% Ceci est tabularcalc_doc_fr.tex, le manuel en français de tabularcalc
% This is tabularcalc_doc_fr.tex, the french manual of tabularcalc
%
% Christian Tellechea 2009
%
% email : unbonpetit@gmail.com
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% This work may be distributed and/or modified under the
% conditions of the LaTeX Project Public License, either version 1.3
% of this license or (at your option) any later version.
% The latest version of this license is in
%
%     http://www.latex-project.org/lppl.txt
%
% and version 1.3 or later is part of all distributions of LaTeX
% version 2005/12/01 or later.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\documentclass[a4paper,10pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[a4paper,dvips,colorlinks=true,hyperfootnotes=false,filecolor=black,linkcolor=blue,urlcolor=magenta,bookmarks=false,pdfauthor={Christian TELLECHEA},pdftitle={tabularcalc},pdfsubject={extension pour construction d'un tableau de valeurs},pdfkeywords={tabularcalc},pdfcreator={LaTeX}]{hyperref}
\usepackage[a4paper,dvips,margin=2.75cm]{geometry}
\usepackage[autolanguage]{numprint}
\usepackage{colortbl}
\usepackage{xcolor}
\usepackage{lmodern}
\usepackage{xspace}
\usepackage{listings}
\usepackage{tabularcalc}
\usepackage[bottom]{footmisc}
\usepackage[frenchb]{babel}
\makeatletter
\definecolor{tc@bckgcolor}{rgb}{1,1,0.875}
\definecolor{tc@keywordstc}{rgb}{0.7,0,0}
\definecolor{tc@keywordslatex}{rgb}{0,0,1}
\definecolor{tc@arguments}{rgb}{0,0,0}
\definecolor{tc@comments}{rgb}{0.5,0.5,0.5}
\lstset{%
	language=[AlLaTeX]TeX,%
	float=hbp,%
	basicstyle=\footnotesize\ttfamily,%
	identifierstyle=\color{tc@arguments},%
	keywordstyle=\color{tc@keywordslatex},%
	commentstyle=\itshape\color{tc@comments},%
	columns=fixed,%
	tabsize=4,%
	frame=single,%
	extendedchars=true,%
	showspaces=false,%
	showstringspaces=false,%
	numbers=left,%
	numberstyle=\tiny\ttfamily,%
	breaklines=true,%
	breakindent=3em,%
	backgroundcolor=\color{tc@bckgcolor},%
	breakautoindent=true,%
	captionpos=t,%
	xleftmargin=1em,%
	xrightmargin=1em,%
	lineskip=0pt,%
	numbersep=1em,
	classoffset=1,%
	morekeywords={% les macros et commandes de tabularcalc
		tccol,tclin,%
		htablecalc,vtablecalc,%
		tcnoshowmark,tcatbeginrow,tcresetcellcode,edefcellcode,defcellcode,%
		tcsethrule,tcresethrule,tcsetcoltype,tcresetcoltype,%
		tcprintvalue,tcprintresult,tclistsep,%
		tcprintroundresult,tcprintroundvalue,tcwritetofile},%
	keywordstyle=\color{tc@keywordstc},%
	classoffset=0}
\makeatother

\newcommand\guill[1]{\og{}#1\fg{}}
\newcommand\argu[1]{$\langle$\textit{#1}$\rangle$}
\newcommand\ARGU[1]{\texttt{\{}\argu{#1}\texttt{\}}}
\newcommand\arguC[1]{\texttt{[}\argu{#1}\texttt{]}}

\newcommand\tbcalc{\textsf{tabularcalc}\xspace}
\newcommand\verbinline{\lstinline[breaklines=false,basicstyle=\normalsize\ttfamily]}
\newcommand\mywidth{0.85\linewidth}

\begin{document}
\setlength{\parindent}{0pt}
\begin{titlepage}
	\null\par\vfill
	\begin{center}
		\begin{minipage}{0.75\linewidth}
			\begin{center}
				\Huge\bfseries \tbcalc\par\vspace{5pt}
				\small v\tabularcalcversion\par\vspace{25pt}
				\normalsize Manuel de l'utilisateur
			\end{center}
		\end{minipage}
	\end{center}
	\vspace{1cm}
	\begin{center}
		Christian {\sc Tellechea}\par\small
		\href{mailto:unbonpetit@gmail.com}{\texttt{\textbf{unbonpetit@gmail.com}}}\par\vspace{5pt}
		\tabularcalcfrenchdate
	\end{center}
	\vfill\hrulefill
	\begin{center}
		\begin{minipage}{0.85\linewidth}
			\noindent
			\hfill\textbf{\textit{Résumé}}\hfill{}\medskip\par
				Étant donné une liste de nombres et une ou plusieurs formules à une variable, cette extension, à l'aide d'une syntaxe simple, construit un tableau de valeurs, c'est-à-dire un tableau dont la première ligne contient les nombres les autres lignes les résultats pris par la (ou les) formules pour chacun des nombres de la liste :
				\begin{center}
					\tcsethrule{\hline}{\hline\hline}{\hline}
					\tcsetcoltype{|c|}{>{\centering\arraybackslash}m{1.5cm}|}
					\htablecalc[3]{$x$}{x=-4,-2,0,2.25,7}
					              {$f(x)=2x-3$}{2*x-3}
					              {$x^2$}{x*x}
					              {$h(x)=\sqrt{x^2+1}$}{round(root(2,x*x+1),6)}
				\end{center}
				Le tableau peut être construit horizontalement ou verticalement, et il est entièrement personnalisable, autant du point de vue des filets, que de la hauteur des lignes ou que des types de colonnes. De plus, le contenu de n'importe quelle cellule du tableau peut être masqué.\smallskip

				Des effets encore plus précis sont possibles puisqu'une commande permet de faire exécuter n'importe quel code dans une cellule particulière.
		\end{minipage}
	\end{center}
	\hrulefill\vfill{}
\end{titlepage}

\tableofcontents

\bigskip
J'adresse mes remerciements à Derek~\textsc{O'Connor} pour l'intérêt qu'il a porté à cette extension et pour les tests qu'il a effecté sur les versions beta que je lui ai envoyées. Ses suggestions ---~pertinentes~--- de nouvelles fonctionnalités m'ont été précieuses. Sans ses conseils, \tbcalc ne serait pas ce qu'il est.\medskip

Merci également à Le \textsc{Huu Dien Khue} qui m'a gentiment proposé de traduire ce manuel en viet-namien.

\section{Introduction}
\subsection{Présentation}
Cette extension permet de construire facilement des tableaux de résultats en évaluant des formules dont la variable prend des valeurs données dans une liste. Les tableaux sont affichés avec l'environnement standard \verb|tabular|. L'affichage des nombres se fait sous forme décimale.

\tbcalc fonctionne sous \LaTeX{} et charge les extensions \href{http://www.ctan.org/tex-archive/macros/latex/contrib/fp/}{\texttt{\textbf{fp}}}, \href{http://www.ctan.org/tex-archive/macros/latex/contrib/xstring/}{\texttt{\textbf{xstring}}} et \href{http://www.ctan.org/tex-archive/macros/latex/contrib/numprint/}{\texttt{\textbf{numprint}}} si ce n'a pas été le cas.

Cette extension n'est pas du tout destinée à entrer en concurrence avec \href{http://www.ctan.org/tex-archive/graphics/pgf/contrib/pgfplots/}{\texttt{\textbf{pgfplotstable}}}, l'excellente extension de Christian~\textsc{Feuers\"anger}. Cette dernière est en effet bien plus personnalisable que \tbcalc au prix cependant d'une syntaxe et d'une difficulté d'utilisation plus grande. \tbcalc se veut plus modeste et privilégie la facilité d'utilisation combinée à des possibilités de personnalisation aisément accessibles.\medskip

En ce qui concerne l'affichage des nombres décimaux dans le tableau, de l'avis de l'auteur, rien ne le fait mieux que l'extension \href{http://www.ctan.org/tex-archive/macros/latex/contrib/numprint/}{\texttt{\textbf{numprint}}} qui est donc également requise. On peut changer le moteur d'affichage des nombres décimaux et/ou entièrement personnaliser l'affichage des nombres (voir page~\pageref{persoaffichage}).

\subsection{L'extension \ttfamily fp}
Du côté des calculs, l'évaluation d'une expression numérique comme \verb|2*x*x-5*x+7| lorsque \hbox{\verb|x = 2.7|} est, avec \TeX{}, une chose complexe que \tbcalc ne réalise pas. Pour cette tâche, il fait appel à un moteur de calcul fourni par l'extension \og\verb=fp=\fg qui offre toutes les fonctions arithmétiques, scientifiques et trigonométriques habituelles.\medskip

On peut utiliser indifféremment la syntaxe infixée ou postfixée. Consulter le fichier \href{http://www.ctan.org/get/macros/latex/contrib/fp/README}{\texttt{\textbf{README}}} de l'extension \verb=fp= pour la liste exhaustive des fonctions disponibles selon la notation employée.\medskip

Sans demander l'autorisation de l'auteur ni même l'en informer\footnote{Je crois que l'auteur a depuis longtemps délaissé le monde de \LaTeX{}.}, je me suis permis de corriger 2 problèmes de l'extension \verb=fp=, tous deux dans la macro \verb=\FPpow=, s'occupant du calcul des puissances :
\parindent2em
\begin{itemize}
	\item tout d'abord, un espace indésirable était ajouté lors du calcul d'une puissance par \verb=fp=;
	\item il y a plus gênant puisque pour calculer $a^b$, \verb=fp= utilise la formule $\mathrm{e}^{b\ln a}$. Il y a un petit problème lorsque $b$ est entier et $a$ est négatif puisqu'alors : $(-3)^2=\mathrm{e}^{2\ln(-3)}$ et le logarithme d'un nombre négatif est indéfini.
\end{itemize}\smallskip

\parindent0pt
Pour laisser \tbcalc corriger ces 2 problèmes, on peut passer l'option \og\verb=fixFPpow=\fg{} au package :
\begin{center}
\begin{minipage}{\mywidth}
\begin{lstlisting}
\usepackage[fixFPpow]{tabularcalc}
\end{lstlisting}
\end{minipage}
\end{center}

\subsection{Ce qui est nouveau}
Hélas, on m'a fait part d'incompatibilité avec d'autres packages car le nom de certaines macros de \tbcalc était déjà utilisé. J'ai donc décidé ---~la mort dans l'âme~--- de renommer les macros publiques, au risque certain de créer une incompatibilite avec la version 0.1; que les utilisateurs m'excusent pour ce désagrément !

Pour éviter tout nouveau risque, je mets donc \og\verb-tc-\fg{} (comme \tbcalc\footnote{Je préfère préciser qu'il s'agit d'un racourci pour \tbcalc et non de mes initiales : je ne suis pas narcissique à ce point !}) devant le nom de presque toutes les macros publiques. Pour ceux qui utilisent déjà \tbcalc, voici tous les changements de nom :
\begin{center}
	\begin{tabular}{rl}
		Ancien nom&Nouveau nom \\\hline
		\verb=\noshowmark=&\verb=\tcnoshowmark=\\
		\verb=\startline=&\verb=\tcatbeginrow=\\
		\verb=\resetcellcode=&\verb=\tcresetcellcode=\\
		\verb=\listsep=&\verb=\tclistsep=\\
		\verb=\printvalue=&\verb=\tcprintvalue=\\
		\verb=\printresult=&\verb=\tcprintresult=\\
		\verb=\sethrule=&\verb=\tcsethrule=\\
		\verb=\resethrule=&\verb=\tcresethrule=\\
		\verb=\setcoltype=&\verb=\tcsetcoltype=\\
		\verb=\resetcoltype=&\verb=\tcresetcoltype=
	\end{tabular}
\end{center}

Autres nouveautés pour ceux qui sont familiers avec cette extension :\parindent2em
\begin{itemize}
	\item les calculs effectués par \verb=pgfmath= étant beaucoup trop imprécis, cette extension est abandonnée au profit de \verb=fp= qui offre une précision bien plus grande;
	\item les valeurs peuvent maintenant être calculées;
	\item on peut désormais écrire le code correspondant à un tableau dans un fichier pour le modifier à la main.
\end{itemize}\parindent0pt

\subsection{Vocabulaire}
Pour que des points de vocabulaire soient clairs par la suite, dans les tableaux triviaux ci-dessous, les nombres en rouge sont les \og{\color{red}valeurs}\fg{}, les nombres en bleu sont les \og{\color{blue}résultats}\fg{}, et les textes en brun sont les \og{\color{brown}labels}\fg{}. La cellule en haut à gauche est la \guill{cellule (0,0)}. Ce vocabulaire sera employé ensuite.

\begin{minipage}{0.5\linewidth}
\begin{center}
{\scriptsize Tableau horizontal}\par\nobreak\smallskip
\def\tcprintvalue#1{\color{red}$#1$}
\def\tcprintresult#1#2{\color{blue}$#1$}
\htablecalc[3]{cellule (0,0)}{x=-5,-1,0,3,10}{\color{brown}$x$}{x}{\color{brown}$2x$}{2*x}{\color{brown}$3x$}{3*x}
\end{center}
\end{minipage}%
\begin{minipage}{0.5\linewidth}
\begin{center}
{\scriptsize Tableau vertical}\par\nobreak\smallskip
\def\tcprintvalue#1{\color{red}$#1$}
\def\tcprintresult#1#2{\color{blue}$#1$}
\vtablecalc[3]{cellule (0,0)}{x=-5,-1,0,3,10}{\color{brown}$x$}{x}{\color{brown}$2x$}{2*x}{\color{brown}$3x$}{3*x}
\end{center}
\end{minipage}

\section{Fonctions basiques}
\subsection{Tableaux horizontaux}
La commande \verbinline|\htablecalc| permet de construire un tableau de valeur horizontal, dont la 1\iere{} ligne contiendra les valeurs, et les lignes suivantes les résultats. La syntaxe est :\smallskip

\setbox0=\hbox{\verbinline|\htablecalc|\arguC{n}}
\verbinline|\htablecalc|\arguC{n}\ARGU{cellule (0,0)}\ARGU{variable=liste val}\par
\hskip\wd0\ARGU{label 1}\ARGU{formule 1}\par
\hskip\wd0\ARGU{label 2}\ARGU{formule 2}\par
\hskip\wd0\ldots\par
\hskip\wd0\ARGU{label n}\ARGU{formule n}\medskip

où :\parindent2em
\begin{itemize}
	\item \argu{n} est le nombre de formules à évaluer. Ce nombre vaut 1 par défaut;
	\item \argu{cellule(0,0)} est le contenu de la cellule (0,0);
	\item \argu{variable} est la variable qui interviendra dans les \argu{formules i} servant à calculer les résultats.
	\item \argu{liste val} est la liste des valeurs, séparées par une virgule. Noter que les valeurs décimales doivent avoir le point comme séparateur décimal;
	\item \argu{label i} est le i\ieme{} label;
	\item \argu{formule i} est la i\ieme{} formule qui servira à évaluer les résultats de la i\ieme{} ligne.
\end{itemize}\parindent0em
\medskip

Dans la liste de valeurs, le séparateur par défaut est la virgule qui est le développement de \verbinline|\tclistsep|, et pour changer ce séparateur en \guill{|} par exemple, il faut écrire : \verbinline=\def\tclistsep{|}=\medskip

À titre d'exemple, voici un premier essai pour obtenir le tableau de la première page :
\begin{center}
\begin{minipage}{\mywidth}
\begin{lstlisting}
\htablecalc[3]{$x$}{x=-4,-2,0,2.25,7}
              {$f(x)=2x-3$}{2*x-3}
              {$x^2$}{x*x}
              {$h(x)=\sqrt{x^2+1}$}{round(root(2,x*x+1),6)}
\end{lstlisting}
\end{minipage}
\htablecalc[3]{$x$}{x=-4,-2,0,2.25,7}
              {$f(x)=2x-3$}{2*x-3}
              {$x^2$}{x*x}
              {$h(x)=\sqrt{x^2+1}$}{round(root(2,x*x+1),6)}
\end{center}
On peut observer que le tableau n'est pas strictement identique à celui de la première page : les colonnes contenant les résultats ne sont pas toutes de la même largeur et le filet sous la 1\iere{} ligne est différent. Nous verrons comment personnaliser tout cela plus loin.

\subsection{Tableaux verticaux}
La commande \verbinline|\vtablecalc| permet de construire un tableau de valeur vertical, dont la 1\iere{} colonne contiendra les valeurs, et les colonnes suivantes les résultats. La syntaxe est :\smallskip

\setbox0=\hbox{\verbinline|\vtablecalc|\arguC{n}}
\verbinline|\vtablecalc|\arguC{n}\ARGU{cellule (0,0)}\ARGU{variable=liste val}\par
\hskip\wd0\ARGU{label 1}\ARGU{formule 1}\par
\hskip\wd0\ARGU{label 2}\ARGU{formule 2}\par
\hskip\wd0\ldots\par
\hskip\wd0\ARGU{label n}\ARGU{formule n}\medskip

où :\parindent2em
\begin{itemize}
	\item \argu{n} est le nombre de formules à évaluer. Ce nombre vaut 1 par défaut;
	\item \argu{cellule(0,0)} est le contenu de la cellule (0,0);
	\item \argu{variable} est la variable qui interviendra dans les \argu{formules i} servant à calculer les résultats;
	\item \argu{liste val} est la liste des valeurs, séparées par une virgule. Noter que les valeurs décimales doivent avoir le point comme séparateur décimal;
	\item \argu{label i} est le i\ieme{} label;
	\item \argu{formule i} est la i\ieme{} formule qui servira à évaluer les résultats de la i\ieme{} ligne.
\end{itemize}\parindent0em
\medskip

À titre d'exemple, voici le tableau précédent présenté verticalement, mais où l'on prend la variable des formules comme étant \verb=y= :\par\nobreak
\begin{center}
\begin{minipage}{\mywidth}
\begin{lstlisting}
\vtablecalc[3]{$x$}{y=-4,-2,0,2.25,7}
              {$f(x)=2x-3$}{2*y-3}
              {$x^2$}{y*y}
              {$h(x)=\sqrt{x^2+1}$}{round(root(2,y*y+1),6)}
\end{lstlisting}
\end{minipage}

\vtablecalc[3]{$x$}{y=-4,-2,0,2.25,7}
              {$f(x)=2x-3$}{2*y-3}
              {$x^2$}{y*y}
              {$h(x)=\sqrt{x^2+1}$}{round(root(2,y*y+1),6)}
\end{center}

\subsection{Masquer des cellules}\label{masquercellules}
On peut masquer le contenu de n'importe quelle cellule, aussi bien dans un tableau horizontal que vertical.

\subsubsection{Masquer une valeur}
Si on veut masquer une valeur, il suffit de la faire précéder d'un \og\verb|@|\fg dans la liste. Dans l'exemple suivant, on masque la 2\ieme{} et la 5\ieme{} valeur :\smallskip
\begin{center}
\begin{minipage}{\mywidth}
\begin{lstlisting}
\htablecalc[3]{$x$}{x=-4,@-2,0,2.25,@7}
              {$f(x)=2x-3$}{2*x-3}
              {$x^2$}{x*x}
              {$h(x)=\sqrt{x^2+1}$}{round(root(2,x*x+1),6)}
\end{lstlisting}
\end{minipage}

\htablecalc[3]{$x$}{x=-4,@-2,0,2.25,@7}
              {$f(x)=2x-3$}{2*x-3}
              {$x^2$}{x*x}
              {$h(x)=\sqrt{x^2+1}$}{round(root(2,x*x+1),6)}
\end{center}
\medskip

Le token \og\verb|@|\fg est en réalité le développement de la commande \verbinline|\tcnoshowmark|. Pour changer le token qui masque une valeur, il suffit de redéfinir cette macro. Par exemple, pour faire tenir ce rôle au signe \og=\fg, on écrirait \verbinline|\def\tcnoshowmark{=}|

\subsubsection{Masquer un résultat}
Pour une valeur donnée, si on veut masquer les résultats numéro $a_1,a_2,\ldots,a_n$, il suffit de faire suivre cette valeur par $[a_1][a_2]\ldots[a_n]$ où les nombres $a_i$ sont dans l'ordre croissant. Si un des nombres $a_j$ vaut 0, tous les autres $a_k$ où $k>j$ sont ignorés et tous les résultats qui suivront le précédent résultat masqué seront masqués.\medskip

Dans l'exemple qui suit, on va :\parindent2em
\begin{itemize}
	\item masquer le 2\ieme{} résultat de la première valeur avec \og\verb|-4[2]|\fg
	\item laisser tous les résultats de la 2\ieme{} valeur avec \og\verb|-2|\fg
	\item masquer les résultats \no{} 1 et 3 de la troisième valeur avec \og\verb|0[1][3]|\fg
	\item masquer tous les résultats de la 4\ieme{} valeur avec \og\verb|2.25[0]|\fg
	\item masquer tous les résultats à partir du 2\ieme{} pour la 5\ieme{} valeur avec \og\verb|7[2][0]|\fg
\end{itemize}\parindent0em

\begin{center}
\begin{minipage}{\mywidth}
\begin{lstlisting}
\htablecalc[3]{$x$}{x=-4[2],-2,0[1][3],2.25[0],7[2][0]}
              {$f(x)=2x-3$}{2*x-3}
              {$x^2$}{x*x}
              {$h(x)=\sqrt{x^2+1}$}{round(root(2,x*x+1),6)}
\end{lstlisting}
\end{minipage}

\htablecalc[3]{$x$}{x=-4[2],-2,0[1][3],2.25[0],7[2][0]}
              {$f(x)=2x-3$}{2*x-3}
              {$x^2$}{x*x}
              {$h(x)=\sqrt{x^2+1}$}{round(root(2,x*x+1),6)}
\end{center}
On peut combiner cette syntaxe avec \verb|@| pour masquer à la fois la valeur et certains résultats.

\subsection{Hauteur des lignes}
Au début de chaque ligne, lors de son affichage, la commande \verbinline|\tcatbeginrow| est exécutée.

Par défaut, cette commande est définie par : \verbinline|\def\tcatbeginrow{\rule[-1.2ex]{0pt}{4ex}}|. Cette commande se développe donc par défaut en un \guill{strut} qui fixe la hauteur de la ligne. Voici ce strut, rendu visible devant la lettre a : \rule[-1.2ex]{2pt}{4ex}a\medskip

On peut donc faire exécuter un autre strut ou tout autre action au début d'une ligne :
\begin{center}
\begin{minipage}{\mywidth}
\begin{lstlisting}
\def\tcatbeginrow{%
	{\bfseries\number\tclin)\ }%
}
\htablecalc[3]{$x$}{x=-4,-2,0,2.25,7}
              {$f(x)=2x-3$}{2*x-3}
              {$x^2$}{x*x}
              {$h(x)=\sqrt{x^2+1}$}{round(root(2,x*x+1),6)}
\end{lstlisting}
\end{minipage}

\def\tcatbeginrow{%
	{\bfseries\number\tclin)\ }%
}
\htablecalc[3]{$x$}{x=-4,-2,0,2.25,7}
              {$f(x)=2x-3$}{2*x-3}
              {$x^2$}{x*x}
              {$h(x)=\sqrt{x^2+1}$}{round(root(2,x*x+1),6)}
\end{center}
Ici, on ne définit aucun strut (on redonne donc aux lignes leur hauteur naturelles) et on affiche en gras le numéro de la ligne en cours (qui est contenue dans le compteur \verbinline|\tclin|) à la ligne 2 du code.

\subsection{Filets horizontaux}
\tbcalc permet de définir 3 types de filets horizontaux. Pour cela, la commande \verbinline|\tcsethrule| admet 3 arguments :

\parindent2em
\begin{itemize}
	\item le \guill{filet 0} affiché en haut et en bas du tableau;
	\item le \guill{filet 1} affiché sous la première ligne;
	\item les \guill{autres filets} affichés sous les lignes de résultats (sauf la dernière qui reçoit le filet de bas de tableau).
\end{itemize}\parindent0em
Voici la syntaxe :

\verbinline|\tcsethrule|\ARGU{filet 0}\ARGU{filet 1}\ARGU{autres filets}
\medskip

Par défaut, les 3 arguments valent \verbinline|\hline|.\medskip

Voici un exemple où le filet sous la première ligne est double et les autres filets sont supprimés :
\begin{center}
\begin{minipage}{\mywidth}
\begin{lstlisting}
\tcsethrule{\hline}{\hline\hline}{}
\htablecalc[3]{$x$}{x=-2,-1,0,1,2,3}
              {$2x$}{2*x}
              {$3x$}{3*x}
              {$4x$}{4*x}
\end{lstlisting}
\end{minipage}

\tcsethrule{\hline}{\hline\hline}{}
\htablecalc[3]{$x$}{x=-2,-1,0,1,2,3}
              {$2x$}{2*x}
              {$3x$}{3*x}
              {$4x$}{4*x}
\end{center}

La commande \verbinline|\tcresethrule| permet de revenir aux filets horizontaux définis par défaut.

\subsection{Personnalisation des colonnes}
\subsubsection{Filets verticaux}
\tbcalc permet de définir 2 types de colonnes : le type de la colonne de gauche et le type des autres colonnes. La commande \verbinline|setcoltype| admet un argument optionnel et 2 arguments obligatoires :
\begin{itemize}
	\item l'argument optionnel, vide par défaut, définit les filets verticaux \guill{|} affichés à la droite du tableau;
	\item le type 1 de la première colonne qui est prédéfini à \guill{|c|};
	\item le type 2 des autres colonnes qui est prédéfini à \guill{c|}
\end{itemize}\medskip

La syntaxe est :\par\nobreak
\verbinline|\tcsetcoltype|\arguC{filets de droite}\ARGU{type 1}\ARGU{type 2}\medskip

Voici un exemple :
\begin{center}
\begin{minipage}{\mywidth}
\begin{lstlisting}
\tcsetcoltype[||]{||c||}{c}
\htablecalc[3]{$x$}{x=-2,-1,0,1,2,3}
              {$2x$}{2*x}
              {$3x$}{3*x}
              {$4x$}{4*x}
\end{lstlisting}
\end{minipage}

\tcsetcoltype[||]{||c||}{c}
\htablecalc[3]{$x$}{x=-2,-1,0,1,2,3}
              {$2x$}{2*x}
              {$3x$}{3*x}
              {$4x$}{4*x}
\end{center}

La commande \verbinline|\tcresetcoltype| permet de revenir aux types de colonne définis par défaut.

\subsubsection{Largeur des colonnes}
Au lieu de l'habituel spécificateur de colonne \guill{c} que nous avons utilisé jusqu'à présent, on peut spécifier la largeur des colonnes avec le spécificateur \guill{m} de l'extension \href{http://www.ctan.org/tex-archive/graphics/pgf/base/latex/pgf/basiclayer/}{\texttt{\textbf{array}}} de cette façon : \og\verb|m{1.5cm}|\fg{}.\medskip

Voici un exemple où la 1\iere{} colonne est centrée à droite, les colonnes de résultats sont centrées et mesurent \numprint[cm]{1.5} de large :
\begin{center}
\begin{minipage}{\mywidth}
\begin{lstlisting}
\usepackage{array}
\tcsetcoltype{|r|}{>{\centering\arraybackslash}m{1.5cm}|}
\htablecalc[3]{$x$}{x=-4,-2,0,2.25,7}
              {$f(x)=2x-3$}{2*x-3}
              {$x^2$}{x*x}
              {$h(x)=\sqrt{x^2+1}$}{round(root(2,x*x+1),6)}
\end{lstlisting}
\end{minipage}

\tcsetcoltype{|r|}{>{\centering\arraybackslash}m{1.5cm}|}
\htablecalc[3]{$x$}{x=-4,-2,0,2.25,7}
              {$f(x)=2x-3$}{2*x-3}
              {$x^2$}{x*x}
              {$h(x)=\sqrt{x^2+1}$}{round(root(2,x*x+1),6)}
\end{center}

\section{Calculer les valeurs}
Lorsque les valeurs sont assez nombreuses et suivent une règle mathématique, il peut être plus simple de saisir la formule que toutes les valeurs. Ainsi la syntaxe :
\begin{center}
\begin{minipage}{\mywidth}
\begin{lstlisting}
\htablecalc[2]{$x$}{x=-3,-1,1,3,5,7,9,11,13}
              {$2x$}{2*x}
              {$x^2$}{x*x}
\end{lstlisting}
\end{minipage}
\end{center}
peut être saisie ainsi :
\begin{center}
\begin{minipage}{\mywidth}
\begin{lstlisting}
\htablecalc[2]{$x$}{x=a;a=-3:13[2]}
              {$2x$}{2*x}
              {$x^2$}{x*x}
\end{lstlisting}
\end{minipage}
\end{center}
La présence du \og\verb=;=\fg{} change la façon d'analyser l'argument contenant les valeurs : on exprime à droite du signe \og\verb=;=\fg{} que la variable muette \og\verb=a=\fg{} va parcourir l'intervalle $-3\ldots13$ avec un incrément de 2. Les valeurs seront donc des entiers \emph{impair}. À gauche de \og\verb=;=\fg{}, on exprime que la variable intervenant dans les formules ---~ ici \verb=x=~--- va être égale à \verb=a= donc prendra elle aussi les valeurs impaires de $-3$ à 13.

On aurait pu aussi générer l'argument \verb|{x=-3,-1,1,3,5,7,9,11,13}| avec  \verb|{x=2*a+1:a=-2:6}|. Cette fois-ci l'incrément vaut 1 par défaut. Il y plusieurs façons de parvenir à ces mêmes valeurs, celle-ci par exemple : \verb|{x=2*a-3;a=0:8}|\bigskip

Lorsqu'on utilise un argument avec \og\verb=;=\fg{}, on perd la possibilité de masquer des cellules comme vu à la page~\pageref{masquercellules}. Il faut aussi prendre garde au nombres de valeurs générées afin que le tableau ne devienne pas gigantesque.\medskip

Avec cette syntaxe, l'argument contenant les valeurs se présente sous cette forme :\par\smallskip\nobreak
\hfill\argu{variable 1}\verb|=|\argu{formule}\verb|;|\argu{variable 2}\verb|=|\argu{min}\verb|:|\argu{max}\arguC{incrément}\hfill{}\smallskip

où :
\parindent2em
\begin{itemize}
	\item \argu{variable 1} est la variable intervenant dans les formules servant à évaluer les résultats;
	\item \argu{variable 2} est la variable intervenant dans les formules servant à évaluer les valeurs. Elle doit être différente de \argu{variable 1}.
	\item \argu{formule} est la formule qui va évaluer les différentes valeurs.  La variable intervenant dans cette formule est \argu{variable 2};
	\item \argu{min}\verb|:|\argu{max} représentent l'intervalle dans lequel doit varier la \argu{variable 2};
	\item \argu{incrément} est le pas d'incrémentation, il est facultatif et vaut \verb=1= par défaut. Il ne doit pas être nul.
\end{itemize}\parindent0em
\medskip

Comme on l'a vu, il y a de plusieurs façons différentes de générer les mêmes valeurs. Ainsi, les valeurs \texttt{\{0,1,2,3,4,5,6,7,8,9,10\}} sont générées par :

\parindent2em
\begin{itemize}
	\item \verb|{z=x;x=0:10}| et \og\verb=z=\fg{} sera la variable des formules;
	\item \verb|{n=2*a;a=0:5[0.5]}| et \og\verb=n=\fg{} sera la variable des formules;
	\item \verb|{x=y/10;y=0:100[10]}| et \og\verb=x=\fg{} sera la variable des formules;
\end{itemize}
\parindent0pt\medskip

Il va sans dire que l'intervalle et l'incrément doivent être cohérents entre-eux. Un argument \verb|0:10[-1]| va provoquer message d'erreur de \tbcalc !\medskip

À titre d'exemple, voici un tableau utilisant les fonctions trigonométriques de \verb|fp|:
\begin{center}
\begin{minipage}{\mywidth}
\begin{lstlisting}
\htablecalc[6]{$x$\ [deg]}{x=a;a=15:75[15]}
              {$\sin x$}{round(sin(x*pi/180),6)}
              {$\cos x$}{round(cos(x*pi/180),6)}
              {$\tan x$}{round(tan(x*pi/180),6)}
              {$\sin^2x$}{round(sin(x*pi/180)^2,6)}
              {$\cos^2x$}{round(cos(x*pi/180)^2,6)}
              {$\tan^2x$}{round(tan(x*pi/180)^2,6)}
\end{lstlisting}
\end{minipage}

\htablecalc[6]{$x$\ [deg]}{x=a;a=15:75[15]}
              {$\sin x$}{round(sin(x*pi/180),6)}
              {$\cos x$}{round(cos(x*pi/180),6)}
              {$\tan x$}{round(tan(x*pi/180),6)}
              {$\sin^2x$}{round(sin(x*pi/180)^2,6)}
              {$\cos^2x$}{round(cos(x*pi/180)^2,6)}
              {$\tan^2x$}{round(tan(x*pi/180)^2,6)}
\end{center}
\medskip

Et un autre tableau qui affiche des puissances de 10, leur logarithme décimal, leur racine carrée et leur inverse :
\begin{center}
\begin{minipage}{\mywidth}
\begin{lstlisting}
\htablecalc[3]{Puissances de 10}{x=round(10^n,4);n=-3:3}
              {Logarithme d\'ecimal}{ln(x)/ln(10)}
              {Racine carr\'ee}{round(root(2,x),3)}
              {Inverse}{1/x}
\end{lstlisting}
\end{minipage}

\htablecalc[3]{Puissances de 10}{x=round(10^n,4);n=-3:3}
              {Logarithme d\'ecimal}{ln(x)/ln(10)}
              {Racine carr\'ee}{round(root(2,x),3)}
              {Inverse}{1/x}
\end{center}

\section{Personnalisation avancée}
\subsection{Exécution d'un code dans une cellule}
La macro \verbinline|\defcellcode| permet d'exécuter un code donné dans une cellule, une colonne entière ou une ligne entière de son choix. Pour cela, les cellules du tableau sont repérées avec des coordonnées que voici :\smallskip

\begin{center}
	\def\tcprintvalue#1{}\def\tcprintresult#1#2{}
	\edefcellcode{}{}{(\number\tclin,\number\tccol)}
	\htablecalc[3]{}{x=1,2,3,4,5}{}{x}{}{x}{}{x}
\end{center}
\medskip

En interne, la 1\iere{} coordonnée ---~le numéro de la ligne~--- est contenu dans le compteur \verbinline{\tclin}, tandis que le numéro de la colonne est contenu dans le compteur \verbinline{\tccol}.\smallskip

Voici la syntaxe de cette commande :

\verbinline|\defcellcode|\ARGU{nombre 1}\ARGU{nombre 2}\ARGU{code}
\smallskip

où :\parindent2em
\begin{itemize}
	\item \ARGU{nombre 1} est la première coordonnées, le numéro de la ligne;
	\item \ARGU{nombre 2} est la deuxième coordonnées, le numéro de la colonne;
	\item \ARGU{code} est le code qui sera exécuté lorsque la cellule choisie sera affichée : ce code ne sera développé qu'à ce moment là;
	\item Si \ARGU{nombre 1} est vide, toutes les lignes sont concernées;
	\item Si \ARGU{nombre 2} est vide, toutes les colonnes sont concernées;
\end{itemize}\parindent0em
\smallskip

Il faut noter que le code ainsi défini est exécuté \emph{lors de l'affichage de la cellule}, et à ce moment là, la valeur du compteur \verbinline|\tccol| ne contient plus le numéro de la colonne de la cellule : il n'est donc pas question d'impliquer \verbinline|\tccol| dans le code défini par la commande \verbinline|\defcellcode|. Par contre, le compteur \verbinline|\tclin| contient bien le numéro de la ligne en cours d'affichage.

Si la commande \verbinline|\defcellcode| est appelée plusieurs fois pour définir des codes différents, et si plusieurs codes concernent une même cellule, les codes seront exécutés dans l'ordre où ils ont été définis.\medskip

Voici un exemple où, à l'aide de l'extension \verb|xcolor|, on choisit d'écrire en bleu le contenu de la cellule (2~,~3), d'écrire en rouge le contenu de la ligne 1, et en brun le contenu de la colonne 4.
\begin{center}
\begin{minipage}{\mywidth}
\begin{lstlisting}
\usepackage{color}
\defcellcode{2}{3}{\color{blue}}
\defcellcode{1}{}{\color{red}}
\defcellcode{}{4}{\color{brown}}
\htablecalc[3]{$x$}{x=-2,-1,0,1,2,3}
              {$2x$}{2*x}
              {$3x$}{3*x}
              {$4x$}{4*x}
\end{lstlisting}
\end{minipage}

\defcellcode{2}{3}{\color{blue}}
\defcellcode{1}{}{\color{red}}
\defcellcode{}{4}{\color{brown}}
\htablecalc[3]{$x$}{x=-2,-1,0,1,2,3}
              {$2x$}{2*x}
              {$3x$}{3*x}
              {$4x$}{4*x}
\end{center}

On peut observer que la cellule (1 , 4) qui contient {\color{brown}\numprint{2}} a été colorée en brun. En effet, elle a d'abord été colorée en rouge (ligne 3 du code) \emph{puis} colorée en brun (ligne 4 du code).\bigskip

Il existe une autre commande similaire qui exécute du code qui est \verbinline|\edefcellcode| : cette fois ci, le code est exécuté une première fois lors de la construction de la cellule, alors que le compteur \verbinline|\tccol| contient bien le numéro de la colonne de la cellule. Lors de cette première exécution, le code est développé au maximum avec un \verbinline|\edef|\footnote{Il convient de mettre un \texttt{\string\noexpand} devant les commandes que l'on ne veut pas développer à ce moment là.}. Le développement obtenu est exécuté une seconde fois lors de l'affichage de la cellule.\medskip

Voici un exemple où le texte dans toutes les colonnes supérieures à la colonne \no{}2 est coloré en bleu :
\begin{center}
\begin{minipage}{\mywidth}
\begin{lstlisting}
\usepackage{color}
\edefcellcode{}{}{%
	\ifnum\tccol>2 \noexpand\color{blue}\fi}
\htablecalc[3]{$x$}{x=-2,-1,0,1,2,3}
              {$2x$}{2*x}
              {$3x$}{3*x}
              {$4x$}{4*x}
\end{lstlisting}
\end{minipage}

\edefcellcode{}{}{%
	\ifnum\tccol>2 \noexpand\color{blue}\fi}
\htablecalc[3]{$x$}{x=-2,-1,0,1,2,3}
              {$2x$}{2*x}
              {$3x$}{3*x}
              {$4x$}{4*x}
\end{center}

\subsection{Personnaliser l'affichage}
\subsubsection{Les macros {\ttfamily\textbackslash printvalue} et {\ttfamily\textbackslash printresult}}\label{persoaffichage}
Pour afficher une valeur, la commande \verbinline|\tcprintvalue| est appelée. Elle admet un argument qui est le nombre décimal à afficher qui provient de \verb|fp| et se présente sous forme brute c'est-à-dire \verb|12345.6789| par exemple pour \numprint{12345.6789}.

Par défaut, \verbinline|\tcprintvalue| est définie par le code suivant :\par\nobreak\smallskip
\hfill\verbinline|\def\tcprintvalue#1{\numprint{#1}}|\hfill{}
\smallskip

On voit que la commande \verb|\numprint| est appelée pour donner un affichage soigné.\bigskip

Pour afficher un résultat, la commande \verbinline|\tcprintresult| est appelée. Elle admet \textbf{deux} arguments; le premier est le résultat provenant de \verb|fp| et le deuxième est la valeur qui a servi à calculer le résultat, telle qu'elle a été saisie dans la liste de valeurs.

Par défaut, \verbinline|\tcprintresult| est définie par le code suivant :\par\nobreak\smallskip
\hfill\verbinline|\def\tcprintresult#1#2{\numprint{#1}}|\hfill{}
\smallskip

On peut observer que l'argument \verb|#2| (la valeur) n'est pas exploitée par \verbinline|\tcprintresult|. On peut cependant imaginer un exemple où elle le serait. Sur cet exemple, on affiche un \verb|X| rouge lorsque la dimension du côté du carré (qui est l'argument \verb|#2|) est négative. Sinon, on affiche le résultat avec l'unité. En plus, on affiche en bleu tout résultat inférieur à 10 :\par\nobreak
\begin{center}
\begin{minipage}{\mywidth}
\begin{lstlisting}
\usepackage{color}
\def\tcprintresult#1#2{%
	\ifdim#1pt<10pt\color{blue}\fi
	\ifdim#2pt<0pt
		\color{red}\texttt{X}%
	\else
		\numprint[cm^2]{#1}%
	\fi}
\htablecalc{longueur}{x=0.7,-10,3,-2,5,12}
           {aire du carr\'e}{x*x}
\end{lstlisting}
\end{minipage}

\def\tcprintresult#1#2{%
	\ifdim#1pt<10pt\color{blue}\fi
	\ifdim#2pt<0pt
		\color{red}\texttt{X}%
	\else
		\numprint[cm^2]{#1}%
	\fi}
\htablecalc{longueur}{x=0.7,-10,3,-2,5,12}{aire du carr\'e}{x*x}
\end{center}

\subsubsection{Gérer les arrondis}
Les calculs faits par \verb|fp| ont une grande précision $\left(10^{-12}\right)$ et les développements décimaux ont parfois beaucoup de chiffres après la virgule. Voici par exemple $\sqrt{10}$ calculé par \verb=fp= :
\begin{center}\FPeval\truc{root(2,10)}\numprint\truc\end{center}
Les 11 premiers chiffres sont exacts, le 12\ieme{} est arrondi.\medskip

Pour les résultats, on peut utiliser la fonction \verb|round(nombre,precision)| de \verb|fp|. Si l'on ne veut pas alourdir la syntaxe des formules, on peut aussi utiliser la commande \verbinline|\tcprintroundresult| offerte par \tbcalc. Son argument est le nombre de chiffres après la virgule que l'on veut voir affichés. La macro étoilée \verbinline|\tcprintroundresult*| complète le nombre avec des 0 inutiles si nécessaire. Si l'argument est vide, la macro est neutralisée, et aucun arrondi n'est fait (comprtement par défaut).
\begin{center}
\begin{minipage}{0.5\linewidth}
\begin{center}
\begin{lstlisting}
\tcprintroundresult{3}
\htablecalc{$x$}{x=2,3,4,5}
           {$\sqrt{x}$}{root(2,x)}
\end{lstlisting}
\tcprintroundresult{3}
\htablecalc{$x$}{x=2,3,4,5}
           {$\sqrt{x}$}{root(2,x)}
\end{center}
\end{minipage}%
\begin{minipage}{0.5\linewidth}
\begin{center}
\begin{lstlisting}
\tcprintroundresult*{3}
\htablecalc{$x$}{x=2,3,4,5}
           {$\sqrt{x}$}{root(2,x)}
\end{lstlisting}
\tcprintroundresult*{3}
\htablecalc{$x$}{x=2,3,4,5}
           {$\sqrt{x}$}{root(2,x)}
\end{center}
\end{minipage}
\end{center}

En ce qui concerne les valeurs calculées, il est \textbf{déconseillé} d'utiliser la fonction \verb|round| puisque si tel était le cas, la valeur arrondie serait utilisée pour le calculs des résultats. En voici la démonstration sur cet exemple où l'on prend comme valeurs les valeurs arrondies à $10^{-2}$ les racines carrées des entiers de 2 à 4 que l'on élève ensuite au carré :
\begin{center}
\begin{minipage}{0.75\linewidth}
\begin{lstlisting}
\htablecalc{racines}{x=round(root(2,k),2);k=2:4}
            {carr\'e}{x*x}
\end{lstlisting}
\end{minipage}

\htablecalc{racines}{x=round(root(2,k),2);k=2:4}
            {carr\'e}{x*x}
\end{center}
Les erreurs d'arrondis des valeurs se retrouvent dans les résultats.

Il convient donc d'utiliser \verbinline|\tcprintroundvalue| dont le fonctionnement et la syntaxe sont les mêmes que \verbinline|\tcprintroundresult| :
\begin{center}
\begin{minipage}{\mywidth}
\begin{lstlisting}
\tcprintroundvalue{2}
\htablecalc{racines}{x=root(2,k);k=2:4}
            {carr\'e}{x*x}
\end{lstlisting}
\end{minipage}

\tcprintroundvalue{2}
\htablecalc{racines}{x=root(2,k);k=2:4}
            {carr\'e}{x*x}
\end{center}
Les résultats ---~non arrondis, eux!~--- sont bien plus proches des entiers attendus.

\subsubsection{Pour le fun}
On peut imaginer des détournements de \tbcalc, comme par exemple afficher un échiquier dont les cases mesurent \numprint[cm]{0.5} de côté :\par\nobreak\parindent2em
\begin{itemize}
	\item on initialise à \verb|0pt| les séparateurs du tableau à la ligne 1 pour ne pas fausser la dimension voulue de \numprint[cm]{0.5};
	\item l'affichage de toutes les valeurs et résultats est neutralisé à la ligne 2;
	\item ensuite on ne dessine que les filets horizontaux du haut et du bas du tableau (ligne 3), et les filets de gauche et droite (ligne 4);
	\item on définit un strut de hauteur \numprint[cm]{0.5} au début de chaque ligne (ligne 5);
	\item et on teste si la somme de la ligne et de la colonne en cours est impaire (ligne 7) auquel cas, on colore la case en gris (ligne 8).
\end{itemize}\parindent0em
\begin{center}
\begin{minipage}{\mywidth}
\begin{lstlisting}
\arraycolsep=0pt\tabcolsep=0pt
\def\tcprintvalue#1{}\def\tcprintresult#1#2{}
\tcsethrule{\hline}{}{}
\tcsetcoltype[|]{|m{0.5cm}}{m{0.5cm}}
\def\tcatbeginrow{\rule[-0.2cm]{0pt}{0.3cm}}
\edefcellcode{}{}{%
	\ifodd\numexpr\tccol+\tclin\relax
		\noexpand\cellcolor{lightgray}\fi
}
\htablecalc[7]{}{x=1,2,3,4,5,6,7}
	{}{x}{}{x}{}{x}{}{x}{}{x}{}{x}{}{x}
\end{lstlisting}
\end{minipage}

\arraycolsep=0pt\tabcolsep=0pt
\def\tcprintvalue#1{}\def\tcprintresult#1#2{}
\tcsethrule{\hline}{}{}
\tcsetcoltype[|]{|m{0.5cm}}{m{0.5cm}}
\def\tcatbeginrow{\rule[-0.2cm]{0pt}{0.3cm}}
\edefcellcode{}{}{%
	\ifodd\numexpr\tccol+\tclin\relax
		\noexpand\cellcolor{lightgray}\fi
}
\htablecalc[7]{}{x=1,2,3,4,5,6,7}
	{}{x}{}{x}{}{x}{}{x}{}{x}{}{x}{}{x}
\end{center}

\section{Exporter un tableau dans un fichier}
Aussi personnalisable qu'il soit, \tbcalc ne peut couvrir tous les cas, et des ajustements fins sont parfois nécessaires dans les tableaux générés. La commande \verbinline=\tcwritetofile=\ARGU{filename} admet un argument obligatoire qui est un nom de fichier sans l'extension. Le première instruction \verbinline=\htablecalc= ou \verbinline=\vtablecalc= qui suit cette commande ne produira pas l'affichage d'un tableau, mais un fichier \argu{filename}\verb|.tex| sera créé dans le répertoire courant dont le contenu sera le code \TeX{} du tableau.\medskip

Voyons ceci sur un exemple :
\begin{center}
\begin{minipage}{\mywidth}
\begin{lstlisting}
\tcwritetofile{mytable}
\defcellcode{}{2}{\color{blue}}
\htablecalc[2]{$x$}{x=k;k=0:4}
               {$2x$}{2*x}
               {$x^2$}{x*x}
\tcresetcellcode
\end{lstlisting}
\end{minipage}
\end{center}
\tcwritetofile{mytable}
\defcellcode{}{2}{\color{blue}}
\htablecalc[2]{$x$}{x=k;k=0:4}
               {$2x$}{2*x}
               {$x^2$}{x*x}
\tcresetcellcode

Un fichier \og\verb=mytable.tex=\fg{} est créé dans le répertoire courant et son contenu est le code du tableau qui aurait dû être affiché :
\begin{center}
\begin{minipage}{\mywidth}
\begin{lstlisting}
\begin {tabular}{|c|*{5}{c|}}\hline
\tcatbeginrow $x$&\tcprintvalue {0}&\color {blue}\tcprintvalue {1}&\tcprintvalue {2}&\tcprintvalue {3}&\tcprintvalue {4}\\\hline
\tcatbeginrow $2x$&\tcprintresult {0}{0}&\color {blue}\tcprintresult {2}{1}&\tcprintresult {4}{2}&\tcprintresult {6}{3}&\tcprintresult {8}{4}\\ \hline
\tcatbeginrow $x^2$&\tcprintresult {0}{0}&\color {blue}\tcprintresult {1}{1}&\tcprintresult {4}{2}&\tcprintresult {9}{3}&\tcprintresult {16}{4}\\ \hline
\end {tabular}
\end{lstlisting}
\end{minipage}
\end{center}
Cela laisse à l'utilisateur le loisir de modifier ce code à sa convenance puis d'inclure ce fichier à tout moment dans le code \LaTeX{} d'un document avec :
\begin{center}
\begin{minipage}{\mywidth}
\begin{lstlisting}
\input{mytable.tex}
\end{lstlisting}
\end{minipage}
\end{center}
et voici le résultat :
\begin{center}
\input{mytable.tex}
\end{center}

\section{Utiliser la notations infixée et postfixée}
La notation infixée ou postfixée peut-être utilisée indifféremment puisque \tbcalc utilise \verb=\FPeval= qui accepte les deux. Dans cet exemple, le même tableau est généré avec la notation infixée puis avec la notation postfixée. Les résultats obtenus sont évidemment strictement les mêmes puisque le moteur de calcul est le même; seule la notation change :
\begin{center}
\begin{minipage}{\mywidth}
\begin{lstlisting}
\tcprintroundvalue{6}
\tcprintroundresult{6}
Avec la notation infix\'ee\par
\htablecalc[3]{$x=10^k$ o\`u $k\in[-3;3]$}{x=10^k;k=-3:3}
               {$\log x$}{ln(x)/ln(10)}
               {$\sqrt{x}$}{root(2,x)}
               {$\frac{1}{x}$}{1/x}

\medskip
Avec la notation postfix\'ee\par
\htablecalc[3]{$x=10^k$ o\`u $k\in[-3;3]$}{x=k 10 pow;k=-3:3}
               {$\log x$}{x ln 10 ln div}
               {$\sqrt{x}$}{2 x root}
               {$\frac{1}{x}$}{1 x div}
\end{lstlisting}
\end{minipage}

\tcprintroundvalue{6}
\tcprintroundresult{6}
Avec la notation infix\'ee\par\nobreak
\htablecalc[3]{$x=10^k$ o\`u $k\in[-3;3]$}{x=10^k;k=-3:3}
               {$\log x$}{ln(x)/ln(10)}
               {$\sqrt{x}$}{root(2,x)}
               {$\frac{1}{x}$}{1/x}

\medskip
Avec la notation postfix\'ee\par
\htablecalc[3]{$x=10^k$ o\`u $k\in[-3;3]$}{x=k 10 pow;k=-3:3}
               {$\log x$}{x ln 10 ln div}
               {$\sqrt{x}$}{2 x root}
               {$\frac{1}{x}$}{1 x div}
\end{center}
On préfèrera ---~ dans la mesure où on la maîtrise~--- la notation postfixée qui permet bien souvent d'économiser du temps de calcul. Ainsi, le calcul $\cos x(1-\cos x)$ s'écrit ainsi en notation infixée
\begin{center}
\begin{minipage}{\mywidth}
\begin{lstlisting}
cos(x)*(1-cos(x))
\end{lstlisting}
\end{minipage}
\end{center}
Ce qui fait que $\cos x$ est calculé deux fois inutilement.\smallskip

Avec la notation postfixée, on ne le calcule qu'une seule fois :
\begin{center}
\begin{minipage}{\mywidth}
\begin{lstlisting}
x cos copy 1 swap sub mul
\end{lstlisting}
\end{minipage}
\end{center}

\bigskip
\begin{center}
$\star$\par
$\star$\quad$\star$
\end{center}

\bigskip
C'est tout, j'espère que cette extension vous sera utile !\par\nobreak
Merci de me signaler par \href{mailto:unbonpetit@gmail.com}{\texttt{\textbf{email}}} tout bug ou toute proposition d'amélioration\ldots\par\nobreak\bigskip
Christian \textsc{Tellechea}
\end{document}