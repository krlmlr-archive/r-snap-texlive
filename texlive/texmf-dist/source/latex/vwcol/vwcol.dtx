% \iffalse 
%<*internal>
\iffalse
%</internal>
%<*readme>
_________________
The VWCOL package
v0.1

This package provides a crude environment
called 'vwcol' for typesetting multicolumn
paragraph text of various column widths on
a single page.

For example,

\documentclass{article}
\usepackage{lipsum}
\begin{document}
\begin{vwcol}[widths={0.3,0.2,0.5}]
  \lipsum[1]
\end{vwcol}
\end{document}

Note again that only paragraph text is 
supported at present.

______________
Will Robertson
wspr 81 [at] gmail [dot] com

Copyright 2008
Distributed under the LaTeX Project Public License
%</readme>
%<*internal>
\fi
\begingroup
%</internal>
%<*batchfile>
\input docstrip.tex
\keepsilent
\preamble

  __________________________________
  Copyright (C) 2008  Will Robertson

  License information appended.


\endpreamble
\postamble

Copyright (C) 2008 by Will Robertson <wspr81@gmail.com>

Distributable under the LaTeX Project Public License,
version 1.3c or higher (your choice). The latest version of
this license is at: http://www.latex-project.org/lppl.txt

This work is "maintained" (as per LPPL maintenance status) 
by Will Robertson.

This work consists of the file  vwcol.dtx
          and the derived files vwcol.sty,
                                vwcol.ins, and
                                vwcol.pdf.

\endpostamble
\askforoverwritefalse
\generate{\file{\jobname.sty}{\from{\jobname.dtx}{package}}}
%</batchfile>
%<batchfile>\endbatchfile
%<*internal>
\generate{\file{\jobname.ins}{\from{\jobname.dtx}{batchfile}}}
\nopreamble\nopostamble
\generate{\file{README.txt}{\from{\jobname.dtx}{readme}}}
\generate{\file{dtx-style.sty}{\from{\jobname.dtx}{dtx-style}}}
\endgroup
\immediate\write18{mv README.txt README}
\immediate\write18{makeindex -s gind.ist -o \jobname.ind  \jobname.idx}
\immediate\write18{makeindex -s gglo.ist -o \jobname.gls  \jobname.glo}
%</internal>
%
%<*driver>
\documentclass{ltxdoc}
\EnableCrossrefs
\CodelineIndex
\RecordChanges
%\OnlyDescription
\usepackage{dtx-style}
\begin{document}
  \DocInput{\jobname.dtx}
\end{document}
%</driver>
%
%
% \fi
%
% \GetFileInfo{\jobname.sty}
% \CheckSum{0}
% \makeatletter
%
% \title{The \pkg{vwcol} package}
% \author{Will Robertson}
% \date{\filedate \qquad \fileversion}
%
% \maketitle
%
% \section{Introduction}\seclabel{intro}
%
% This package provides an environment that allows paragraph text to be typeset into multiple columns of uneven width, with text that flows from one column to the next. The columns can not span over multiple pages.
%
% Due to difficulties with the processing of such a thing, little else \emph{besides} text is allowed within (feel free to experiment, but you're on your own). Here's an example:\footnote{Requires the \pkg{lipsum} package to print the sample text.}
% \begin{example}{firstline=2}
%   \tiny
%   \begin{vwcol}[widths={0.3,0.2,0.5}]
%     \lipsum[1]
%   \end{vwcol}
% \end{example}
%
% \section{Options}
%
% As shown above, at heart this package is quite simple. This section discusses the options that can be passed to the |vwcol| environment. The basic options are:
% \begin{description}[noitemsep,font=\ttfamily,leftmargin=5.5em,style=nextline]
% \item [widths] The number and size of the columns
% \item [sep] The width of the space between the columns
% \item [rule] The width of the rule
% \item [sidesep] Whether to add space on the outside of the columns
% \item [siderule] Whether to draw a rule on the outside of the columns
% \end{description}
% Paragraph options |justify| and |indent| are covered in \secref[vref]{para}, and
% advanced options are discussed in \secref[vref]{advanced}.
% 
% \noindent\DescribeMacro{\vwcolsetup}
% This macro may be used to set the default values for the options (described subsequently) of the |vwcol| environment.
% \begin{example}{firstline=2}
%   \tiny
%   \vwcolsetup{widths={0.3,0.2,0.5},rule=2pt}
%   \begin{vwcol}
%     \lipsum[1]
%   \end{vwcol}
% \end{example}
%
% \noindent\DescribeMacro{widths} 
% This option must always be present (either as a default value previously set in \cmd\vwcolsetup\ or specified in the environment directly) and consists of any number of comma separated lengths or ratios. Lengths set the column width to an explicit size, whereas a ratio (as above) sets the column width to a fraction of the available linewidth (leaving some space for some separation between the columns). 
%
% As shown in the example in \secref{intro}, when the width ratios sum to 100\% then the multi-columns will span the entire line width regardless of the chosen separation between the columns. A set of widths may be any combination of ratios and lengths, but the total width should not exceed the linewidth available (a warning will be given if so).
%
% \bigskip\noindent\DescribeMacro{sep}
% The separation between the columns can be chosen as either 
% a length, a ratio of the linewidth, or the keyword |fill|. 
% The default is |sep=0.05| (\ie, 5\% of the linewidth).
% \begin{example}{firstline=2}
%   \tiny
%   \begin{vwcol}[widths={0.35,0.25,0.4},sep=5pt]
%     \lipsum[1]
%   \end{vwcol}
% \end{example}
%
% \noindent 
% The keyword |fill| adds stretchable space between the columns so the multi-columns fill the entire linewidth (without altering the widths of the columns themselves):
% 
% \begin{example}{firstline=2}
%   \tiny
%   \begin{vwcol}[widths={2cm,2cm,0.4},sep=fill]
%     \lipsum[1]
%   \end{vwcol}
% \end{example}
%
% \noindent
% If ratio column widths are used with a variable separation gap,
% then the separation gap is considered zero for the total width calculation.
% In this example, because the ratios for the column widths sum to 100\% there is no room left over
% for a separation gap:
% \begin{example}{firstline=2}
%   \tiny
%   \begin{vwcol}[widths={0.3,0.2,0.5},sep=fill]
%     \lipsum[1]
%   \end{vwcol}
% \end{example}
%
% \bigskip\noindent\DescribeMacro{presep}\DescribeMacro{postsep}\DescribeMacro{sidesep}
% These options control whether an extra separation is added before and/or after the multicolumns. |presep| (or |presep=true|) adds space before the columns (and |presep=false| suppresses it); |postsep| adds space after the columns; |sidesep| is a shorthand for activating both at once.
% \begin{example}{firstline=2}
%   \tiny\par
%   \begin{vwcol}[widths={0.3,0.25,0.4}]
%     \lipsum[1]
%   \end{vwcol}
%
%   \setlength\fboxsep{0pt}
%   \fbox{\begin{vwcol}[widths={0.3,0.25,0.4},sidesep]
%     \lipsum[1]
%   \end{vwcol}}
% \end{example}
%
% \bigskip\noindent\DescribeMacro{rule}
% The width of the rule is configurable (again, either a length or a ratio of the line width) and does not affect the separation gap. Use |rule=none| or |rule=0pt| to suppress drawing the rule. The default is |rule=0.4pt|.
% \begin{example}{firstline=2}
%   \tiny
%   \begin{vwcol}[widths={0.35,0.25,0.4}]
%     \lipsum[1]
%   \end{vwcol}
%   \begin{vwcol}[widths={0.35,0.25,0.4},rule=0.02]
%     \lipsum[1]
%   \end{vwcol}
% \end{example}
%
% \bigskip\noindent\DescribeMacro{prerule}\DescribeMacro{postrule}\DescribeMacro{siderule}
% These options control whether extra vertical rules are added before and/or after the columns. |prerule| places a rule before the columns; |postrule| after them. (Again, |prerule=false| (\etc) turns this feature off.) And |siderule| is a shorthand to activate both. Using these options implicitly activates the relevant |presep| and/or |postsep| options, because you can't have the rule without the gap.
% \begin{example}{firstline=2}
%   \par\tiny
%   \begin{vwcol}[widths={0.35,0.25,0.4},siderule]
%     \lipsum[1]
%   \end{vwcol}
% \end{example}
%
% \newpage
% \section{Paragraph settings}\seclabel{para}
%
% \bigskip\noindent\DescribeMacro{justify}
% The justification to use; one of |ragged| (\emph{default}), |flush|, |raggedleft|, or |center|. These settings are made using the \pkg{ragged2e} package, with the result that hyphenation is enabled even in the ragged settings (this is a good thing!); due to a limitation of \TeX's \cmd\parshape, \LaTeX's ordinary \cmd\raggedright\ setting cannot be used.
% \begin{example}{firstline=2}
%   \tiny
%   \begin{vwcol}[widths={0.35,0.25,0.4}]
%     \lipsum[66]
%   \end{vwcol}
%   \begin{vwcol}[widths={0.35,0.25,0.4},justify=flush]
%     \lipsum[66]
%   \end{vwcol}
%   \begin{vwcol}[widths={0.35,0.25,0.4},justify=raggedleft]
%     \lipsum[66]
%   \end{vwcol}
%   \begin{vwcol}[widths={0.35,0.25,0.4},justify=center]
%     \lipsum[66]
%   \end{vwcol}
% \end{example}
%
% \bigskip\noindent\DescribeMacro{indent}
% This option is used to set the paragraph indent for ragged right and justified paragraph shapes (by default |[indent=1.5em]|).
% \begin{example}{firstline=2}
%   \tiny
%   \begin{vwcol}[widths={0.35,0.25,0.4},indent=5em]
%     \lipsum[66]\lipsum[66]
%   \end{vwcol}
% \end{example}
% Note that the first column always begins with a \cmd\noindent. Let me know if you don't like this idea.
%
%
% \section{Advanced (read: not very useful) options}
% \seclabel{advanced}
%
% \bigskip\noindent\DescribeMacro{quiet}
% The \pkg{vwcol} package passes certain information about what it's doing via errors in compilation, warnings in the console output, and info in the |.log| file. Loading \pkg{vwcol} with the |[quiet]| option `demotes' the priority of these diagnostics: errors become warnings, warnings become info in the |.log| file, and info is suppressed entirely.
%
% \bigskip\noindent\DescribeMacro{lines}
% With the default |[lines=auto]|, the |vwcol| environment tries to 
% estimate how much space is required but it will
% sometimes get it wrong. Pass an integer to the |lines| option to specify 
% exactly how many
% lines to use (which will also save processing time), but if the value chosen
% is too small then text will be lost (and an error given):
% \begin{example}{firstline=2}
%   \tiny
%   \begin{vwcol}[widths={0.35,0.25,0.4},lines=4]
%     \lipsum[1]
%   \end{vwcol}
%   \begin{vwcol}[widths={0.35,0.25,0.4},lines=11]
%     \lipsum[1]
%   \end{vwcol}
% \end{example}
% The rationale behind producing an error is that you really want to be alerted if text in your input is not making it into the output document (\cf\ with trying to insert a character that doesn't exist in the current font).
%
% \bigskip\noindent\DescribeMacro{maxrecursion}
% When the estimate number of
% lines is calculated, the value is sometimes too small. |vwcol| will increment
% the number of lines one-by-one at most |maxrecursion| times until the text completely fits into the columns. If it hits |maxrecursion|, then an error is reported explaining what's going on.
%
% The default is |5|, but I'd be surprised if you ever need to adjust this parameter.
% 
% \newpage
% \section{Usage notes}
%
% If you want the |widths| ratios to use a different width to denote 100\% (instead of \cmd\linewidth), put the whole thing in a |minipage| or \cmd\parbox:
% \begin{example}{firstline=2}
%   \tiny
%   \begin{minipage}{0.8\linewidth}
%     \begin{vwcol}[widths={0.3,0.7},indent=1.8em]
%       \lipsum[66]\lipsum[66]
%     \end{vwcol}
%   \end{minipage}
% \end{example}
% \noindent (I might add an option to |vwcol| to allow this directly; \Eg, |[totalwidth=0.8\linewidth]|. Let me know if you like the idea.)
%
% The |vwcol| environment ends the previous paragraph at |\begin{vwcol}| and terminates the paragraph it is contained within at |\end{vwcol}|. This means you can't place two |vwcol| environments next to each other, for example (or next to anything else, for that matter). If you want to be able to do this, again, put them in |minipage|s or \cmd\parbox es:
% \begin{example}{firstline=2}
%   \tiny
%   \rule{0.1\linewidth-\fboxsep}{1ex}%
%   %
%   \fbox{\parbox{0.8\linewidth}{%
%     \begin{vwcol}[widths={0.3,0.7},indent=1.8em]
%       \lipsum[66]\lipsum[66]
%     \end{vwcol}}}%
%   %
%   \rule{0.1\linewidth-\fboxsep}{1ex}%
% \end{example}
% \noindent (I might add an option to |vwcol| to allow this directly; \Eg, |[par=false]| or |[block=par]| vs.\ |[block=inline]|. Let me know if you like the idea.)
%
% Note in both of these cases that the \cmd\parindent\ length had to be redefined after |{minipage}| or \cmd\parbox\ defined it to zero inside themselves.
%
% \section{Acknowledgements}
%
% Many thanks to Flavio Costa for testing an early version of this package and especially for proof-reading this documentation. In large part due to him this manual makes much more sense |:)|
%
% \StopEventually{}
%
% \part{\pkg{\jobname} implementation}
%\iffalse
%<*package>
%\fi
%
% \PrintChanges
%
% This is the package.
%
%    \begin{macrocode}
\ProvidesPackage{vwcol}
  [2008/06/24 v0.1 Variable-width multicolumn text]
%    \end{macrocode}
%
% \section{Preamble}
%
% \subsection{Packages}
%
%    \begin{macrocode}
\RequirePackage{calc}
\RequirePackage{environ}[2008/06/18]
\RequirePackage{keyval}
\RequirePackage{ragged2e}
%    \end{macrocode}
% 
% \subsection{Things we need}
% 
%    \begin{macrocode}
\newlength\vwcol@sep
\newlength\vwcol@rule
\newlength\vwcol@totalwidth
\newlength\vwcol@averagewidth
\newlength\vwcol@parindent
%    \end{macrocode}
% 
%    \begin{macrocode}
\newcount\vwcol@last
\newcount\vwcol@Ncols
\newcount\vwcol@Nlines
\newcount\vwcol@maxrecursion
%    \end{macrocode}
% 
%    \begin{macrocode}
\newbox\vwcol@box
\newbox\vwcol@plainbox
\newbox\vwcol@outputbox
%    \end{macrocode}
% 
%    \begin{macrocode}
\newif\if@vwcol@boxready
\newif\if@vwcol@prerule
\newif\if@vwcol@postrule
\newif\if@vwcol@presep
\newif\if@vwcol@postsep
%    \end{macrocode}
%
% \subsection{Conveniences}
%
% Start error and warning text on a new line coz I think it looks better that way:
%    \begin{macrocode}
\newcommand\vwcol@PackageError[2]{%
  \PackageError{vwcol}{^^J\space\space#1}{#2}}
%    \end{macrocode}
% 
%    \begin{macrocode}
\newcommand\vwcol@PackageWarning[1]{%
  \PackageWarning{vwcol}{%
    ^^J\space\space#1^^JThis warning occurred}}
%    \end{macrocode}
%
%    \begin{macrocode}
\newcommand\vwcol@PackageInfo[1]{%
  \PackageWarning{vwcol}{%
    ^^J\space\space#1^^JThis warning occurred}}
%    \end{macrocode}
%
% \subsection{Package option}
%
%    \begin{macrocode}
\DeclareOption{quiet}{%
  \renewcommand\vwcol@PackageError[2]{%
    \vwcol@PackageWarning{#1.}}%
  \let\vwcol@PackageInfo\@gobble}
\ProcessOptions
%    \end{macrocode}
%
% \section{Auxiliary macros}
%
% \begin{macro}{\vwcol@test@length}
% \darg{Rational number or length (\ie, with unit)}
% \darg{Multiplier for the rational (\eg, \cmd\linewidth)}
% This macro returns \cs{@tempswa} true if the input is a rational number (\eg, |0.1|, |1|, \etc) or false if it is a length (\eg, |2pt|, |3cm|). \note{Based on a similar macro by David Kastrup: \url{http://groups.google.com/group/comp.text.tex/msg/9bd5349ea2416c95}} \cs{@tempdima} contains the length corresponding to the rational number multiplier of |#2| or the length input, respectively.
% \begin{example}{}
%   \vwcol@test@length{1}{\linewidth}
%   \if@tempswa Rational\else Length\fi\\
%   \vwcol@test@length{1cm}{\linewidth}
%   \if@tempswa Rational\else Length\fi
% \end{example}
%    \begin{macrocode}
\def\vwcol@test@length#1#2{%
  \afterassignment\vwcol@test@@
  \@tempdima=#1#2\@nil} 
%    \end{macrocode}
% The afterassignment macro:
%    \begin{macrocode}
\def\vwcol@test@@#1\@nil{%
  \ifx\@nil#1\@nil
    \@tempswatrue
  \else
    \@tempswafalse
  \fi} 
%    \end{macrocode}
% \end{macro}
% Actually, I don't use \cs{if@tempswa} in this package (I use \cmd\@tempdima\ directly), but I've left the conditional in there in case someone else finds it useful.
%
%
% \section{Environment options} 
%
% \begin{macro}{\vwcolsetup}
% To set the defaults:
%    \begin{macrocode}
\def\vwcolsetup{\setkeys{vwcol}}
%    \end{macrocode}
% \end{macro}
% 
% \paragraph{widths} The number and size of each column.
%    \begin{macrocode}
\define@key{vwcol}{widths}{\def\vwcol@widths{#1}}
%    \end{macrocode}
% No defaults.
%
% \paragraph{maxrecursion} 
% Number of iterations used to estimate the number of lines.
% I doubt if it will ever need to be changed from the default.
%    \begin{macrocode}
\define@key{vwcol}{maxrecursion}{\vwcol@maxrecursion=#1}
%    \end{macrocode}
% Default:
%    \begin{macrocode}
\vwcolsetup{maxrecursion=5}
%    \end{macrocode}
%
% \paragraph{rule}
% The width of the intercolumn rule as a length or as a ratio of the total line width or as the keyword |none|.
%    \begin{macrocode}
\define@key{vwcol}{rule}{%
  \def\@tempa{#1}%
  \def\@tempb{none}%
  \ifx\@tempa\@tempb
    \vwcol@rule=0pt
  \else
    \vwcol@test@length{#1}{\linewidth}%
    \vwcol@rule=\@tempdima
  \fi}
%    \end{macrocode}
% Default:
%    \begin{macrocode}
\vwcolsetup{rule=0.4pt}
%    \end{macrocode}
% 
% \paragraph{lines} The number of lines of text in each column or the keyword |auto|.
%    \begin{macrocode}
\define@key{vwcol}{lines}{%
  \def\@tempa{#1}%
  \def\@tempb{auto}%
  \ifx\@tempa\@tempb
    \vwcol@Nlines=0  
  \else
    \vwcol@Nlines=#1
  \fi}
%    \end{macrocode}
% Default:
%    \begin{macrocode}
\vwcolsetup{lines=auto}
%    \end{macrocode}
% 
% \paragraph{sep} The distance between each column (including space taken up by the rule, if any) as a length or as a ratio or as the keyword |fill|.
%    \begin{macrocode}
\define@key{vwcol}{sep}{%
  \def\@tempa{#1}%
  \def\@tempb{fill}%
  \ifx\@tempa\@tempb
    \vwcol@sep=1sp
  \else
    \vwcol@test@length{#1}{\linewidth}%
    \vwcol@sep=\@tempdima
  \fi}
%    \end{macrocode}
% Default:
%    \begin{macrocode}
\vwcolsetup{sep=0.05}
%    \end{macrocode}
%
% \paragraph{presep}
% Whether to include a gap before the first column.
%    \begin{macrocode}
\define@key{vwcol}{presep}[true]{%
  \def\@tempa{#1}%
  \def\@tempb{true}%
  \ifx\@tempa\@tempb
    \@vwcol@preseptrue
  \else
    \def\@tempb{false}%
    \ifx\@tempa\@tempb
      \@vwcol@presepfalse
    \else
      \vwcol@PackageWarning{%
        '#1' not a valid option for option 'presep'; 
        'true' or 'false' only.}%
    \fi
  \fi}
%    \end{macrocode}
% Default:
%    \begin{macrocode}
\vwcolsetup{presep=false}
%    \end{macrocode}

% 
% \paragraph{postsep}
% Whether to include a gap after the last column.
%    \begin{macrocode}
\define@key{vwcol}{postsep}[true]{%
  \def\@tempa{#1}%
  \def\@tempb{true}%
  \ifx\@tempa\@tempb
    \@vwcol@postseptrue
  \else
    \def\@tempb{false}%
    \ifx\@tempa\@tempb
      \@vwcol@postsepfalse
    \else
      \vwcol@PackageWarning{%
        '#1' not a valid option for option 'postsep'; 
        'true' or 'false' only.}%
    \fi
  \fi}
%    \end{macrocode}
% Default:
%    \begin{macrocode}
\vwcolsetup{postsep=false}
%    \end{macrocode}
% 
% \paragraph{sidesep}
% Shorthand for setting both |presep| and |postsep| at once.
%    \begin{macrocode}
\define@key{vwcol}{sidesep}[true]{%
  \def\@tempa{#1}%
  \def\@tempb{true}%
  \ifx\@tempa\@tempb
    \@vwcol@preseptrue
    \@vwcol@postseptrue
  \else
    \def\@tempb{false}%
    \ifx\@tempa\@tempb
      \@vwcol@presepfalse
      \@vwcol@postsepfalse
    \else
      \vwcol@PackageWarning{%
        '#1' not a valid option for option 'sidesep'; 
        'true' or 'false' only.}%
    \fi
  \fi}
%    \end{macrocode}
% 
% \paragraph{prerule}
% Whether to place a rule before the first column (implies |presep|).
%    \begin{macrocode}
\define@key{vwcol}{prerule}[true]{%
  \def\@tempa{#1}%
  \def\@tempb{true}%
  \ifx\@tempa\@tempb
    \@vwcol@preseptrue
    \@vwcol@preruletrue
  \else
    \def\@tempb{false}%
    \ifx\@tempa\@tempb
      \@vwcol@prerulefalse
    \else
      \vwcol@PackageWarning{%
        '#1' not a valid option for option 'prerule'; 
        'true' or 'false' only.}%
    \fi
  \fi}
%    \end{macrocode}
% Default:
%    \begin{macrocode}
\vwcolsetup{prerule=false}
%    \end{macrocode}
% 
% \paragraph{postrule}
% Whether to place a rule after the last column (implies |postsep|).
%    \begin{macrocode}
\define@key{vwcol}{postrule}[true]{%
  \def\@tempa{#1}%
  \def\@tempb{true}%
  \ifx\@tempa\@tempb
    \@vwcol@postseptrue
    \@vwcol@postruletrue
  \else
    \def\@tempb{false}%
    \ifx\@tempa\@tempb
      \@vwcol@postrulefalse
    \else
      \vwcol@PackageWarning{%
        '#1' not a valid option for option 'postrule'; 
        'true' or 'false' only.}%
    \fi
  \fi}
%    \end{macrocode}
% Default:
%    \begin{macrocode}
\vwcolsetup{postrule=false}
%    \end{macrocode}
% 
% \paragraph{siderule}
% Shorthand for setting |prerule| and |postrule| simultaneously.
%    \begin{macrocode}
\define@key{vwcol}{siderule}[true]{%
  \def\@tempa{#1}%
  \def\@tempb{true}%
  \ifx\@tempa\@tempb
    \@vwcol@preseptrue
    \@vwcol@postseptrue
    \@vwcol@preruletrue
    \@vwcol@postruletrue
  \else
    \def\@tempb{false}%
    \ifx\@tempa\@tempb
      \@vwcol@prerulefalse
      \@vwcol@postrulefalse
    \else
      \vwcol@PackageWarning{%
        '#1' not a valid option for option 'siderule'; 
        'true' or 'false' only.}%
    \fi
  \fi}
%    \end{macrocode}
% 
% \paragraph{justify} 
% The justification to use; one of |flush|/|ragged|/|raggedleft|/|center|.
%    \begin{macrocode}
\define@key{vwcol}{justify}{%
  \def\@tempa{#1}%
  \def\@tempb{ragged}%
  \ifx\@tempa\@tempb
    \let\vwcol@justify\RaggedRight
  \else
    \def\@tempb{flush}%
    \ifx\@tempa\@tempb
      \let\vwcol@justify\justifying
    \else
      \def\@tempb{raggedleft}%
      \ifx\@tempa\@tempb
        \let\vwcol@justify\RaggedLeft
      \else
        \def\@tempb{center}%
        \ifx\@tempa\@tempb
          \let\vwcol@justify\Centering
        \else
          \vwcol@PackageWarning{%
            '#1' not a valid option for option 'justify'; 
            one of 'flush'/'ragged'/'raggedleft'/'center' only.}%
        \fi
      \fi
    \fi
  \fi}
%    \end{macrocode}
% Default:
%    \begin{macrocode}
\vwcolsetup{justify=ragged}
%    \end{macrocode}
%
% \paragraph{indent} 
% The paragraph indent to use with |flush| or |ragged| justification.
%    \begin{macrocode}
\define@key{vwcol}{indent}{\setlength\vwcol@parindent{#1}}
%    \end{macrocode}
% Default:
%    \begin{macrocode}
\vwcolsetup{indent=1.5em}
%    \end{macrocode}
%
% \section{\texttt{vwcol} environment definition}
%
% \begin{environment}{vwcol}
% Always start a new par.
%    \begin{macrocode}
\NewEnviron{vwcol}[1][]{%
  \par\noindent
%    \end{macrocode}
% Initialisation:
%    \begin{macrocode}
  \@vwcol@boxreadyfalse
  \vwcolsetup{#1}%
%    \end{macrocode}
% Ensure the space at the top of each column is uniform:
%    \begin{macrocode}
  \splittopskip=\ht\strutbox
%    \end{macrocode}
% Setup widths (this counts the columns and calculates the average and total widths of the columns):
%    \begin{macrocode}
  \expandafter\vwcol@process@widths\expandafter{\vwcol@widths}%
%    \end{macrocode}
% Set up the paragraph parameters:
%    \begin{macrocode}
  \vwcol@para@setup
%    \end{macrocode}
% From the width of the columns, the total width of the environment can be calculated. First, if |sep=fill| then the whole linewidth will be used:
%    \begin{macrocode}
  \ifdim\vwcol@sep=1sp
    \vwcol@totalwidth=\linewidth
%    \end{macrocode}
% Otherwise calculate the total from the number of separation gaps:\\ (\cmd\vwcol@totalwidth\ is currently the total of the columns widths, which was calculated above in \cmd\vwcol@process@widths)
%    \begin{macrocode}
  \else
    \vwcol@totalwidth=\numexpr
      \vwcol@totalwidth+(\vwcol@Ncols-1)*\vwcol@sep
      \relax sp
%    \end{macrocode}
% Add on extra space due to the optional pre- and post-separation gaps and rules. Note that while rules between columns do not contribute to the total width of the columns (they subtract from the empty space in the gaps between the columns, which explains why the correction is needed in the |presep|/|postsep| length processing), pre- or post-rules \emph{do}.
%    \begin{macrocode}
    \if@vwcol@presep  
      \advance\vwcol@totalwidth\dimexpr(\vwcol@sep-\vwcol@rule)/2\relax
    \fi
    \if@vwcol@postsep 
      \advance\vwcol@totalwidth\dimexpr(\vwcol@sep-\vwcol@rule)/2\relax
    \fi
    \if@vwcol@prerule \advance\vwcol@totalwidth \vwcol@rule\fi
    \if@vwcol@postrule\advance\vwcol@totalwidth \vwcol@rule\fi
  \fi
%    \end{macrocode}
% Finally, warn the author if their columns are going to be too large:
%    \begin{macrocode}
  \ifdim\vwcol@totalwidth > \linewidth
    \vwcol@PackageWarning{%
      Total width of columns plus their separations 
      is greater than the linewidth^^J\space\space
      (by \the\vwcol@totalwidth\space - \the\linewidth\space = 
       \the\dimexpr \vwcol@totalwidth-\linewidth\relax)}%
  \fi
  \ifnum\vwcol@Nlines=0%
%    \end{macrocode}
% If the |lines| are not explicitly selected then they must be estimated.
% Typeset the text into a single box of the average column width (while ignoring overfull/underfull boxes):
%    \begin{macrocode}
    \@tempcnta=\hbadness
    \hbadness=\maxdimen
    \setbox\vwcol@plainbox\hbox{%
      \parbox{\vwcol@averagewidth}{\vwcol@justify\BODY}}%
    \hbadness=\@tempcnta
%    \end{macrocode}
% Now the estimate of the number of lines, $L$, can be calculated. Start by assuming that the `area' of the material in the single block will be able the same when split into columns of un-equal width ($w_i$). If $T$ is the total number of lines of the single block typeset above (which is calculated by dividing the height of the block by the baselineskip), this gives
% \[ T\times w_a \approx L\times w_1+L\times w_2+\cdots = L\times\sum_{i=1}^N w_i .\]
% The width of the single block is the average of column widths:
% \[ w_a = \mathrm{ave}(w_i) = \sum_{i=1}^N w_i/N\]
% (Where by `area' we \emph{actually} mean the number of lines in a block multiplied by the number of lines.)
% These two expressions are easily combined to give 
% \[ L = \frac{T\times \mathrm{ave}(w_i)}{\sum_{i=1}^N w_i} = \frac{T}{N} . \]
% In other words, the expression for the number of lines per columns simplifies to simply dividing the single block into equal sections.
%    \begin{macrocode}
    \vwcol@Nlines=\numexpr 
        (\ht\vwcol@plainbox+\dp\vwcol@plainbox)/
        (\baselineskip*\vwcol@Ncols)
      \relax
%    \end{macrocode}
% However, differences may arise due to rounding (due to \TeX's integer arithmetic, the floor of the resultant value is always calculated\footnote{I think.}) and hyphenation/justification variations between the two cases.
%
% Due to these differences, we start with the calculated number of lines and increment in a loop if necessary to ensure all of the material does actually fit. It's unlikely that the number of lines estimated will be \emph{greater} than the number of lines required due to the effect of the `flooring' of the calculations. 
%    \begin{macrocode}
    \@tempcnta=1%
    \loop\unless\if@vwcol@boxready
      \savebox\vwcol@outputbox{%
        \hbox to \vwcol@totalwidth{\vwcol@{\BODY}}}%
      \unless\if@vwcol@boxready
        \advance\@tempcnta 1%
        \advance\vwcol@Nlines 1%
%    \end{macrocode}
% Here we could keep looping for as long as necessary, but in case of weird input we put a hard limit on the number of iterations. Stop after the line number has been incremented five times (by default) because surely the calculation couldn't have been that far wrong.
%    \begin{macrocode}
        \ifnum\@tempcnta>\vwcol@maxrecursion
          \@vwcol@boxreadytrue
          \vwcol@PackageError{%
            The estimated number of lines is greater than 
            \the\vwcol@maxrecursion\space lines too small,%
              ^^J\space\space
            so I gave up (last tried maximum value of 
            [lines=\the\vwcol@Nlines])%
          }{%
            Text will be truncated in the multicolumns; 
            please select the%
            ^^J\space\space
            number of lines explicitly or increase 
            [maxrecursion=\the\vwcol@maxrecursion].%
          }%
        \fi  
      \fi
    \repeat
    \usebox\vwcol@outputbox
%    \end{macrocode}
% If the |lines| was chosen explicitly then just run with it, giving an error if the lines were too small. I can imagine an |approxlines| option that varies the number of lines over a range of say, 5 lines up and down then chooses the best one, but I can't be bothered implementing that right now.
%    \begin{macrocode}
  \else
    \hbox to \vwcol@totalwidth{\vwcol@{\BODY}}%
    \unless\if@vwcol@boxready
      \vwcol@PackageError{%
        Not enough lines to fit the entire text; 
        some text has been truncated.^^J\space\space
        Increase [lines=\the\vwcol@Nlines] to fit more%
      }{%
        Or remove [lines=\the\vwcol@Nlines] altogether 
        to have 'vwcol' estimate the value.}%
    \fi
  \fi\par}
%    \end{macrocode}
% That's it!
% \end{environment}
%
% \begin{macro}{\vwcol@para@setup}
% Set up the paragraph options.
%    \begin{macrocode}
\def\vwcol@para@setup{%
%    \end{macrocode}
% Justification:
%    \begin{macrocode}
    \vwcol@justify
%    \end{macrocode}
% \cmd\parindent\ override if |justify| is |ragged| or |flush|:
%    \begin{macrocode}
    \@tempswafalse
    \ifx\vwcol@justify\RaggedRight
      \@tempswatrue
    \else\ifx\vwcol@justify\justifying
        \@tempswatrue
    \fi\fi
    \if@tempswa
      \parindent=\vwcol@parindent
    \else
      \vwcol@PackageInfo{%
        'indent' ignored for [justify=raggedleft] 
        or [justify=center]}
    \fi
%    \end{macrocode}
% The algorithm, unfortunately, doesn't work with non-zero \cmd\parskip:
%    \begin{macrocode}
    \parskip=0pt}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\vwcol@process@widths}
% This macros takes the |widths| input and calculates the number of columns and the total and average widths of the columns.
%    \begin{macrocode}
\def\vwcol@process@widths#1{%
%    \end{macrocode}
% Count the number of columns: (this must be done in a loop before the main one so that \cmd\vwcol@Ncols\ is known first)
%    \begin{macrocode}
  \@for\@ii:=#1\do{\advance\vwcol@Ncols 1}%
%    \end{macrocode}
% Based on the colsep and rule width, calculate allowable space. For stretchable column gaps, the separation gap counts as zero but the rules still take up some space:
%    \begin{macrocode}
  \ifdim\vwcol@sep=1sp
    \@tempdimb=\numexpr 
      \linewidth-(\vwcol@Ncols-1)*\vwcol@rule
      \relax sp
%    \end{macrocode}
% And for fixed-width column gaps: (chuck in the warning here about |sep|$\ge$|rule| coz it's convenient)
%    \begin{macrocode}
  \else
    \ifdim\vwcol@rule > \vwcol@sep
      \vwcol@sep=\vwcol@rule
      \vwcol@PackageWarning{%
        'sep' must be greater than or equal to 'rule'}%
    \fi
    \@tempdimb=\numexpr
      \linewidth-(\vwcol@Ncols-1)*\vwcol@sep
      \relax sp
%    \end{macrocode}
% Remember that the rules do not take up any space of their own between the columns, so they subtract from the white space of the separation gap; this must be mirrored when additional space is included before or after the columns:
%    \begin{macrocode}
    \if@vwcol@presep
      \advance\@tempdimb\dimexpr(-\vwcol@sep+\vwcol@rule)/2\relax
    \fi
    \if@vwcol@postsep
      \advance\@tempdimb\dimexpr(-\vwcol@sep+\vwcol@rule)/2\relax
    \fi
  \fi
%    \end{macrocode}
% The prerule and postrule both contribute to the total width, unlike the rules between the columns:
%    \begin{macrocode}
  \if@vwcol@prerule\advance\@tempdimb-\vwcol@rule\fi
  \if@vwcol@postrule\advance\@tempdimb-\vwcol@rule\fi
%    \end{macrocode}
% \cmd\@tempdimb\ now contains the maximum width that the columns can span before the environment is wider the \cmd\linewidth, after the rules and gaps are added in too. Use this as the reference length to calculate the lengths of the columns that have widths specified as ratios. 
%
% Now iterate to do stuff:
%    \begin{macrocode}
  \@for\@ii:=#1\do{%
%    \end{macrocode}
% If the column width is a plain rational number (like |0.4|) then set the columnwidth to be that fraction of the allowable width.
%    \begin{macrocode}
    \vwcol@test@length\@ii\@tempdimb
%    \end{macrocode}
% Keep a running total of the total width being used:
%    \begin{macrocode}
    \advance\vwcol@totalwidth\@tempdima
%    \end{macrocode}
% Save the column widths for later in the \cmd\parshape\ processing:
%    \begin{macrocode}
    \expandafter\expandafter\expandafter\def 
    \expandafter\expandafter\expandafter\vwcol@setup@parlines 
    \expandafter\expandafter\expandafter{%
                \expandafter\vwcol@setup@parlines 
                \expandafter\vwcol@addlines 
                \expandafter{\the\@tempdima}}}%
%    \end{macrocode}
% End the loop. Finally, calculate the average width of the columns:
%    \begin{macrocode}
  \vwcol@averagewidth=\dimexpr \vwcol@totalwidth/\vwcol@Ncols \relax}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\vwcol@setup@parlines}
% This is the macro used to locally store the setup for the \cmd\parshape\ line specification: (see a few lines back for the \cmd\expandafter\ fun of getting stuff into it)
%    \begin{macrocode}
\def\vwcol@setup@parlines{\let\vwcol@parlines\@empty}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\vwcol@addlines}
% Adds paragraph specifications to \cmd\vwcol@parlines for a single column in the \cmd\parshape\. For $N$ columns there will be $N$ calls to this macro inside \cmd\vwcol@setup@parlines, which gets expanded at the beginning of every paragraph to create the required \cmd\parshape\ specification.
%
% \cmd\@tempcntb\ starts at |0| at the beginning of each paragraph and counts the number of lines over all the columns.
% \cmd\vwcol@last\ is the total number of lines that have so far been
% put into the columns. \cmd\vwcol@parlines\ is initialised at the beginning of each paragraph.
%
% Each time \cmd\vwcol@addlines\ is executed, \cmd\@tempcnta\ iterates through each line in that column. Once the total line count reaches the number of lines that have been typeset, \cmd\vwcol@parlines\ starts filling up with \cmd\parshape\ lines for the next paragraph.
%    \begin{macrocode}
\def\vwcol@addlines#1{%
  \@tempcnta=0
  \loop\ifnum\@tempcnta<\vwcol@Nlines
    \advance\@tempcntb 1
    \ifnum\@tempcntb>\vwcol@last
      \xdef\vwcol@parlines{\vwcol@parlines 0cm #1 }%
    \fi
    \advance\@tempcnta 1
  \repeat}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\vwcol@}
% This is the macro for splitting the text into variable-width columns.
%    \begin{macrocode}
\newcommand\vwcol@[1]{%
%    \end{macrocode}
% \paragraph{Setting the paragraphs}
% First set the text into a special box that varies width at the appropriate places so when it is split into equal segments they can be arranged into variable-width columns.
%    \begin{macrocode}
  \setbox\vwcol@box\vbox{%
%    \end{macrocode}
% The trick is to keep a running counter of lines that we've gone through by inspecting every paragraph after it is typeset:
%    \begin{macrocode}
    \def\par{\endgraf\advance\vwcol@last\the\prevgraf}%
%    \end{macrocode}
% (see \cmd\vwcol@addlines\ for a more detailed explanation):
%    \begin{macrocode}
    \everypar{%
      \@tempcntb=0
      \vwcol@setup@parlines
      \parshape=\numexpr \vwcol@Nlines*\vwcol@Ncols-\vwcol@last \relax
      \vwcol@parlines}%
%    \end{macrocode}
% Insert a \cmd\strut\ at the top to ensure we chop off the first column at the same height as all the others:
%    \begin{macrocode}
    \noindent\strut#1}%
%    \end{macrocode}
% \paragraph{Splitting the columns}
% First insert a pre-sep and -rule, if appropriate:
%    \begin{macrocode}
  \if@vwcol@presep
    \if@vwcol@prerule
      \vrule width \vwcol@rule
    \fi
    \hskip\dimexpr (\vwcol@sep-\vwcol@rule)/2 \relax
  \fi
%    \end{macrocode}
% Iterate over the total number of columns:
%    \begin{macrocode}
  \@tempcnta=0
  \loop\ifnum\@tempcnta < \vwcol@Ncols 
    \advance\@tempcnta 1
%    \end{macrocode}
% Skip the separations and rules in the first case:
%    \begin{macrocode}
    \unless\ifnum\@tempcnta=1
%    \end{macrocode}
% Sep and rule between the columns if |[sep=fill]|:
%    \begin{macrocode}
      \ifdim\vwcol@sep=1sp
        \hfill\vrule width \vwcol@rule\hfill
      \else
%    \end{macrocode}
% Sep and rule between the columns if |sep| is a length:
%    \begin{macrocode}
        \@tempdima=\dimexpr (\vwcol@sep-\vwcol@rule)/2 \relax
        \hskip\@tempdima\vrule width \vwcol@rule\hskip\@tempdima
      \fi
    \fi
%    \end{macrocode}
% Split off and place the text column, then loop:
%    \begin{macrocode}
    \vsplit\vwcol@box to \numexpr 
      (\vwcol@Nlines-1)*\baselineskip+\ht\strutbox \relax sp
  \repeat
%    \end{macrocode}
% Finally place the post-sep and -rule, if appropriate:
%    \begin{macrocode}
  \if@vwcol@postsep
    \hskip\dimexpr (\vwcol@sep-\vwcol@rule)/2 \relax
    \if@vwcol@postrule
      \vrule width \vwcol@rule
    \fi
  \fi
%    \end{macrocode}
% If \cs{vwcol@box} is void then we've used up all the material. This fact is passed on so we can re-run the algorithm with a different number of lines (or give a warning) if the material was truncated.
%    \begin{macrocode}
  \ifvoid\vwcol@box
    \global\@vwcol@boxreadytrue
  \fi}
%    \end{macrocode}
% \end{macro}
%
% \newpage
% \section{Problem with \cmd\raggedright\ and \cmd\parshape}
%
% Check it out; when you make a \cmd\parshape\ with more lines specified than necessary, the linebreak of the first line is totally wrong:
%
% \begin{example}{}
%   \raggedright
%   \newlength\tmp\tmp=241.84842pt
%
%   \def\oneline{ 2.5em \tmp}
%   \def\fivelines{\oneline\oneline\oneline\oneline\oneline}
%
%   \textbf{Wrong}:\\
%   \parshape 10 \fivelines\fivelines  
%   \lipsum[66]
%
%   \textbf{Right}:\\
%   \parshape 7 \fivelines\oneline\oneline  
%   \lipsum[66]
% \end{example}
% This is why this package uses \pkg{ragged2e}'s \cmd\RaggedRight\ instead of \LaTeX's \cmd\raggedright.
%
%\iffalse
%</package>
%\fi
%
% \Finale
%
%
%\iffalse
%<*dtx-style>
%    \begin{macrocode}
\ProvidesPackage{dtx-style}

\errorcontextlines=999

\def\@dotsep{1000}
\setcounter{tocdepth}{2}
\setlength\columnseprule{0.1pt}
\renewcommand\tableofcontents{\relax
  \begin{multicols}{2}[\section*{\contentsname}]\small
    \@starttoc{toc}\relax
  \end{multicols}}

\setcounter{IndexColumns}{2}
\renewenvironment{theglossary}
  {\small\list{}{}
     \item\relax
     \glossary@prologue\GlossaryParms 
     \let\item\@idxitem \ignorespaces 
     \def\pfill{\hspace*{\fill}}}
  {\endlist}

\usepackage[svgnames]{xcolor}
\usepackage{amsmath,array,bm,booktabs,calc,enumitem,fancyvrb,graphicx,ifthen,lipsum,longtable,microtype,refstyle,subfig,varioref,url}

\usepackage[center,it]{titlesec}
\usepackage[quiet]{vwcol}

\usepackage[sc,osf]{mathpazo}

\linespread{1.1}      % A bit more space between lines
\frenchspacing         % Remove ugly extra space after punctuation
\setlength\parindent{2em}

\definecolor{niceblue}{rgb}{0.2,0.4,0.8}
\newenvironment{example}[1]
  {\VerbatimEnvironment
   \def\Options{#1}%
   \begin{VerbatimOut}[gobble=2]{\examplefilename}}
  {\end{VerbatimOut}\relax
   \typesetexample}

\fvset{formatcom=\color{niceblue}}
\DefineShortVerb{\|}

\def\theCodelineNo{\textcolor{niceblue}{\sffamily\tiny\arabic{CodelineNo}}}

\let\examplesize\normalsize
\let\auxwidth\relax

\newsavebox\verbatimbox
\edef\examplefilename{\jobname.example}

\newcommand\typesetexample{\relax
  \par\noindent
  \begin{trivlist}\item[]
  \begin{minipage}[t]{\linewidth}
  \begin{quote}
   \edef\@tempa{[gobble=2,fontsize=\noexpand\small,\Options]}%
   \begin{lrbox}{\verbatimbox}\relax
     \expandafter\BVerbatimInput\@tempa{\examplefilename}%
   \end{lrbox}
   \noindent\usebox\verbatimbox\par
   \vspace{-0.7\baselineskip}%
   {\color{gray}\hrulefill}\par
   \catcode`\%=14
   \input\examplefilename
  \end{quote}
  \end{minipage}
  \end{trivlist}}

\newcommand*\name[1]{{#1}}
\newcommand*\pkg[1]{\textsf{#1}}
\newcommand*\feat[1]{\texttt{#1}}
\newcommand*\opt[1]{\texttt{#1}}

\newcommand*\note[1]{\unskip\footnote{#1}}

\let\latin\textit
\def\eg{\latin{e.g.}}
\def\Eg{\latin{E.g.}}
\def\ie{\latin{i.e.}}
\def\cf{\latin{cf.}}
\def\etc{\@ifnextchar.{\latin{etc}}{\latin{etc.}\@}}

\def\STIX{\textsc{stix}}
\def\MacOSX{Mac~OS~X}
\def\ascii{\textsc{ascii}}
\def\OMEGA{Omega}
\def\CTAN{\textsc{ctan}}

\newcounter{argument}
\g@addto@macro\endmacro{\setcounter{argument}{0}}
\newcommand*\darg[1]{%
  \stepcounter{argument}%
  {\ttfamily\char`\{\char`\#\theargument\char`\}:~}#1\par\noindent\ignorespaces}
\newcommand*\doarg[1]{%
  \stepcounter{argument}%
  {\ttfamily[\char`\#\theargument]:~}#1\par\noindent\ignorespaces}

\def\codeline{\par\hspace{\parindent}}% two \indents in total

%    \end{macrocode}
%</dtx-style>
%\fi
%
% \typeout{*************************************************************}
% \typeout{*}
% \typeout{* To finish the installation you have to move the following}
% \typeout{* file into a directory searched by TeX:}
% \typeout{*}
% \typeout{* \space\space\space vwcol.sty}
% \typeout{*}
% \typeout{*************************************************************}
%
\endinput
