%
% ^^A This is file sseq.dtx. First LaTeX the accompanying file sseq.ins
% ^^A to produce the package file sseq.sty.
% ^^A Then LaTeX this file to produce the documentation of the sseq package.
% ^^A
% ^^A (c) 2003-2007 Tilman Bauer. Freely distributable under the LaTeX Project Public License (LPPL)
% ^^A
% \ifthenelse{0=1}{
%<*never>
\documentclass{ltxdoc}
\usepackage{sseq}
\EnableCrossrefs
\CodelineIndex
\RecordChanges
\begin{document}
\DocInput{sseq.dtx} \PrintIndex \PrintChanges
\end{document}
%</never>
% }{}

% 
% \changes{v1.0}{November 12, 2003}{First release of code and documentation}
% \changes{v1.01}{November 15, 2003}{Bug fix with clipping after a ssgoto}
% \changes{v1.02}{November 18, 2003}{Bug fix that would mess up page numbering in some cases}
% \changes{v1.03}{December 11, 2003}{Added examples to documentation, bug fix in grid drawing}
% \changes{v1.04}{January 19, 2004}{Up to nine drops per square now possible, added customization of the grid}
% \changes{v1.05}{December 9, 2004}{Added support for different packing strategies; support for dotted lines}
% \changes{v1.06}{August 1, 2005}{sseqxstep=0 will now suppress printing of horizontal label; similarly sseqystep=0 and vertical labels}
% \changes{v2.0a}{July 16, 2007}{Completely recoded the graphics for using pgf instead of xyPic. Many new features. Consult the manual.}
% \changes{v2.0}{April 9, 2009}{bug fix with arrows leaving the chart}
% \changes{v2.01}{September 6, 2013}{bug fix with bent arrows displaying hooks. Now requires at least tikz/pgf version 2.0}
% \ifthenelse{0=1}{
%<*package>
\NeedsTeXFormat{LaTeX2e}

\ProvidesPackage{sseq}[2009/04/09 ver 2.0]

\RequirePackage{ifthen,calc,pifont}
\RequirePackage{pgf}[2008/02/20]
\RequirePackage{xkeyval}
\usepgflibrary{decorations.pathmorphing}

%^^A \newboolean{usesps}
%^^A \setboolean{usesps}{true} % Deprecated for pgf version of sseq
\newboolean{usescolor}
\setboolean{usescolor}{true}
\newboolean{debug}
\setboolean{debug}{false}

\DeclareOption{ps}{\errmessage{sseq: ps/nops is deprecated}}
\DeclareOption{nops}{\errmessage{sseq: ps/nops is deprecated}}
\DeclareOption{dvips}{\errmessage{sseq: deprecated option dvips ignored}}
\DeclareOption{xdvi}{\errmessage{sseq: deprecated option xdvi ignored}}
\DeclareOption{color}{\setboolean{usescolor}{true}}
\DeclareOption{nocolor}{\setboolean{usescolor}{false}}
\DeclareOption{debug}{\setboolean{debug}{true}}

\ProcessOptions

%</package>
% }{}
%
% \title{Typesetting spectral sequences in \LaTeX\ with sseq.sty}
% \author{Tilman Bauer\footnote{tilman@alum.mit.edu}}
% \date{April 9, 2009}
%
% \MakeShortVerb{\|}
%
% \maketitle
%
% \section{Introduction}
% 
% The present package, \texttt{sseq}, facilitates the typesetting of mathematical objects called \emph{spectral sequence charts} (henceforth simply called ``chart''). From a typographical point of view, a chart is a two-dimensional grid with integer coordinates; at every position (x,y), there may be any number of symbols (usually dots, little circles or boxes, digits etc.), possibly decorated with labels, and between any two such symbols may or may not be a connection---e.~g., a line, an arrow, or some curved line.
%
% The \texttt{sseq} package is built on top of the pgf package by Till Tantau. It shares the disadvantage of using up lots of \TeX's memory; therefore, if your system provides a \texttt{biglatex} or \texttt{hugelatex} command, it is wise to use it when using \texttt{sseq}. Still, problems may arise with very large charts (i.e., more than $100\times100$). Previous versions of |sseq| (pre-2.0) were based on the graphics package xy-Pic; the current version produces higher quality output and allows for more customization, at the cost of requiring a fairly recent \TeX distribution (or, at least, the packages |pgf| and |xkeyval| should be installed and the former should be no older than from 2006).
%
% This package automates the following functions:
%
% \begin{itemize}
% \item Automatic drawing of the grid and the axis labels;
% \item Clipping. Anything outside the displayed portion of the chart is clipped away. This has the advantage that a large chart, which does not fit on a page, can be cut into smaller pieces which contain exactly the same \texttt{sseq} code, but different clipping regions.
% \item Arranging. Multiple symbols dropped at the same integer coordinates will be automatically arranged so that they usually do not overlap. The algorithm for doing this is rather primitive, but still powerful enough for most applications
% \item Simplified ``turtle graphics'' syntax. Every primitive element of a chart is typeset with a macro defined by \texttt{sseq}.
% \item Control structures (loops, if/then, etc.) are allowed inside the \texttt{sseq} environment.
% \end{itemize}
%
%
% \section{Global options}
% 
% The |sseq| package is loaded with
%
% |\usepackage[|\meta{options...}|]{sseq}|.
%
% The following options are defined:
%
% \begin{itemize}
% \item |nops| is a deprecated option of a previous version. It is ignored.
% \item |nocolor| will tell |sseq| not to generate any color information. This includes gray shades. Many |dvi| drivers do not support color, but most of them tolerate (i.e. ignore) the color directives.
% \item |debug| will type out the pgf code generated by every |sseq| environment and wait for the user to confirm.
% \end{itemize}
%
%
% \section{Basic usage}
%
% \DescribeEnv{sseq}
% A spectral sequence is typeset by the code
%
% |\begin{sseq}[|\meta{options...}|]{|\meta{x-range}|}{|\meta{y-range}|}|
%
% \meta{sseq commands...}
%
% |\end{sseq}|
%
% In the simplest case, a range is of the form \meta{min}|...|\meta{max}, where \meta{min} and \meta{max} are two integers with \meta{min} $\leq$ \meta{max}.
%
% Thus |\begin{sseq}{2...5}{-3...-1}\end{sseq}| will typeset
% \[\begin{sseq}{2...5}{-3...-1}\end{sseq}.\]
%
% It is also possible for ranges to be a comma-separated list of ranges of the above form, e.g. |0...3,8...10|. In this case, the chart is broken into several pieces. Here is an example:
%
% \noindent\begin{minipage}{\textwidth/2}
% \begin{verbatim}\begin{sseq}{-1...3,5...8,20...24}
%            {0...2,4...4}
%\end{sseq}\end{verbatim}\end{minipage}\begin{minipage}{\textwidth/2}\begin{sseq}{-1...3,5...8,20...24}{0...2,4...4}\end{sseq}\bigskip\end{minipage}
%
% The minimum value of one block always has be at least two greater than the maximum of the previous block; |0...2,3...5| is illegal.
%
%
% The following options are defined for the |sseq| environment. Options in bold face are the default setting.
% \begin{description}
% \item[|grid=|]\meta{none,\textbf{crossword},go,dots,chess} Select an option of drawing the background grid.
%
% \begin{tabular}{ccccc}
% none & crossword & go & dots & chess\\
% \begin{sseq}[entrysize=2mm,labels=none,grid=none]{4}{4}\end{sseq} &
% \begin{sseq}[entrysize=2mm,labels=none,grid=crossword]{4}{4}\end{sseq} &
% \begin{sseq}[entrysize=2mm,labels=none,grid=go]{4}{4}\end{sseq} &
% \begin{sseq}[entrysize=2mm,labels=none,grid=dots]{4}{4}\end{sseq} &
% \begin{sseq}[entrysize=2mm,labels=none,grid=chess]{4}{4}\end{sseq}
% \end{tabular}
% \item[|entrysize=|\meta{size}] Specify the size of each square of the grid. The default is 4mm.
% \item[|labels=|\meta{labels},|xlabels=|\meta{labels},|ylabels=|\meta{labels}] Specify how labels on the x- and y-axis are drawn, respectively. The |labels| option sets both |xlabels| and |ylabels| to the same. Possible values are |none|, |numbers|, or an explicit list of semicolon-separated labels |{|\meta{$x_1$}|;|\meta{$x_2$}|;|\dots|}| which will be typeset in math mode. If the range consists of more than one block, the labels for the separate blocks are separated by a comma; see the example below. The default is |numbers|.
% \item[|labelstep=|\meta{step},|xlabelstep=|\meta{step},|ylabelstep=|\meta{step}] Frequently it is not desirable that every label is printed, but only every second or third label. This can be done by setting this option to a positive integer. The default is 2.
%
% The following example illustrates how labels can be customized:
%
% \noindent\begin{minipage}{\textwidth*2/3}
% \begin{verbatim}\begin{sseq}[xlabelstep=1,ylabelstep=4,
%             xlabels={x_1;x_2;x_3,y_1;y_2;y_3}]
%            {1...3,10...11}{0...4}
%\end{sseq}\end{verbatim}\end{minipage}\begin{minipage}{\textwidth/3}\begin{sseq}[xlabelstep=1,ylabelstep=4,xlabels={x_1;x_2;x_3,y_1;y_2;y_3}]{1...3,10...11}{0...4}\end{sseq}\end{minipage}
% \item[|gapsize=|\meta{size},|xgapsize=|\meta{size},|ygapsize=|\meta{size}] This sets the size of the gap between two blocks in a range (i.e. in the above example, the distance between the $x_3$ column and the $y_1$ column). The default is 3mm.
% \item[|gridstroke=|\meta{thickness}] For the grid types |crossword| and |go|, this sets the line width. The default is .1pt. A good option is to set it to the resolution of your output device.
% \item[|leak=|\meta{size},|xleak=|\meta{size},|yleak=|\meta{size}] When a line is drawn from within the visible range of the chart to a point outside, or vice versa, this line will protrude beyond the boundaries of the grid. These values define how far; the default is one third of |leak|.
% \item[|arrows=|\meta{arrow type}] Sets the default arrow type to use in the spectral sequence. Here are some default arrow types:
%
%\begin{sseq}[grid=none,labels=none]{0...3}{-2...0}
% \ssdrop{} \ssmove 3 0 \ssdrop{\mathtt{\;to}} \ssstroke[arrowto=to] \ssmove {-3}{-1}
% \ssdrop{} \ssmove 3 0 \ssdrop{\mathtt{\;stealth}} \ssstroke[arrowto=stealth] \ssmove {-3}{-1}
% \ssdrop{} \ssmove 3 0 \ssdrop{\mathtt{\;latex}} \ssstroke[arrowto=latex]
%\end{sseq}
%
% Other arrow types can be defined by the user or loaded from a library; see the pgf package documentation for details.
% \end{description}
%
% You may specify which algorithm you want to use to arrange multiple objects in
% a grid square. The following are possible:
% \begin{itemize}
% \item |\def\sseqpacking{\sspacksmart}|: the default, arrange dots roughly as on a dice
% \item |\def\sseqpacking{\sspackhorizontal}|: put all objects in a horizontal line, vertically centered.
% \item |\def\sseqpacking{\sspackvertical}|: put all objects in a vertical line, horizontally centered.
% \item |\def\sseqpacking{\sspackdiagonal}|: put all objects in a line going from top left to bottom right.
% \end{itemize}
%
% It is recommended to use the packing commands before the |\begin{sseq}| command;
% though it is possible to change the packing strategy within a single chart, the
% user has to take care to make sure that in every coordinate consistent packing
% strategies are used; the result will be unexpected otherwise.
%
% \section{sseq commands}
%
% Inside an |sseq| environment there is defined a virtual cursor, which starts out at position $(0,0)$ (even if that position is not within the visible region!). Most drawing commands are relative to the current cursor position; this facilitates reusage of |sseq| code when a certain pattern has to be repeated, as is often the case in mathematical spectral sequences.
%
% 
% \ifthenelse{0=1}{
%
% 

\def\sseq@currentname{}
\def\sseq@previousname{}

\newboolean{sseqhasopenconn}
\setboolean{sseqhasopenconn}{false}
\newboolean{sseqclip}
\setboolean{sseqclip}{true}

\def\sseqconncommand{}
\def\sseq@connbuffer{}
\def\sseq@currarrowstart{}
\def\sseq@currarrowend{}

\newif\ifsseq@connreverse

\ifthenelse{\boolean{usescolor}}
{
 \definecolor{sseqgr}{gray}{0.65}
 \definecolor{sslightgr}{gray}{0.8}
 \definecolor{ssred}{rgb}{1,0,0}
 \definecolor{ssblack}{rgb}{0,0,0}
}{}
\newcommand{\ssconncolor}{ssblack}
\newcommand{\sslabelcolor}{ssblack}
\newcommand{\ssplacecolor}{ssblack}

\def\sseqpacking{\sspacksmart}
% ^^A This is one of: {\sspacksmart,\sspackhorizontal,\sspackdiagonal,\sspackvertical}

%% ^^A Initialization
\newcount\sseqxstart \sseqxstart=0
\newcount\sseqystart \sseqystart=0
\newcount\sseqxstep
\newcount\sseqystep
\newdimen\sseqentrysize
\newdimen\sseq@xgap
\newdimen\sseq@ygap
\newdimen\sseq@xleak
\newdimen\sseq@yleak
\newdimen\ss@currsep \ss@currsep=\pgfshapeinnerxsep
\newdimen\ss@size
\newdimen\sseq@gridstrokethickness

\newsavebox\sseq@labelbox

\newif\ifssclipped 
\newif\ifcurroutofrange

\newtoks\sseqcmdlist
\sseqcmdlist={}

\def\currprefix{}

\long\def\ntimes#1#2{
\ifnum#1>0
 #2
 \count0=#1
 \advance\count0 by -1
 \edef\tmpcnt{\the\count0}
 \ntimes{\tmpcnt}{#2}
\fi
}

\long\def\for #1=#2\to#3\do#4\od{#1=#2 \sseq@for #1\to #3\do #4\od}
\long\def\sseq@for #1\to #2\do #3\od{%
 \ifnum #1>#2 \else
   #3\relax
  \advance #1 by 1
   \def\tempcmd{\sseq@for #1\to #2\do #3\od}%
   \expandafter\tempcmd
 \fi
}

\def\@eval#1#2{%
  \edef\tempcmd{\noexpand#1#2}%
  \tempcmd
}
%
% ^^A Support macros for ranges (like "-3...5,12...18")
%
\def\range@endmarker{END}
%
%
% ^^A range@parsenadnormalize{\targetcommand}{defaultstart}{string}
%
\def\range@parseandnormalize#1#2#3{\def#1{}\range@parseandnormalizeinnerloop{#1}{#2}{-10000}#3,END,}
%
\def\range@parseandnormalizeinnerloop#1#2#3#4,{%
 \def\temp{#4}%
 \ifx\temp\range@endmarker
  \edef #1{#1END;END,}%
 \else
  \def\tempoutercmd{\range@parseinnerpart{#1}{#2}{#3}#4...END...}%
  \expandafter\tempoutercmd
 \fi
}
%
\def\range@parseinnerpart#1#2#3#4...#5...{%
 \def\temp{#5}
 \ifx\temp\range@endmarker
   \count0=#2
   \advance\count0 by #4
   \advance\count0 by -1
   \edef\tempcmd{\noexpand\range@parseinnerpart{\noexpand#1}{#2}{#3}#2...\number\count0...END...}
 \else
   \count0=#3
   \count1=#4
   \count2=#5
   \ifnum\count1<\count0
     \PackageError{sseq}{Illegal stepping in range}{In a range a...b,c...d, c has to be >= b+2. In your case, b+2=#3 and c=#4. I'll replace c by #3.}
     \count1=#3
   \fi
   \ifnum\count2<\count1
     \PackageError{sseq}{Illegal range}{In a range a...b, b has to be at least as big as a. In your case, a=\number\count1 and b=#5. I'll replace b by \number\count1.}
     \count2=\count1
   \fi
   \count0=\count2
   \advance\count0 by 2
   \edef#1{#1\number\count1;\number\count2,}
   \edef\tempcmd{\noexpand\range@parsegobbleend{\noexpand#1}{#2}{\number\count0}}
 \fi
 \tempcmd
}
%
\def\range@parsegobbleend#1#2#3#4...{%
\range@parseandnormalizeinnerloop{#1}{#2}{#3}%
}
%
% \range@loop {command} range
%
\newif\ifrangebreak
%
%
\def\range@loop#1#2;#3,{
 \rangebreakfalse
 \def\temp{#2}
 \def\tempcmd{}
 \ifx\temp\range@endmarker\else
   #1{#2}{#3}
   \advance\sseqj by 1
   \ifrangebreak
    \def\tempcmd{\range@gobbletoend}
   \else
    \def\tempcmd{\range@loop{#1}}
   \fi
 \fi
 \tempcmd
}
%
%
\newif\ifoutofrange
%
% ^^A Compute absolute coordinates from logical ones
% ^^A return them in \sseqx and \sseqy
%
% ^^A \range@getabsoluteposition{pos}{stepinc}{gapinc}{offset}range
% ^^A return value in \dimen0; also set \ifoutofrange
%
\def\range@getabsoluteposition#1#2#3#4#5;#6,{
 \outofrangefalse
 \def\temp{#5}
 \def\tempcmd{}
 \count0=#1
 \ifx\temp\range@endmarker
   \outofrangetrue
 \else % ^^A now #4 contains the current min and #5 the current max
   \ifnum\count0<#5
     \outofrangetrue
     \def\tempcmd{\range@gobbletoend}
   \else
     \ifnum\count0>#6
       \count0=#6
       \advance\count0 by 1
       \count1=#5
       \multiply\count1 by -1
       \advance\count0 by \count1
       \dimen0=#2
       \multiply\dimen0 by \count0
       \advance\dimen0 by #4
       \advance\dimen0 by #3
       \edef\tempcmd{\noexpand\range@getabsoluteposition{#1}{#2}{#3}{\number\dimen0sp}}
     \else
       \count1=#5
       \multiply\count1 by -1
       \advance\count0 by \count1
       \dimen0=#2
       \multiply\dimen0 by \count0
       \advance\dimen0 by #4
       \def\tempcmd{\range@gobbletoend}
     \fi
   \fi
 \fi
 \tempcmd
}
\def\range@gobbletoend#1END,{}

\def\ss@getcoords#1#2{
 \edef\tempcmd{\noexpand\range@getabsoluteposition{#1}{\number\sseqentrysize sp}{\number\sseq@xgap sp}{0pt}}
 \expandafter\tempcmd\sseq@xrange
 \sseqx=\dimen0
 \edef\tempcmd{\noexpand\range@getabsoluteposition{#2}{\number\sseqentrysize sp}{\number\sseq@ygap sp}{0pt}}
 \ifoutofrange
  \expandafter\tempcmd\sseq@yrange
  \outofrangetrue
 \else
  \expandafter\tempcmd\sseq@yrange
 \fi
 \sseqy=\dimen0
}


%
% ^^A \putxy will put a list of commands into the execution queue
%
\def\putxyq#1{\toks0={#1}%
 \edef\act{\noexpand\sseqcmdlist={\the\sseqcmdlist \the\toks0}}%
 \act
}
\def\putxy#1{%
 \edef\act{\noexpand\sseqcmdlist={\the\sseqcmdlist #1}}%
 \act
}

%
%
%
\def\sseqwritecolor#1{
\ifthenelse{\boolean{usescolor}}{
  \putxy{\noexpand\color{#1}}
}{}
}
%
%
%

\def\sseqconcludeconnection{
 \sseqconncommand
 \setboolean{sseqhasopenconn}{false}
}

\def\dropvarname#1#2{\csname sseqdrop#1,#2\endcsname}

\def\ifuniquedrop#1#2{
\edef\tmpval{\dropvarname{#1}{#2}}
\expandafter\ifx\tmpval1
}

\def\ifnodrop#1#2{
\edef\tmpval{\dropvarname{#1}{#2}}
\expandafter\ifx\tmpval\relax
}

\def\ssdroperrormsg#1#2{
 \ifnodrop{#1}{#2}
  \PackageError{sseq}{cannot open position (#1,#2): nothing dropped yet}{You cannot draw any connection until you have drawn the source.}
 \else
  \PackageError{sseq}{cannot open position (#1,#2): multiple drops}{You cannot specify this position by coordinates. Instead, name it.}
 \fi
}
%
% ^^A update sseqabsposx, sseqabspoy, ifcurroutofrange from sseqposx, sseqposy.
%
\def\sseq@updatecurrentdata{
 \@eval\ss@getcoords{{\number\sseqposx}{\number\sseqposy}}
 \sseqabsposx=\sseqx
 \sseqabsposy=\sseqy
 \let\ifcurroutofrange\ifoutofrange
}

\def\sseq@openposition{
 \ifuniquedrop{\the\sseqposx}{\the\sseqposy}
  \edef\sseq@currentname{ss(\number\sseqposx,\number\sseqposy)1}
 \else
  \ssdroperrormsg{\the\sseqposx}{\the\sseqposy}
  \def\sseq@currentname{}
 \fi
}

\def\ssassertsource{
 \sseq@flushconn
 \ifx\sseq@currentname\empty
  \sseq@openposition
 \fi
}

\def\ssfinishpos{
 \sseq@flushconn
 \ifx\sseq@currentname\empty
 \else
   \ifthenelse{\boolean{sseqhasopenconn}}
   {
     \sseqconcludeconnection
   }{}
   \edef\sseq@previousname{\sseq@currentname}
   \def\sseq@currentname{}
 \fi
}  


% ^^A Packing subroutines. Count11 contains the number of previously dropped objects that have to be rearranged. Count0-count9 contain the previously dropped object numbers. dimen5 contains the stepping, dimen6 its negative.
\def\sspacksmart#1#2{
 \ifcase\count11
  % ^^A 0
  \PackageError{sseq}{This can't happen!}{Internal error. Contact the author.}
 \or % ^^A 1
  \sseqrearrange{#1}{#2}{\the\count1}{\the\dimen6}{\the\dimen5}
  \advance\sseqx by \dimen5
  \advance\sseqy by \dimen6
 \or % ^^A 2
  \sseqrearrange{#1}{#2}{\the\count2}{0pt}{\the\dimen5}
  \sseqrearrange{#1}{#2}{\the\count2}{0pt}{\the\dimen5}
  \advance\sseqy by \dimen6
 \or % ^^A 3
  \sseqrearrange{#1}{#2}{\the\count3}{\the\dimen6}{0pt}
  \advance\sseqx by \dimen5
  \advance\sseqy by \dimen6
 \or % ^^A 4 -- give up on being clever and put everything in one diagonal row.
  \sseqrearrange{#1}{#2}{\the\count2}{\the\dimen6}{\the\dimen6}
  \sseqrearrange{#1}{#2}{\the\count3}{\the\dimen5}{0pt}
  \sseqrearrange{#1}{#2}{\the\count3}{\the\dimen5}{0pt}
  \sseqrearrange{#1}{#2}{\the\count4}{\the\dimen5}{\the\dimen6}
  \advance\sseqx by \dimen5
  \advance\sseqx by \dimen5
  \advance\sseqx by \dimen5
  \advance\sseqy by \dimen6
  \advance\sseqy by \dimen6
  \advance\sseqy by \dimen6
 \else
  \advance\count11 by -1
  \multiply\dimen5 by \count11
  \multiply\dimen6 by \count11
  \advance\sseqx by \dimen5
  \advance\sseqy by \dimen6
 \fi
}

\def\sspackhorizontal#1#2{
 \divide\dimen6 by 2
 \divide\dimen5 by 2
 \for\count10=1 \to \count11 \do
   \sseqrearrange{#1}{#2}{\the\count\count10}{\the\dimen6}{0pt}
 \od
 \multiply\dimen5 by \count11
 \advance\sseqx by \dimen5
}
\def\sspackvertical#1#2{
 \divide\dimen6 by 2
 \divide\dimen5 by 2
 \for\count10=1 \to \count11 \do
   \sseqrearrange{#1}{#2}{\the\count\count10}{0pt}{\the\dimen6}
 \od
 \multiply\dimen5 by \count11
 \advance\sseqy by \dimen5
}
\def\sspackdiagonal#1#2{
 \divide\dimen6 by 2
 \divide\dimen5 by 2
 \for\count10=1 \to \count11 \do
   \sseqrearrange{#1}{#2}{\the\count\count10}{\the\dimen6}{\the\dimen5}
 \od
 \multiply\dimen5 by \count11
 \multiply\dimen6 by \count11
 \advance\sseqx by \dimen5
 \advance\sseqy by \dimen6
}


\def\sseqpack#1#2{
\expandafter\ifx\sseqpacking\ssequndefined
 \PackageError{sseq}{Unknown packing option, reverting to \string\sspacksmart}{You apparently have redefined \string\sspacksmart. The only allowed values are: \string\sspacksmart,\string\sspackhorizontal,\string\sspackdiagonal,\string\sspackvertical.}
 \gdef\sseqpacking{\sspacksmart}
\fi
\sseqpacking{#1}{#2}
}

\def\sseqrearrange#1#2#3#4#5{
\dimen0 = \csname sseqcoordx<#1,#2>#3\endcsname
\dimen1 = \csname sseqcoordy<#1,#2>#3\endcsname
\advance\dimen0 by #4
\advance\dimen1 by #5
\expandafter\edef\csname sseqcoordx<#1,#2>#3\endcsname{\the\dimen0}
\expandafter\edef\csname sseqcoordy<#1,#2>#3\endcsname{\the\dimen1}
}

\def\sseqstacking#1#2#3{ % ^^A (xpos, ypos, number of previous drops)
 \dimen5=\sseqentrysize
 \divide\dimen5 by 4
 \dimen6=\dimen5
 \multiply\dimen6 by -1
%
 \count11=0
 \for\count10=1 \to #3 \do
  \if1\csname sseqwillmove<#1,#2>\the\count10 \endcsname
   \advance\count11 by 1
   \expandafter\count\the\count11=\count10
  \fi
 \od
 \ifnum\count11<9
 \else
   \PackageError{sseq}{Too many drops at (#1,#2)}{The sseq.sty algorithm can only place up to nine independent drops in one position.}
 \fi
 \sseqpack{#1}{#2}
}

% ^^A This sets the new shape inner x- and y-separation to the new value
% ^^A It avoids issuing a command if it's already set to the right value
\def\ss@setshapesep#1{
 \ifdim\ss@currsep=#1\else
   \putxy{\noexpand\pgfsetshapeinnerxsep{#1}\noexpand\pgfsetshapeinnerysep{#1}}
   \ss@currsep=#1
 \fi
}

\def\sseq@setcircumference{
 \expandafter\ss@size\expandafter=\expandafter\csname\sseq@currentname size\endcsname
 \advance\ss@size by 1pt
 \ifKV@sseqdrop@boxed  
    \advance\ss@size by 2pt
  \fi
 \ss@setshapesep{\the\ss@size}
}

% ^^A This replaces \ssplacespecial in the xy version.
% ^^A Arguments: 1,2 = x- and y-coordinates
% ^^A              3 = pgf shape
% ^^A              4 = pgf path usage
% ^^A              5 = contents
%
\def\ss@placespecial#1#2#3#4#5{
%
 \ssfinishpos
%
 \ss@getcoords{#1}{#2}
 \advance\sseqx by \sseqhalfentry
 \advance\sseqy by \sseqhalfentry
%
 \expandafter\def\expandafter\tmpname\expandafter{\csname sseqdrop#1,#2\endcsname}
%
\ifnodrop{#1}{#2}
\expandafter\def\tmpname{1}
\else
 \edef\setcnt{\noexpand\count0=\tmpname}
 \setcnt
 \sseqstacking{#1}{#2}{\tmpname}
 \advance\count0 by 1
 \expandafter\edef\tmpname{\the\count0}
\fi
\putxyq{\pgftransformshift}
\putxy{{\noexpand\pgfpoint{\csname sseqcoordx<#1,#2>\tmpname\endcsname}{\csname sseqcoordy<#1,#2>\tmpname \endcsname}}}
%
%
\ifoutofrange % ^^A Outside clipping region -- produce an empty node
 \putxyq{\pgfnode{coordinate}{center}{}}
 % ^^A now give it a unique name
 \putxy{{ss(#1,#2)\tmpname}}
 \putxyq{{}}
\else
 \sseqwritecolor{\ssplacecolor}
 \putxyq{\pgfnode{#3}{center}}
 \putxyq{{#5}}
% ^^A now give it a unique name
 \putxy{{ss(#1,#2)\tmpname}}
 \putxyq{{#4}}
\fi
%
\putxyq{\pgftransformreset}
%
\def\temp{#5}
\ifx\temp\empty % ^^A It's a bullet or a circle or such
  \dimen0=1pt
\else
  \setbox0=\hbox{#5}
  \dimen0=0.5\wd0
\fi
\expandafter\edef\csname sseqcoordx<#1,#2>\tmpname\endcsname{\the\sseqx}
\expandafter\edef\csname sseqcoordy<#1,#2>\tmpname\endcsname{\the\sseqy}
\expandafter\edef\csname ss(#1,#2)\tmpname size\endcsname{\number\dimen0 sp}
\expandafter\def\csname sseqwillmove<#1,#2>\tmpname\endcsname{1}
%
\edef\sseq@currentname{ss(#1,#2)\tmpname}
%
\ifthenelse{\boolean{sseqhasopenconn}}{\sseqconcludeconnection}{}
}

\newcommand{\ssplace}[3]{
 \ss@setshapesep{0pt}
 \putxyq{\pgfsetdash{}{0pt}}
 \ss@placespecial{#1}{#2}{rectangle}{\pgfusepath{discard}}{\ensuremath{#3}}
}

\newcommand{\ssplaceboxed}[3]{
 \ss@setshapesep{1pt}
 \putxyq{\pgfsetdash{}{0pt}}
 \ss@placespecial{#1}{#2}{rectangle}{\pgfusepath{stroke}}{\ensuremath{#3}}
}

\newcommand{\ssplacecircled}[3]{
 \ifthenelse{\equal{#3}{1}
         \OR \equal{#3}{2}
         \OR \equal{#3}{3}
         \OR \equal{#3}{4}
         \OR \equal{#3}{5}
         \OR \equal{#3}{6}
         \OR \equal{#3}{7}
         \OR \equal{#3}{8}
         \OR \equal{#3}{9}}{
% ^^A replace circled single digits by the corresponding dings -- looks better
% ^^A The following adjustment to the bounding circle is based on experimentation
% ^^A Let's hope it doesn't differ too much from one dingbat font to the other...
  \ss@setshapesep{-.3ex}
  \count0=191
  \advance\count0 by #3
  \def\ss@tmpcmd{\ss@placespecial{#1}{#2}{circle}{\pgfusepath{discard}}}
  \expandafter\ss@tmpcmd\expandafter{\expandafter\ding\expandafter{\the\count0}}
 }{
   \putxyq{\pgfsetdash{}{0pt}}
   \ss@setshapesep{0pt}
   \ss@placespecial{#1}{#2}{circle}{\pgfusepath{stroke}}{\ensuremath{#3}}
 }
}

\newcommand{\ssglobalname}[1]{\currprefix#1}


\def\sssetglobalname#1{
 \ssassertsource
 \expandafter\edef\csname sseqpos<#1>\endcsname{\sseq@currentname}
 \expandafter\edef\csname sseqx<#1>\endcsname{\the\sseqposx}
 \expandafter\edef\csname sseqy<#1>\endcsname{\the\sseqposy}
}
% }{}
%
% \DescribeMacro{\ssmoveto} 
% To move the cursor to the absolute position (x,y), use |\ssmoveto{x}{y}|.
%
% \ifthenelse{0=1}{
\newcommand{\ssmoveto}[2]{
 \ifthenelse{\boolean{sseqhasopenconn}}
 {
   \sseqconcludeconnection
 }{}
\ssfinishpos
\sseqposx=#1
\sseqposy=#2
\sseq@updatecurrentdata
}
% }{}
% \DescribeMacro{\ssmove}
% To move the cursor relative to the current position by (x,y), use |\ssmove{x}{y}|.
%
% \iffalse
\newcommand{\ssmove}[2]{
\sseqi=\sseqposx
\advance\sseqi by #1
\sseqj=\sseqposy
\advance\sseqj by #2
\@eval\ssmoveto{{\number\sseqi}{\number\sseqj}}
}
% \fi
%
%
% \DescribeMacro{\ssdrop}
% The command |\ssdrop[|\meta{optios}|]{|\meta{mathcode}|}| will display \emph{mathcode} at the current cursor position. The argument is always interpreted in math mode.
% The following options can be given:
% \begin{description}
% \item[|circled|] A circle is drawn around the object. If the object is a digit 1,\dots,9, a dingbat (eg. \ding{192}) is substituted.
% \item[|boxed|] A box is drawn around the object.
% \item[|color=|\meta{color}] The object is drawn in the specified color. Any \LaTeX{} color can be used, e.g. predefined colors such as |black|, |blue|, |PineGreen|, etc., or user defined rgb colors.
% \item[|name=|\meta{name}] This is equivalent to issuing |\ssname{|\meta{name}|}| after |\ssdrop|, see below.
% \end{description}
% If the argument is |\bullet| or |\circle|, the object is replaced by a better-spaced graphics primitive.
%
% \ifthenelse{0=1}{
\define@key{sseqdrop}{circled}[true]{\newif\ifKV@sseqdrop@circled\csname KV@sseqdrop@circled#1\endcsname}
\define@key{sseqdrop}{boxed}[true]{\newif\ifKV@sseqdrop@boxed\csname KV@sseqdrop@boxed#1\endcsname}
\define@key{sseqdrop}{color}{\def\ssplacecolor{#1}}
\define@key{sseqdrop}{name}{\def\sseq@name{#1}}
%
\def\ssdrop{\@ifnextchar[\sseq@drop{\sseq@drop[]}}
\def\sseq@drop[#1]#2{
 \edef\sseq@savecolor{\ssplacecolor}
 \def\sseq@name{\relax}
 \presetkeys{sseqdrop}{circled=false,boxed=false}{}
 \setkeys{sseqdrop}{#1}
 \ifKV@sseqdrop@circled
   \ssplacecircled{\number\sseqposx}{\number\sseqposy}{#2}
 \else
   \ifKV@sseqdrop@boxed
     \ssplaceboxed{\number\sseqposx}{\number\sseqposy}{#2}
   \else
     \def\temp{#2}
	 \def\temptwo{\bullet}
	 \ifx\temp\temptwo
	   \ss@setshapesep{0pt}
       \ss@placespecial{\number\sseqposx}{\number\sseqposy}{circle}{\pgfusepath{fill}}{}
	 \else
	   \def\temptwo{\circle}
	   \ifx\temp\temptwo
	     \ss@setshapesep{0pt}
         \ss@placespecial{\number\sseqposx}{\number\sseqposy}{circle}{\pgfusepath{stroke}}{}
       \else
         \ssplace{\number\sseqposx}{\number\sseqposy}{#2}
	   \fi
	 \fi
   \fi
 \fi
 \edef\ssplacecolor{\sseq@savecolor}
 \def\temp{\relax}
 \ifx\sseq@name\temp \else
   \@eval\ssname{{\sseq@name}}
 \fi
}
% }{}
%
% ^^A The following are commands purely kept for compatibility.
%
% \iffalse
%
\newcommand{\ssdropbull}{\ssdrop{\bullet}}
\newcommand{\ssdropboxed}[1]{\ssdrop[boxed]{#1}}
\newcommand{\ssdropcircled}[1]{\ssdrop[circled]{#1}}
% \fi
%
% \DescribeMacro{\ssname}
% |\ssname{|\meta{name}|}| gives the object most recently dropped the name \meta{name}. If the previous command is one of the drop commands, then it refers to that object; if it is not, then if there is one and only one object at the current cursor position, it refers to that object; if that is also not the case, an error message is generated.
%
% \iffalse
\def\ssname#1{
 \sssetglobalname{\ssglobalname{#1}}
}
% \fi
%
% \DescribeMacro{\ssgoto}
% After an object has been given a \meta{name} with |\ssname|, the cursor can be moved back to that object at any time by issuing |\ssgoto{|\meta{name}|}|. This becomes necessary when there is more than one object in one position.
%
% \iffalse
\newcommand{\ssgoto}[1]{
\ssabsgoto{\ssglobalname{#1}}
}
% \fi
%
% \DescribeMacro{\ssprefix}
% Often the mechanism provided by |\ssname|/|\ssgoto| is not flexible enough to deal with repeated code. In that case, |\ssprefix{|\meta{prefix}|}| defines a prefix for all names that follow; i.e. a |\ssname{|\meta{name}|}| after such a command will really define a name \meta{prefix}\meta{name}. However, since |\ssgoto| also observes the prefix, |\ssgoto{|\meta{name}|}| will still work. |\ssprefix| commands can be iterated; the prefices are then concatenated (most recent right).
%
% \iffalse
\newcommand{\ssprefix}[1]{
  \edef\currprefix{\currprefix#1}
}
% \fi
%
% \DescribeMacro{\ssresetprefix}
% This command resets the prefix defined by (a sequence of) |\ssprefix| to the empty prefix.
%
% \iffalse
\newcommand{\ssresetprefix}{\def\currprefix{}}
% \fi
%
% \DescribeMacro{\ssabsgoto}
% This is a version of |\ssgoto| that ignores the current prefix.
%
% \ifthenelse{0=1}{
\newcommand{\ssabsgoto}[1]{
 \ifthenelse{\boolean{sseqhasopenconn}}
 {
   \sseqconcludeconnection
 }{}
 \ssfinishpos
 \edef\sseq@currentname{\csname sseqpos<#1>\endcsname}
 \sseqposx=\csname sseqx<#1>\endcsname
 \sseqposy=\csname sseqy<#1>\endcsname
 \sseq@updatecurrentdata
}
% }{}
%
% \DescribeMacro{\ssdroplabel}
% This command decorates the previously typeset object with a label. It is used in the form
% |\ssdroplabel[|\meta{options...}|]{|\meta{label}|}|.
%
% The \meta{label} will then be typeset next to the most recently dropped object (for a definition for what that is, exactly, consult the description of |\ssname|). If you specify one of |U|,|LU|,|RU|,|L|,|R|,|LD|,|RD|,|D| as an option, the label is positioned relative to the object it labels (default: |U|=up).
% As in |\ssdrop|, an option |color=|\meta{color} will typeset the label in the \LaTeX{} color \meta{color}.
%
% \ifthenelse{0=1}{
\define@key{sseqlabel}{color}{\def\sslabelcolor{#1}}
\define@key{sseqlabel}{pos}{\def\sseq@position{#1}}
\define@key{sseqlabel}{U}[]{\def\sseq@position{U}}
\define@key{sseqlabel}{LU}[]{\def\sseq@position{LU}}
\define@key{sseqlabel}{L}[]{\def\sseq@position{L}}
\define@key{sseqlabel}{LD}[]{\def\sseq@position{LD}}
\define@key{sseqlabel}{D}[]{\def\sseq@position{D}}
\define@key{sseqlabel}{RD}[]{\def\sseq@position{RD}}
\define@key{sseqlabel}{R}[]{\def\sseq@position{R}}
\define@key{sseqlabel}{RU}[]{\def\sseq@position{RU}}
%
\def\ssdroplabel{\@ifnextchar[\sseq@droplabel{\sseq@droplabel[]}}
\def\sseq@droplabel[#1]#2{
\ssassertsource
\ifcurroutofrange\else
 \edef\sseq@savecolor{\sslabelcolor}
 \def\sseq@position{L}
 \setkeys{sseqlabel}{#1}
%
 \ifthenelse{\equal{\sseq@position}{U}}{\def\sseq@anchor{north} \def\sseq@link{south}}{}
 \ifthenelse{\equal{\sseq@position}{LU}}{\def\sseq@anchor{north west} \def\sseq@link{south east}}{}
 \ifthenelse{\equal{\sseq@position}{L}}{\def\sseq@anchor{west} \def\sseq@link{east}}{}
 \ifthenelse{\equal{\sseq@position}{LD}}{\def\sseq@anchor{south west} \def\sseq@link{north east}}{}
 \ifthenelse{\equal{\sseq@position}{D}}{\def\sseq@anchor{south} \def\sseq@link{north}}{}
 \ifthenelse{\equal{\sseq@position}{RD}}{\def\sseq@anchor{south east} \def\sseq@link{north west}}{}
 \ifthenelse{\equal{\sseq@position}{R}}{\def\sseq@anchor{east} \def\sseq@link{west}}{}
 \ifthenelse{\equal{\sseq@position}{RU}}{\def\sseq@anchor{north east} \def\sseq@link{south west}}{}
%
 \sseqwritecolor{\sslabelcolor}
 \putxyq{\pgftransformshift}
 \putxy{{\noexpand\pgfpointanchor{\sseq@currentname}{\sseq@anchor}}}
 \putxyq{\pgfnode{rectangle}}
 \putxy{{\sseq@link}}
 \putxyq{{\ensuremath{#2}}{}{\pgfusepath{discard}}}
 \putxyq{\pgftransformreset}
 \edef\sslabelcolor{\sseq@savecolor}
\fi
}
% }{}
%
% \DescribeMacro{\ssdropextension}
% This command has no arguments and is rather specialized. It refers to a previously dropped object (see |\ssname|), draws a circle around it, and considers that circle a new object. Thus it produces a new circle object that is attached to the original object, and not subject to the algorithm that tries to make objects non-overlapping.
%
% \ifthenelse{0=1}{
\define@key{sseqdropext}{circled}[true]{\newif\ifKV@sseqdrop@circled\csname KV@sseqdrop@circled#1\endcsname}
\define@key{sseqdropext}{boxed}[true]{\newif\ifKV@sseqdrop@boxed\csname KV@sseqdrop@boxed#1\endcsname}
\define@key{sseqdropext}{color}{\def\ssplacecolor{#1}}
\define@key{sseqdropext}{name}{\def\sseq@name{#1}}
%
\def\ssdropextension{\@ifnextchar[\sseq@dropextension{\sseq@dropextension[]}}
\def\sseq@dropextension[#1]{
 \edef\sseq@savecolor{\ssplacecolor}
 \def\sseq@name{\relax}
 \presetkeys{sseqdropext}{circled=false,boxed=false}{}
 \setkeys{sseqdrop}{#1}
 \ssassertsource
 \expandafter\def\expandafter\tmpname\expandafter{\csname sseqdrop\the\sseqposx,\the\sseqposy\endcsname}
 \edef\setcnt{\noexpand\count0=\tmpname}
 \setcnt
 \advance\count0 by 1
 \expandafter\edef\tmpname{\the\count0}
 \putxyq{\pgftransformshift}
 \putxy{{\noexpand\pgfpointanchor{\sseq@currentname}{center}}}
 \ifoutofrange
  \putxyq{\pgfnode{coordinate}{center}{}}
  \putxy{{ss(\the\sseqposx,\the\sseqposy)\tmpname}{}}
 \else
   \sseqwritecolor{\ssplacecolor}
   \sseq@setcircumference
   \ifKV@sseqdrop@boxed  
     \putxyq{\pgfnode{rectangle}{center}{}}
   \else
     \putxyq{\pgfnode{circle}{center}{}}
   \fi
   \putxy{{ss(\the\sseqposx,\the\sseqposy)\tmpname}}
   \putxyq{{\pgfusepath{stroke}}}
 \fi
 \putxyq{\pgftransformreset}
%
% ^^A now give it a unique name
%
 \edef\sseq@currentname{ss(\number\sseqposx,\number\sseqposy)\tmpname}
 \expandafter\edef\csname \sseq@currentname size\endcsname{\number\ss@size sp}
%
 \ifthenelse{\boolean{sseqhasopenconn}}{\sseqconcludeconnection}{}
%
 \edef\ssplacecolor{\sseq@savecolor}
 \def\temp{\relax}
 \ifx\sseq@name\temp \else
   \@eval\ssname{{\sseq@name}}
 \fi
}
%
\def\ssprepareline#1#2{
 \ssassertsource\ssfinishpos
 \advance\sseqposx by #1
 \advance\sseqposy by #2
 \sseq@updatecurrentdata
 \setboolean{sseqhasopenconn}{true}
}
%
\def\extractcoords ss(#1,#2)#3{{#1}{#2}}
%
\def\sseq@flushconn{
 \ifx\sseq@connbuffer\empty\else
   \ifsseq@connreverse
     \putxy{\noexpand\pgfsetarrows{\sseq@currarrowend-\sseq@currarrowstart}}
   \else
     \putxy{\noexpand\pgfsetarrows{\sseq@currarrowstart-\sseq@currarrowend}}
   \fi
   \sseq@connbuffer
   \def\sseq@connbuffer{}
   \def\sseq@currarrowstart{}
   \def\sseq@currarrowend{}
 \fi
}
% ^^A parameters: 1 = dashing (e.g. {{1pt}{1pt}} = dashed, {} = solid)
% ^^A             2 = bending ({} = no bend)
% ^^A             3 = target is void (true/false)
%
\def\sseq@connection#1#2#3{
 \sseq@flushconn
 \ifthenelse{\boolean{#3}}{}{\ssassertsource}
 \sseq@connreversefalse
 \edef\sseq@prevxy{\expandafter\extractcoords\sseq@previousname}
 \expandafter\ss@getcoords\sseq@prevxy
% ^^A now prevxy={fromx}{fromy}, \ifoutofrange=fromclip, \sseqx,\sseqy = fromcoords (if in range)
% ^^A sseqposx=tox,sseqposy=toy, \ifcurroutofrange=toclip, \sseqabsposx,\sseqabsposy = tocoords (if in range)
% ^^A only do it if not both source and target are outside the clipping region
 \ifcurroutofrange
   \ifoutofrange % ^^A both out of range -- do nothing
   \else % ^^Afrom within range to out of range -- draw a void line
     % ^^A need to recompute the relative coordinates
     \@eval\sseq@diffhelper{\sseq@prevxy{\number\sseqposx}{\number\sseqposy}}
     \@eval\sseq@lineintooff{{\sseq@previousname}\sseq@prevxy{\number\count0}{\number\count1}{#1}{#2}}
   \fi
 \else
   \ifoutofrange % ^^A from out of range to within range -- draw a void line
     \ifthenelse{\boolean{#3}}{}{ % ^^A if the target is also void -- do nothing.
       \sseq@connreversetrue
       \@eval\sseq@diffhelper{{\number\sseqposx}{\number\sseqposy}\sseq@prevxy}
       \@eval\sseq@lineintooff{{\sseq@currentname}{\sseqposx}{\sseqposy}{\number\count0}{\number\count1}{#1}{#2}}
	 }
   \else
     \putxyq{\pgfsetdash{#1}{0pt}}
	 \ifthenelse{\boolean{#3}}{ % ^^A draw a void line
	   \multiply\sseqx by -1
	   \advance\sseqx by \sseqabsposx
	   \multiply\sseqy by -1
	   \advance\sseqy by \sseqabsposy
       \putxy{\noexpand\pgftransformshift{\noexpand\pgfpointanchor{\sseq@previousname}{center}}}
       \putxyq{\pgfpathmoveto}
       \putxy{{\noexpand\pgfpointshapeborder{\sseq@previousname}%
                                            {\noexpand\pgfpoint{\the\sseqx}{\the\sseqy}}}}
	 }{
       \putxyq{\pgfpathmoveto}
       \putxy{{\noexpand\pgfpointshapeborder{\sseq@previousname}{\noexpand \pgfpointanchor{\sseq@currentname}{center}}}}
	 }			
	\putxyq{\pgfpathlineto}
	\ifthenelse{\boolean{#3}}{
       \putxy{{\noexpand\pgfpoint{\the\sseqx}{\the\sseqy}}}
	 }{
       \putxy{{\noexpand\pgfpointshapeborder{\sseq@currentname}{\noexpand \pgfpointanchor{\sseq@previousname}{center}}}}
     } 							
     \def\sseq@temp{#2}
     \ifx\sseq@temp\empty
     \else
       \putxyq{\pgfdecorationsegmentamplitude=#2pc}
       \putxyq{\multiply\pgfdecorationsegmentamplitude by 3 }
       \putxyq{\pgfdecorationsegmentaspect=.3}
       \putxyq{\pgfdecoratecurrentpath{bent}}
     \fi
	 \edef\sseq@connbuffer{\noexpand\sseqwritecolor{\ssconncolor}\noexpand\putxyq{\noexpand\pgfusepath{stroke}\noexpand\pgftransformreset}}
   \fi
 \fi
}
% ^^A xmin,ymin,xmax,ymax --> \count0,\count1
\def\sseq@diffhelper#1#2#3#4{
  \count0=#1
  \multiply\count0 by -1
  \advance\count0 by #3
  \count1=#2
  \multiply\count1 by -1
  \advance\count1 by #4
}
% }{}
%
%
% \DescribeMacro{\ssstroke}
% There are two ways of typesetting connections between objects. One of them is the command |\ssstroke|, which 
% requires that the cursor recently moved from one object to another. It takes no non-optional arguments and typesets a 
% line between the two objects. Example: Suppose there are two objects, which have been given the names |a| and |b| 
% by |\ssname|. Drawing a line between them is achieved by the command |\ssgoto{a} \ssgoto{b} \ssstroke|.
%
% The following options can be given in the form |\ssstroke[options]|:
% \begin{description}
% \item[|color=|color] the connection is drawn in the given \LaTeX{} color
% \item[|curve=|value] the connection is curved to the left by an amount proportional to the value given.
% \item[{|dashed|[=dashing type]}] the connection is drawn in a dashed style. The optional \emph{dashing type} is an
% expression of the form |{{a}{b}...}|, where each of a, b, \dots is a length (like 2pt or 3mm). The line then consists of
% a stroke of length |a|, followed by a gap of length |b|, followed by a stroke of length ... etc.
% \item[{|dotted|[=dashing type]}] the connection is drawn in a dotted style. If the optional dashing type is given,
% this option behaves exactly like |dashed|.
% \item[{|arrowfrom|[=arrow style]}] An arrow is drawn at the beginning of the line. The global arrow style can be overridden
% by specifying an arrow style.
% \item[{|arrowto|[=arrow style]}] An arrow is drawn at the end of the line.
% \item[|void|] This option says that the target of the connection is not another object; instead, the connection should just point into the correct direction.
% \end{description}
%
% \ifthenelse{0=1}{
%
\define@key{sseqstroke}{color}{\def\ssconncolor{#1}}
\define@key{sseqstroke}{curve}{\def\sseq@curve{#1}}
\define@key{sseqstroke}{dashed}[{{2pt}{2pt}}]{\def\sseq@dashing{#1}}
\define@key{sseqstroke}{dotted}[{{.5pt}{2pt}}]{\def\sseq@dashing{#1}}
\define@key{sseqstroke}{arrowfrom}[\sseq@defaultarrowstyle]{\edef\sseq@arrowfrom{#1}}
\define@key{sseqstroke}{arrowto}[\sseq@defaultarrowstyle]{\edef\sseq@arrowto{#1}}
\define@key{sseqstroke}{void}[true]{\newif\ifKV@sseqstroke@void\csname KV@sseqstroke@void#1\endcsname}
%
\def\ssstroke{\@ifnextchar[\sseq@stroke{\sseq@stroke[]}}
\def\sseq@stroke[#1]{
 \edef\sseq@savecolor{\ssconncolor}
 \def\sseq@dashing{}
 \def\sseq@curve{}
 \edef\sseq@arrowfrom{\sseq@currarrowstart}
 \edef\sseq@arrowto{\sseq@currarrowend}
 \presetkeys{sseqstroke}{void=false}{}
 \setkeys{sseqstroke}{#1}
 \ifKV@sseqstroke@void % ^^A a void line
   \@eval\sseq@connection{{\sseq@dashing}{\sseq@curve}{true}}
 \else
   \@eval\sseq@connection{{\sseq@dashing}{\sseq@curve}{false}}
 \fi
 \edef\sseq@currarrowstart{\sseq@arrowfrom}
 \edef\sseq@currarrowend{\sseq@arrowto}
 \edef\ssconncolor{\sseq@savecolor}
}
% }{}
%
% ^^A Keep these for compatibility
% \ifthenelse{0=1}{
\newcommand{\sscurve}[1]{\sseq@stroke[curve=#1]}
\newcommand{\ssdashedstroke}{\sseq@stroke[dashed]}
\newcommand{\ssdashedcurve}[1]{\sseq@stroke[dashed,curve=#1]}
\newcommand{\ssdottedstroke}{\sseq@stroke[dotted]}
\newcommand{\ssdottedcurve}[1]{\sseq@stroke[dotted,curve=#1}
% }{}
%
% \DescribeMacro{\ssarrowhead}
% \DescribeMacro{\ssinversearrowhead}
% Instead of specifying |arrowfrom| or |arrowto| in |ssstroke|, you can issue these commands afterwards to typeset an arrow head onto the beginning resp. end of the connection most recently typeset. There is one optional parameter |[|\meta{arrow style}|]| which selects the arrow tips of style \meta{arrow style}, cf. the documentation of |\ssstroke|.
%
% \ifthenelse{0=1}{
\newcommand{\ssarrowhead}[1][\sseq@defaultarrowstyle]{\edef\sseq@currarrowend{#1}}
\newcommand{\ssinversearrowhead}[1][\sseq@defaultarrowstyle]{\edef\sseq@currarrowstart{#1}}
% }{}
%
% \DescribeMacro{\ssline}
% A second way of producing connections is |\ssline[|\meta{options...}|]{|\meta{x}|}{|\meta{y}|}|. This command draws a connection from the most recent object (cf. |\ssname|) to an object at relative position (\meta{x},\meta{y}), and it moves that cursor to that new position. If |\ssline| is followed by a drop command, then the line is attached to this newly dropped object (note the slightly out-of-order execution!), no matter how many other objects there are at the target position. However, if it is not followed by a drop command, then there has to be one and only one object at the target position, otherwise an error message is generated. The options are exactly the same as for |\ssstroke|.
%
% \iffalse
%
\def\ssline{\@ifnextchar[\sseq@line{\sseq@line[]}}
\def\sseq@line[#1]#2#3{
 \ssprepareline{#2}{#3}
 \edef\sseqconncommand{\noexpand\ssstroke[color=\ssconncolor,#1]}
}
\newcommand{\sscurvedline}[3]{\ssline[curve=#3]{#1}{#2}}
\newcommand{\ssdashedline}[2]{\ssline[dashed]{#1}{#2}}
\newcommand{\sscurveddashedline}[3]{\ssline[curve=#3,dashed]{#1}{#2}}
% \fi
%
% \DescribeMacro{\ssarrow}
% |\ssarrow[|\meta{options...}|]{|\meta x|}{|\meta y|}| is an abbreviation for\\
% |\ssline[|\meta{options...}|,arrowto]{|\meta x|}{|\meta y|}|
%
% \ifthenelse{0=1}{
\newcommand{\ssarrow}[3][]{
  \ssline[arrowto,#1]{#2}{#3}
}
\newcommand{\sscurvedarrow}[3]{\ssline[arrowto,curve=#3]{#1}{#2}}
\newcommand{\ssdashedarrow}[2]{\ssline[arrowto,dashed]{#1}{#2}}
\newcommand{\sscurveddashedarrow}[3]{\ssline[arrowto,dashed,curve=#3]{#1}{#2}}
%
%
\def\ssvoidline#1#2{
  \ssassertsource
  \edef\sseq@resetcmd{\noexpand\sseqposx=\number\sseqposx%
					  \noexpand\sseqposy=\number\sseqposy%
					  \noexpand\def\noexpand\sseq@currentname{\sseq@currentname}
					  \noexpand\sseq@updatecurrentdata}
  \ssmove{#1}{#2}
  \ssstroke[void]
  \sseq@resetcmd
}
\newcommand{\ssvoidarrow}[2]{\ssvoidline{#1}{#2}\ssarrowhead}
\newcommand{\ssinversevoidarrow}[2]{\ssvoidline{#1}{#2}\ssinversearrowhead}

% This follows the conventions of pgf, i.e. #1, #2, #3, #4 are pgfpoints, return is a pgfpoint on the
% intersection of line #3 in direction #4 with axis-linear rectangle #1-#2.
\def\sseq@pointintersectionoflinewithrectangle#1#2#3#4{
  \pgf@process{#1}
  \pgf@xa=\pgf@x
  \pgf@ya=\pgf@y
  \pgf@process{#2}
  \pgf@xb=\pgf@x
  \pgf@yb=\pgf@y
  \pgf@process{#3}
  \pgf@xc=\pgf@x
  \pgf@yc=\pgf@y
  \pgf@process{#4}
  \dimen0=100cm % ^^A infinity
  \dimen1=100cm % ^^A infinity
% ^^A
  \ifnum\pgf@x>0pt % ^^A line goes to the right
    \dimen0=\pgf@xb
    \advance\dimen0 by -\pgf@xc
    \divide\dimen0 by \pgf@x
  \fi
  \ifnum\pgf@x<0pt % ^^A line goes to the left
    \dimen0=\pgf@xa
    \advance\dimen0 by -\pgf@xc
    \divide\dimen0 by \pgf@x
  \fi
  \ifnum\pgf@y>0pt % ^^A line goes up
    \dimen1=\pgf@yb
    \advance\dimen1 by -\pgf@yc
    \divide\dimen1 by \pgf@y
  \fi
  \ifnum\pgf@y<0pt % ^^A line goes down
    \dimen1=\pgf@ya
    \advance\dimen1 by -\pgf@xc
    \divide\dimen1 by \pgf@y
  \fi
  \ifnum\dimen1<\dimen0
    \dimen0=\dimen1
  \fi
  % ^^A now dimen0 contains the stretching factor for #4 to the right point.
  \multiply\pgf@x by \dimen0
  \multiply\pgf@y by \dimen0
  \advance\pgf@x by \pgf@xc
  \advance\pgf@y by \pgf@yc
}

%
% ^^A draw a line from the named position #1 (coord #2,#3) to relative position (#4,#5).
% ^^A clip it where appropriate.
% ^^A #6 = dashing (e.g. {{1pt}{1pt}} = dashed, {} = solid)
% ^^A #7 = bending ({} = no bend)
%

\def\sseq@lineintooff#1#2#3#4#5#6#7{
  \putxyq{\begin{pgfscope}}
  \sseqj=0
  \def\tempcmd{\range@loop{\sseq@findxrange{#2}{#3}}}
  \expandafter\tempcmd\sseq@xrange
% ^^A now \sseqxx = xmin, \sseqyy = ymin, \sseqx = xmax, \sseqy = ymax.
  \putxyq{\pgfsetdash{#6}{0pt}}
  \putxyq{\sseq@pointintersectionoflinewithrectangle}
  \putxy{{\noexpand\pgfpoint{\number \sseqxx sp}{\number \sseqyy sp}}}
  \putxy{{\noexpand\pgfpoint{\number \sseqx sp}{\number \sseqy sp}}}
  \putxyq{{\pgfpointanchor{#1}{center}}{\pgfpoint{#4 sp}{#5 sp}}}
  \putxyq{\sseqx=\pgf@x}
  \putxyq{\sseqy=\pgf@y}
  \putxyq{\pgfpathmoveto}
  \putxy{{\noexpand\pgfpointshapeborder{#1}%
                                       {\noexpand\pgfpoint{\noexpand\sseqx}{\noexpand\sseqy}}}}
    \putxyq{\pgfpathlineto}
    \putxyq{{\pgfpoint{\sseqx}{\sseqy}}}
  \def\temp{#7}
  \ifx\temp\empty
  \else
    \dimen0=#7pc
    \ifsseq@connreverse
	  \multiply\dimen0 by -1
	\fi
    \putxy{\noexpand\pgfdecorationsegmentamplitude=\number\dimen0 sp}
    \putxyq{\advance\pgfdecorationsegmentamplitude by \pgfdecorationsegmentamplitude}
    \putxyq{\pgfdecorationsegmentaspect=.3}
     \putxyq{\pgfdecoratecurrentpath{bent}}
  \fi

  \edef\sseq@connbuffer{\noexpand\sseqwritecolor{\ssconncolor}%
                        \noexpand\putxyq{\noexpand\pgfusepath{stroke}\noexpand\end{pgfscope}}}
}


\def\sseq@findxrange#1#2#3#4{
  \ifnum#1<#3\else
    \ifnum#1>#4\else
	  % ^^A found the correct range
	  \sseqj=0
	  \def\tempcmd{\range@loop{\sseq@findyrange{#1}{#2}{#3}{#4}}}
	  \expandafter\tempcmd\sseq@yrange
	  \rangebreaktrue
	\fi
  \fi
}
\def\sseq@findyrange#1#2#3#4#5#6{
  \ifnum#2<#5\else
    \ifnum#2>#6\else
	  % ^^A found the correct range -- do the drawing
	  \ss@getcoords{#3}{#5} % ^^A lower left corner in \sseqx,\sseqy
	  \advance\sseqx by -\sseq@xleak
	  \advance\sseqy by -\sseq@yleak
	  \sseqxx=\sseqx
	  \sseqyy=\sseqy
	  \ss@getcoords{#4}{#6} % ^^A upper right corner in \sseqx,\sseqy
	  \advance\sseqx by \sseq@xleak
	  \advance\sseqx by \sseqentrysize
	  \advance\sseqy by \sseq@yleak
	  \advance\sseqy by \sseqentrysize
	  \rangebreaktrue
	\fi
  \fi
}

% }{}
%
% \DescribeMacro{\ssbullstring}
% |\ssbullstring{x}{y}{n}| is a shortcut for |\ssdrop{\bullet}| followed by $n-1$ copies of |\ssline{x}{y} \ssdrop{\bullet}|.
% \iffalse
\newcommand{\ssbullstring}[3]{
\ifnum#3>0
 \ifnum#3=1
  \ssdropbull
 \else
  \ssdropbull
  \ssline{#1}{#2}
  \count0=#3
  \advance\count0 by -1
  \edef\sseqbullcnt{\the\count0}
  \ssbullstring{#1}{#2}{\sseqbullcnt}
\fi\fi
}
% \fi
%
% \DescribeMacro{\ssinfbullstring}
% |\ssinfbullstring{x}{y}{n}| is a shortcut for |\ssdrop{\bullet}| followed by $n-1$ copies of |\ssline{x}{y} \ssdrop{\bullet}|, followed by |\ssarrow[void]{x}{y}|. The cursor finishes on the last bullet.
%
% \iffalse
\newcommand{\ssinfbullstring}[3]{
\ssbullstring{#1}{#2}{#3}
\ssvoidarrow{#1}{#2}
}
% \fi
%
% \section{Examples}
%
%
% \newtheorem{ex}{Example}
%
%\begin{ex}
%The following code generates a $5 \times 5$ grid with labels between $-2$ and $2$. The size of every square is $(.8cm)^2$, and labels are written on every square. The grid is chess-style. A bullet is drawn at coordinate (0,0).
%
%\noindent
%\begin{minipage}{\textwidth/2}
%\begin{verbatim}
%\begin{sseq}[grid=chess,labelstep=1,
%  entrysize=.8cm]{-2...2}{-2...2}
%\ssdropbull
%\end{sseq}
%\end{verbatim}
%\end{minipage}
%\begin{minipage}{\textwidth/2}
%\def\sseqgridstyle{\ssgridchess}
%\begin{sseq}[grid=chess,labelstep=1,entrysize=.8cm]{-2...2}{-2...2}
%\ssdropbull
%\end{sseq}
%\end{minipage}
%\end{ex}
%
%
%\begin{ex}
%This example demonstrates how to move the cursor and drop objects and labels. Note how the last bullet, which is dropped at position (8,4), is outside the grid and thus clipped. The grid style is the default (|crossword|). \bigskip
%
%\noindent
%\begin{minipage}{\textwidth/2}
%\begin{verbatim}
%\begin{sseq}{0...6}{0...6}
%\ssdropbull
%\ssdroplabel{(0,0)}
%\ssmove 2 1
%\ssdrop{\clubsuit}
%\ssdropextension
%\ssdropextension
%\ssdropextension
%\ssdroplabel[RU]{(2,1)}
%\ssmove 0 4
%\ssdropcircled{8}
%\ssmoveto 5 4
%\ssdropboxed{\spadesuit}
%\ssdroplabel[R]{(5,4)}
%\ssmove 3 0
%\ssdropbull
%\end{sseq}
%\end{verbatim}
%\end{minipage}
%\begin{minipage}{\textwidth/2}
%\begin{sseq}{0...6}{0...6}
%\ssdropbull
%\ssdroplabel{(0,0)}
%\ssmove 2 1
%\ssdrop{\clubsuit}
%\ssdropextension
%\ssdropextension
%\ssdropextension
%\ssdroplabel[RU]{(2,1)}
%\ssmove 0 4
%\ssdropcircled{8}
%\ssmoveto 5 4
%\ssdropboxed{\spadesuit}
%\ssdroplabel[R]{(5,4)}
%\ssmove 3 0
%\ssdropbull
%\end{sseq}
%\end{minipage}
%\end{ex}
% 
%\begin{ex}
%This example illustrates the different ways of drawing connections. 
%\bigskip
%
%\noindent
%\begin{minipage}{\textwidth/2}
%\begin{verbatim}
%\begin{sseq}[grid=go]{0...9}{0...6}
%\ssdropbull
%\ssmove 4 4
%\ssdropbull \ssstroke
%\sscurve{-.5}
%\ssdashedcurve{.1} \ssarrowhead
%\ssmove 4 0 \ssdropcircled{T}
%\ssstroke
%\ssmoveto 0 6
%\ssdropbull 
%\ssline {1} {-1}
%\sscurvedline 7 {-1} {.2}
%\ssdropbull 
%\end{sseq}
%\end{verbatim}
%\end{minipage}
%\begin{minipage}{\textwidth/2}
%\begin{sseq}[grid=go]{0...9}{0...6}
%\ssdropbull
%\ssmove 4 4
%\ssdropbull \ssstroke
%\sscurve{-.5}
%\ssdashedcurve{.1} \ssarrowhead
%\ssmove 4 0 \ssdropcircled{T}\ssstroke
%\ssmoveto 0 6
%\ssdropbull 
%\ssline {1} {-1}
%\ssdropbull
%\sscurvedline 7 {-1} {.2}
%\end{sseq}
%\end{minipage}
%\end{ex}
%
%\begin{ex}
%This sample code shows how to use names for objects dropped in spectral sequence; this is particularly useful when more than one item is dropped at one position. It also demonstrates void arrows, which do not need a target.
%\bigskip
%
%\noindent
%\begin{minipage}{\textwidth*2/3}
%\begin{verbatim}
%\begin{sseq}[grid=dots]{0...4}{0...4}
%\ssdropbull \ssname{a} \ssvoidarrow 0 1
%\ssdropbull \ssname{b} \ssvoidarrow 0 1
%\ssdropbull \ssname{c} \ssvoidarrow 0 1
%\ssdropextension \ssname{d}
%\ssmove 4 4
%\ssdropbull \ssname{e}
%\ssdropbull \ssname{f}
%\ssgoto a \ssgoto f \ssstroke
%\ssgoto e \ssstroke
%\ssgoto d \sscurve{.2}
%\ssline 4 0 \ssdropbull
%\end{sseq}
%\end{verbatim}
%\end{minipage}
%\begin{minipage}{\textwidth/3}
%
%\begin{sseq}[grid=dots]{0...4}{0...4}
%\ssdropbull \ssname{a}\ssvoidarrow 0 1
%\ssdropbull \ssname{b}\ssvoidarrow 0 1
%\ssdropbull \ssname{c}\ssvoidarrow 0 1
%\ssdropextension \ssname{d}
%\ssmove 4 4
%\ssdropbull \ssname{e}
%\ssdropbull \ssname{f}
%\ssgoto a \ssgoto f \ssstroke
%\ssgoto e \ssstroke
%\ssgoto d \sscurve{.2}
%\ssline 4 0 \ssdropbull
%\end{sseq}
%\end{minipage}
%\end{ex}
%
%\begin{ex}
% This final example shows how to take advantage of loops and prefices.
%
%\noindent
%\begin{minipage}[t]{\textwidth*1/3}
%\begin{verbatim}
%\newcount\cnti
%\def\drawstring#1#2{
% \ifnum#2=1
%  \ssdropbull \ssname{#1}
% \else
%  \ssdropbull \ssname{#1}
%  \ssline 1 0
%  \ssprefix{i}
%  \cnti=#2
%  \advance \cnti by -1
%  \drawstring{#1}
%   {\the\cnti}
% \fi
%}
%\end{verbatim}
%\end{minipage}
%\begin{minipage}[t]{\textwidth*1/3}
%\begin{verbatim}
%\def\drawlines#1#2#3{
% \ifnum#3>0
%  \cnti=#3
%  \ssgoto{#1} \ssgoto{#2}
%  \ssstroke \ssarrowhead
%  \ssprefix{i}
%  \advance \cnti by -1
%  \drawlines{#1}{#2}
%   {\the\cnti}
% \fi
%}
%\end{verbatim}
%\end{minipage}
%\begin{minipage}[t]{\textwidth*1/3}
%\begin{verbatim}
%\begin{sseq}[grid=none]
%    {0...8}{0...3}
%\ssmoveto 0 3
%\drawstring{a}{8}
%\ssmoveto 0 3
%\ssresetprefix
%\drawstring{b}{8}
%\ssmoveto 0 0
%\ssresetprefix
%\drawstring{c}{8}
%\ssresetprefix
%\drawlines{c}{a}{8}
%\ssresetprefix
%\drawlines{b}{iic}{6}
%\end{sseq}
%\end{verbatim}
%\end{minipage}
%
% \bigskip
%
% The result is shown in the following chart:
%\newcount\cnti
%\def\drawstring#1#2{
% \ifnum#2=1
%  \ssdropbull \ssname{#1}
% \else
%  \ssdropbull \ssname{#1}
%  \ssline 1 0
%  \ssprefix{i}
%  \cnti=#2
%  \advance \cnti by -1
%  \drawstring{#1}
%   {\the\cnti}
% \fi
%}
%\def\drawlines#1#2#3{
% \ifnum#3>0
%  \cnti=#3
%  \ssgoto{#1} \ssgoto{#2}
%  \ssstroke \ssarrowhead
%  \ssprefix{i}
%  \advance \cnti by -1
%  \drawlines{#1}{#2}
%   {\the\cnti}
% \fi
%}
%\begin{tabular}{l}
%\begin{sseq}[grid=none]{0...8}{0...3}
%\ssmoveto 0 3
%\drawstring{a}{8}
%\ssmoveto 0 3
%\ssresetprefix
%\drawstring{b}{8}
%\ssmoveto 0 0
%\ssresetprefix
%\drawstring{c}{8}
%\ssresetprefix
%\drawlines{c}{a}{8}
%\ssresetprefix
%\drawlines{b}{iic}{6}
%\end{sseq}
%\end{tabular}
%\end{ex}
%
%\section{Final remarks}
%
% This package has been extremely helpful for my own mathematical work, and it most likely carries the characteristics of a tool initially developed for my own purposes only. Before this published version, there was an earlier version of |sseq| which was much less powerful; and what is worse, this version is not fully upward compatible with the previous one. (Every object that was dropped was forgotten right afterwards; thus connections could not properly connect objects but were always drawn from the center of the box corresponding to a coordinate to the center of the box corresponding to the target coordinate, resulting in fairly ugly pictures.)
%
% Many things remain to be desired:
%
% \begin{itemize}
% \item |sseq| seems to be too voracious in memory
% \item While object are placed next to each other, no attempt is made not to make connections overlap
% \item A ``grayout'' option that automatically turns the source and target of any arrow into a different color would be highly useful for spectral sequence charts
% \end{itemize}
%
% Given time and leisure, I might or might not implement one or more of these improvements and make them available; of course, I would be even more happy if somebody else did it. (Needless to say, I would request that I be informed of and sent the enhancements.) I do guarantee that all further versions of |sseq| that might or might not be written by me will be compatible with the documented code written for this version.
%
% \endinput
%
%
\def\ssgridcrossword#1#2{
 \pgfsetlinewidth{\the\sseq@gridstrokethickness}
 \pgfpathgrid[stepx=\the\sseqentrysize,stepy=\the\sseqentrysize]{\pgfpointorigin}{\pgfpoint{#1*\sseqentrysize}{#2*\sseqentrysize}}
 \pgfusepath{stroke}
}

\def\ssgridgo#1#2{
 \pgfsetlinewidth{\the\sseq@gridstrokethickness}
 \pgftransformxshift{\the\sseqhalfentry}
 \pgftransformyshift{\the\sseqhalfentry}
 \pgfpathgrid[stepx=\the\sseqentrysize,stepy=\the\sseqentrysize]{\pgfpoint{-\the\sseqhalfentry}{-\the\sseqhalfentry}}{\pgfpoint{#1*\sseqentrysize-\sseqhalfentry}{#2*\sseqentrysize-\sseqhalfentry}}
 \pgfusepath{stroke}
}

\def\ssgridnone#1#2{}

\def\ssgriddots#1#2{
 \pgfsetlinewidth{1pt}
 \pgfsetdash{{1pt}{\the\sseqentrysize-1pt}}{\the\sseqhalfentry+.5pt}
 \pgftransformxshift{\the\sseqhalfentry}
 \pgftransformyshift{\the\sseqhalfentry}
 \pgfpathgrid[stepx=\the\sseqentrysize,stepy=\the\sseqentrysize]{\pgfpoint{-\the\sseqhalfentry}{-\the\sseqhalfentry}}{\pgfpoint{#1*\sseqentrysize-\sseqhalfentry}{#2*\sseqentrysize-\sseqhalfentry}}
 \pgfusepath{stroke}
}

\def\ssgridchess#1#2{
 \pgfsetlinewidth{\the\sseqentrysize}
 \pgfsetdash{{\the\sseqentrysize}{\the\sseqentrysize}}{\the\sseqentrysize}
 \pgfsetcolor{sslightgr}
 \pgftransformxshift{\the\sseqhalfentry}
 \pgftransformyshift{\the\sseqhalfentry}
 \pgfpathgrid[stepx=\the\sseqentrysize*2,stepy=\the\sseqentrysize*2]{\pgfpoint{-\the\sseqhalfentry}{-\the\sseqhalfentry}}{\pgfpoint{#1*\sseqentrysize-\sseqhalfentry}{#2*\sseqentrysize-\sseqhalfentry}}
 \pgfusepath{stroke}
}

\def\sseq@drawgrid{
 \expandafter\ifx\sseqgridstyle\ssequndefined
  \PackageError{sseq}{Unknown grid option, reverting to \string\ssgridnone}{You apparently have redefined \string\sseqgridstyle. The only allowed values are: \string\ssgridnone,\string\ssgriddots,\string\ssgridgo,\string\ssgridcrossword,\string\ssgridchess.}
  \gdef\sseqgridstyle{\ssgridnone}
 \fi
 \sseqj=0
 \def\tempcmd{\range@loop{\sseq@innergridloop}}
 \expandafter\tempcmd\sseq@xrange
}
% ^^A The following is called for every part #1...#2
%
\def\sseq@innergridloop#1#2{
  \sseqj=0
  \def\tempcmd{\range@loop{\sseq@gridwrapper{#1}{#2}}}
  \expandafter\tempcmd\sseq@yrange
}
\def\sseq@gridwrapper#1#2#3#4{
 \begin{pgfscope}
 \ss@getcoords{#1}{#3}
 \sseqxx=\sseqx
 \sseqyy=\sseqy
 \count0=#2\advance\count0 by 1
 \count1=#4\advance\count1 by 1
 \pgftransformshift{\pgfpoint{\the\sseqxx}{\the\sseqyy}}
 \count2=#1
 \multiply\count2 by -1
 \advance\count0 by \count2
 \count2=#3
 \multiply\count2 by -1
 \advance\count1 by \count2
 \@eval\sseqgridstyle{{\number\count0}{\number\count1}}
 \end{pgfscope}
}
%
% ^^A \sseq@drawlabels
%
\def\sseq@drawlabels{
  \sseqj=0
  \def\tempcmd{\range@loop{\sseqk=-\sseqxstep \sseq@drawhorizontallabels}}
  \expandafter\tempcmd\sseq@xrange
  \sseqj=0
  \def\tempcmd{\range@loop{\sseqk=-\sseqystep \sseq@drawverticallabels}}
  \expandafter\tempcmd\sseq@yrange
}
%

\def\sseq@drawhorizontallabels#1#2{
 \advance\sseqk by \sseqxstep
 \sseqi=#1
 \ifnum\sseqi>#2\else
   \ss@getcoords{\the\sseqi}{0}
   \advance\sseqx by \sseqhalfentry
   \sseqxlabel
   \sbox\sseq@labelbox{\strut\ensuremath{\sseq@answer}}
   \dimen0 = \ht\sseq@labelbox
   \advance\dimen0 by \dp\sseq@labelbox
   \pgf@protocolsizes{0pt}{-\dimen0} % ^^A fixes a bug with bounding boxes in pgf
   \pgftext[top,at=\pgfpoint{\the\sseqx}{0pt}]{\usebox{\sseq@labelbox}} 
   \advance\sseqi by \sseqxstep
   \edef\tempcmd{\noexpand\sseq@drawhorizontallabels{\number\sseqi}{#2}}
   \expandafter\tempcmd
 \fi
}
%
\def\sseq@drawverticallabels#1#2{
 \advance\sseqk by \sseqystep
 \sseqi=#1
 \ifnum\sseqi>#2\else
   \ss@getcoords{0}{\the\sseqi}
   \advance\sseqy by \sseqhalfentry
   \sseqylabel
   \pgftext[right,at=\pgfpoint{-2pt}{\the\sseqy}]{\ensuremath{\sseq@answer}}
   \advance\sseqi by \sseqystep
   \edef\tempcmd{\noexpand\sseq@drawverticallabels{\number\sseqi}{#2}}
   \expandafter\tempcmd
 \fi
}
%
% ^^A #1 = number of outer part
% ^^A #2 = number of inner part
%
%
\def\sseq@labelfromlist#1#2#3,{
 \def\temp{#3}
 \def\tempcmd{}
 \ifx\temp\range@endmarker
   \def\sseq@answer{?}
 \else
   \count0=#1
   \ifnum\count0=0
     \def\sseq@lastlabel{}
     \def\tempcmd{\sseq@innerlabelfromlist{#2}#3;END;}
   \else
     \advance\count0 by -1
     \edef\tempcmd{\noexpand\sseq@labelfromlist{\number\count0}{#2}}
   \fi
 \fi
 \tempcmd
}

\def\sseq@innerlabelfromlist#1#2;{
 \def\temp{#2}
 \def\tempcmd{}
 \ifx\temp\range@endmarker
   \ifx\sseq@lastlabel\empty
     \def\sseq@answer{?}
   \else
     \count0=#1
     \ifnum\count0=0
       \def\sseq@answer{\ensuremath{\sseq@lastlabel}}
       \def\tempcmd{\range@gobbletoend}
     \else
       \advance\count0 by -1
       \edef\tempcmd{\noexpand\sseq@innerlabelfromlist{\number\count0}END;}
     \fi
   \fi
 \else
   \def\sseq@lastlabel{#2}
   \count0=#1
   \ifnum\count0=0
     \def\sseq@answer{\ensuremath{#2}}
     \def\tempcmd{\range@gobbletoend}
   \else
     \advance\count0 by -1
     \edef\tempcmd{\noexpand\sseq@innerlabelfromlist{\number\count0}}
   \fi
 \fi
 \tempcmd 
}
%
% ^^A options that can be passed to sseq
%
\define@key{sseq}{grid}{
\expandafter\def\expandafter\sseqgridstyle\expandafter{\csname ssgrid#1\endcsname}
}
%
\define@key{sseq}{entrysize}{
\sseqentrysize=#1
}
\define@key{sseq}{labels}{
  \setkeys{sseq}{xlabels=#1,ylabels=#1}
}
\define@key{sseq}{xlabels}{
  \def\temp{#1}
  \def\temptwo{none}
  \ifx\temp\temptwo
    \def\sseqxlabel{\def\sseq@answer{}}
  \else
    \def\temptwo{numbers}
    \ifx\temp\temptwo
      \def\sseqxlabel{\def\sseq@answer{\the\sseqi}}
	\else
	  \def\sseqxlabel{%
	    \@eval\sseq@labelfromlist{{\number\sseqj}{\number\sseqk}}#1,END,%
	  }
    \fi
  \fi
}
\define@key{sseq}{ylabels}{
  \def\temp{#1}
  \def\temptwo{none}
  \ifx\temp\temptwo
    \def\sseqylabel{\def\sseq@answer{}}
  \else
    \def\temptwo{numbers}
    \ifx\temp\temptwo
      \def\sseqylabel{\def\sseq@answer{\the\sseqi}}
	\else
	  \def\sseqylabel{%
	    \@eval\sseq@labelfromlist{{\number\sseqj}{\number\sseqk}}#1,END,%
	  }
	\fi
  \fi
}
\define@key{sseq}{xlabelstep}{\sseqxstep=#1}
\define@key{sseq}{ylabelstep}{\sseqystep=#1}
\define@key{sseq}{labelstep}{\setkeys{sseq}{xlabelstep=#1}\setkeys{sseq}{ylabelstep=#1}}

\define@key{sseq}{gapsize}{\setkeys{sseq}{xgapsize=#1}\setkeys{sseq}{ygapsize=#1}}
\define@key{sseq}{xgapsize}{\sseq@xgap=#1}
\define@key{sseq}{ygapsize}{\sseq@ygap=#1}
\define@key{sseq}{leak}{\setkeys{sseq}{xleak=#1}\setkeys{sseq}{yleak=#1}}
\define@key{sseq}{xleak}{\sseq@xleak=#1}
\define@key{sseq}{yleak}{\sseq@yleak=#1}
\define@key{sseq}{gridstroke}{\sseq@gridstrokethickness=#1}
\define@key{sseq}{arrows}{\def\sseq@defaultarrowstyle{#1}}
%
% ^^A Defaults
%
\sseqentrysize=0.4cm
\sseq@xgap=0.3cm
\sseq@ygap=0.3cm
\global\sseq@xleak=-100mm
\global\sseq@yleak=-100mm
\sseqxstep=2
\sseqystep=2
\def\sseqgridstyle{\ssgridcrossword}
\def\sseq@defaultarrowstyle{to}

\newenvironment{sseq}[3][]{%
\begingroup
%
% ^^A Start the PGF environment
\begin{pgfpicture}
%
% ^^A Initialize some local counters and dimensions
%
\countdef\sseqi=152%
\countdef\sseqj=153%
\countdef\sseqxdir=154%
\countdef\sseqposx=155%
\countdef\sseqposy=156%
\countdef\sseqydir=157%
\countdef\sseqk=158%
\dimendef\sseqhalfentry=205%
\dimendef\sseqx=206%
\dimendef\sseqy=207%
\dimendef\sseqxx=208%
\dimendef\sseqyy=209%
\dimendef\sseqabsposx=210%
\dimendef\sseqabsposy=211%
\sseq@gridstrokethickness=.1pt%
%\ifnum\sseqxstep<0 \sseqxdir=-1 \else \sseqxdir=1 \fi
%\ifnum\sseqystep<0 \sseqydir=-1 \else \sseqydir=1 \fi
%
% Backup count0 - count9 (these are page numbers!)
%
\edef\sseqsavecnto{\number\count0}%
\edef\sseqsavecnti{\number\count1}%
\edef\sseqsavecntii{\number\count2}%
\edef\sseqsavecntiii{\number\count3}%
\edef\sseqsavecntiv{\number\count4}%
\edef\sseqsavecntv{\number\count5}%
\edef\sseqsavecntvi{\number\count6}%
\edef\sseqsavecntvii{\number\count7}%
\edef\sseqsavecntviii{\number\count8}%
\edef\sseqsavecntix{\number\count9}%
%
% ^^A Parse arguments
%
%
\setkeys{sseq}{#1}
%
\ifnum\sseqxstep=0 % ^^A old-fashioned way of disabling labels
  \setkeys{sseq}{xlabels=none}
  \sseqxstep=1
\else
  \@ifundefined{sseqxlabel}{\setkeys{sseq}{xlabels=numbers}}{}
\fi
\ifnum\sseqystep=0 % ^^A old-fashioned way of disabling labels
  \setkeys{sseq}{ylabels=none}%
  \sseqystep=1
\else
  \@ifundefined{sseqylabel}{\setkeys{sseq}{ylabels=numbers}}{}
\fi
\ifdim\sseq@xleak=-100mm
  \sseq@xleak=0.3\sseq@xgap
\fi
\ifdim\sseq@yleak=-100mm
  \sseq@yleak=0.3\sseq@ygap
\fi
%
%
%
\range@parseandnormalize{\sseq@xrange}{\sseqxstart}{#2}
\range@parseandnormalize{\sseq@yrange}{\sseqystart}{#3}
%
% ^^A Some setup
\pgfsetshapeminwidth{1.1mm}
\pgfsetshapeinnerxsep{1pt}
\pgfsetshapeinnerysep{1pt}
%
\sseqhalfentry=\sseqentrysize
\divide\sseqhalfentry by 2
%
\sseq@drawgrid
\sseq@drawlabels
%
% ^^A Move to turtle to (0,0)
\sseqposx=0
\sseqposy=0
%\sseq@updatecurrentdata
}
%
%
% ^^A PART FOR \end{sseq}
%
{
\relax
\ssmoveto 0 0 \ssmoveto 0 0
\edef\lst{\the\sseqcmdlist}
\ifthenelse{\boolean{debug}}{\show\lst}{}
\the\sseqcmdlist
%
% ^^A Restore count0-count9 in case we're in the middle of a page break.
%
\count0=\sseqsavecnto
\count1=\sseqsavecnti
\count2=\sseqsavecntii
\count3=\sseqsavecntiii
\count4=\sseqsavecntiv
\count5=\sseqsavecntv
\count6=\sseqsavecntvi
\count7=\sseqsavecntvii
\count8=\sseqsavecntviii
\count9=\sseqsavecntix
\end{pgfpicture}
\endgroup
}
%
% \Finale
