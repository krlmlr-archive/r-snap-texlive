% \CheckSum{1577}
% \iffalse^^A meta-comment
% ======================================================================
% scrlayer-notecolumn.dtx
% Copyright (c) Markus Kohm, 2013
%
% This file is part of the LaTeX2e KOMA-Script bundle.
%
% This work may be distributed and/or modified under the conditions of
% the LaTeX Project Public License, version 1.3c of the license.
% The latest version of this license is in
%   http://www.latex-project.org/lppl.txt
% and version 1.3c or later is part of all distributions of LaTeX
% version 2005/12/01 and of this work.
%
% This work has the LPPL maintenance status "author-maintained".
%
% The Current Maintainer and author of this work is Markus Kohm.
%
% This work consists of all files listed in manifest.txt.
% ----------------------------------------------------------------------
% scrlayer-notecolumn.dtx
% Copyright (c) Markus Kohm, 2013
%
% Diese Datei ist Teil der LaTeX2e KOMA-Script-Sammlung.
%
% Dieses Werk darf nach den Bedingungen der LaTeX Project Public Lizenz,
% Version 1.3c.
% Die neuste Version dieser Lizenz ist
%   http://www.latex-project.org/lppl.txt
% und Version 1.3c ist Teil aller Verteilungen von LaTeX
% Version 2005/12/01 und dieses Werks.
%
% Dieses Werk hat den LPPL-Verwaltungs-Status "author-maintained"
% (allein durch den Autor verwaltet).
%
% Der Aktuelle Verwalter und Autor dieses Werkes ist Markus Kohm.
%
% Dieses Werk besteht aus den in manifest.txt aufgefuehrten Dateien.
% ======================================================================
% \fi^^A meta-comment
%
% \CharacterTable
%  {Upper-case    \A\B\C\D\E\F\G\H\I\J\K\L\M\N\O\P\Q\R\S\T\U\V\W\X\Y\Z
%   Lower-case    \a\b\c\d\e\f\g\h\i\j\k\l\m\n\o\p\q\r\s\t\u\v\w\x\y\z
%   Digits        \0\1\2\3\4\5\6\7\8\9
%   Exclamation   \!     Double quote  \"     Hash (number) \#
%   Dollar        \$     Percent       \%     Ampersand     \&
%   Acute accent  \'     Left paren    \(     Right paren   \)
%   Asterisk      \*     Plus          \+     Comma         \,
%   Minus         \-     Point         \.     Solidus       \/
%   Colon         \:     Semicolon     \;     Less than     \<
%   Equals        \=     Greater than  \>     Question mark \?
%   Commercial at \@     Left bracket  \[     Backslash     \\
%   Right bracket \]     Circumflex    \^     Underscore    \_
%   Grave accent  \`     Left brace    \{     Vertical bar  \|
%   Right brace   \}     Tilde         \~}
%
% \iffalse^^A meta-comment
%<identify>%%% From File: $Id: scrlayer-notecolumn.dtx 1514 2013-11-15 08:23:09Z mjk $ (identify)
%<init>%%% From File: $Id: scrlayer-notecolumn.dtx 1514 2013-11-15 08:23:09Z mjk $ (init)
%<options>%%% From File: $Id: scrlayer-notecolumn.dtx 1514 2013-11-15 08:23:09Z mjk $ (options)
%<body>%%% From File: $Id: scrlayer-notecolumn.dtx 1514 2013-11-15 08:23:09Z mjk $ (body)
%<*dtx>
\ifx\ProvidesFile\undefined\def\ProvidesFile#1[#2]{}\fi
\begingroup
  \def\filedate$#1: #2-#3-#4 #5${\gdef\filedate{#4/#3/#2}}
  \filedate$Date: 2013-11-15 09:23:09 +0100 (Fr, 15. Nov 2013) $
  \def\filerevision$#1: #2 ${\gdef\filerevision{v0.1.#2}}
  \filerevision$Revision: 1514 $
\endgroup
\ProvidesFile{scrlayer-notecolumn.dtx}[\filedate\space\filerevision\space
%</dtx>
%<*identify|doc>
%<interface>\NeedsTeXFormat{LaTeX2e}[1995/12/01]
%<interface>\ProvidesPackage{scrlayer-notecolumn}[%
%<doc>\ProvidesFile{scrlayer-notecolumn.tex}[%
% Sometimes following will be replaced by !KOMASCRIPTVERSION:
%!SCRLAYERVERSION
%<interface>  package
%</identify|doc>
%<*dtx|identify|doc>
  (end user interface for scrlayer)]
%</dtx|identify|doc>
%<*dtx>
\ifx\documentclass\undefined
  \input scrdocstrip.tex
  \@@input scrkernel-version.dtx
  \@@input scrstrip.inc
% Some time we will need:
%  \KOMAdefVariable{COPYRIGHTFROM}{2013}
  \KOMAdefVariable{SCRLAYERVERSION}{\space\space\filedate\space\filerevision}%
  \expandafter\let\csname ifbetawas\expandafter\endcsname
  \csname ifbeta\endcsname
  \expandafter\let\csname ifbeta\expandafter\endcsname
  \csname iftrue\endcsname
  \generate{\usepreamble\defaultpreamble
    \file{scrlayer-notecolumn.sty}{%
      \from{scrlayer-notecolumn.dtx}{interface,trace,notecolumn,identify}%
      \from{scrlayer.dtx}{interface,trace,notecolumn,init}%
      \from{scrlayer-notecolumn.dtx}{interface,trace,notecolumn,init}%
      \from{scrlayer.dtx}{interface,trace,notecolumn,options}%
      \from{scrlayer-notecolumn.dtx}{interface,trace,notecolumn,options}%
      \from{scrlayer.dtx}{interface,trace,notecolumn,body}%
      \from{scrlayer-notecolumn.dtx}{interface,trace,notecolumn,body}%
      \from{scrlayer-notecolumn.dtx}{interface,trace,notecolumn,final}%
      \from{scrlogo.dtx}{logo}%
    }%
    \file{scrlayer-notecolumn.tex}{%
      \from{scrlayer-notecolumn.dtx}{doc}%
    }%
  }
  \expandafter\let\csname ifbeta\expandafter\endcsname
  \csname ifbetawas\endcsname
  \@@input scrstrop.inc
\else
  \let\endbatchfile\relax
\fi
\endbatchfile
%</dtx>
%<*driver>
  \documentclass{scrdoc}
  \addtolength{\textwidth}{-1em}
  \addtolength{\marginparwidth}{2em}
  \addtolength{\oddsidemargin}{2em}
  \usepackage[ngerman,english]{babel}
  \usepackage{url,babelbib}\bibliographystyle{babalpha-fl}
  \usepackage{listings}
  \usepackage{scrhack}
  \usepackage{etoolbox}
  \pretocmd\DescribeMacro{\ifhmode\else\bigskip\noindent\fi}{}{}
  \pretocmd\DescribeEnv{\ifhmode\else\bigskip\noindent\fi}{}{}
  \pretocmd\DescribeOption{\ifhmode\else\bigskip\noindent\fi}{}{}

  \CodelineIndex
  \RecordChanges
  \GetFileInfo{scrlayer-notecolumn.dtx}
  \title{The \texttt{scrlayer} interface \texttt{scrlayer-notecolumn}%
    \footnote{This is version \fileversion\ of file \texttt{\filename}.}}
  \date{\filedate}
  \author{Markus Kohm}

  \newenvironment{Explain}{\par}{\par}
  \newcommand*{\length}{}
  \let\length\Length
  \let\endlength\endLength
  \let\Macro\cs
  \let\Length\Macro
  \let\Package\textsf
  \let\Class\Package
  \let\File\texttt
  \let\Option\texttt
  \newcommand*{\KOption}[1]{\Option{#1}\texttt{=}}
  \newcommand*{\OptionValue}[2]{\Option{#1}\texttt{=}\PValue{#2}}
  \let\Counter\texttt
  \let\Environment\texttt
  \let\ShowOutput\quote
  \let\endShowOutput\endquote
  \let\Pagestyle\texttt
  \newcommand*{\Parameter}[1]{\texttt{\marg{#1}}\linebreak[1]}
  \newcommand*{\OParameter}[1]{\texttt{\oarg{#1}}\linebreak[1]}
  \newcommand*{\MParameter}[2]{\texttt{(\meta{#1},\meta{#2})}\linebreak[1]}
  \providecommand\PParameter[1]{\mbox{\texttt{\{#1\}}}\linebreak[1]}
  \let\PName\meta
  \let\PValue\texttt
  \providecommand*{\autoref}[1]{\expandafter\AUTOREF#1:}
  \providecommand*{\AUTOREF}{}
  \makeatletter
  \def\AUTOREF#1:#2:{%
    \edef\@tempa{#1}%
    \edef\@tempb{tab}\ifx\@tempa\@tempb table~\fi
    \edef\@tempb{sec}\ifx\@tempa\@tempb section~\fi
    \ref{#1:#2}%
  }
  \providecommand*{\IndexCmd}[2][]{}
  \providecommand*{\textnote}[2][]{}
  \providecommand*\eTeX{\leavevmode\hbox{$\varepsilon$}-\TeX}
  \providecommand*\NTS{%
    \leavevmode\hbox{$\cal N\kern-0.35em\lower0.5ex\hbox{$\cal T$}%
      \kern-0.2emS$}}

  \lstnewenvironment{lstcode}{\lstset{language=[LaTeX]TeX}}{}
  \makeatother
  \sloppy% YOU SHOULD NOT DO THIS!!!

  \begin{document}
  \maketitle
  \tableofcontents
  \DocInput{\filename}
  \PrintChanges
  \PrintIndex
  \end{document}
%</driver>
% \fi^^A meta-comment
%
% \selectlanguage{english}
%
% \changes{v0.0}{2013/04/26}{start of interface}
% \let\restorechapter\chapter
% \let\chapter\section
% \let\section\subsection
% \let\subsection\subsubsection
% \iffalse
%<*dtx|doc>
% \fi

\chapter[{End User Interface \Package{scrlayer-notecolumn}}]{End User
  Interface \Package{scrlayer-notecolumn}\footnote{This is not a translation
  of the corresponding chapter of the German \KOMAScript{} manual but the
  tentative and primary implementation manual of package
  \Package{scrlayer-notecolumn}. As long as \Package{scrlayer-notecolumn} is
  primary a proof of concept this doesn't matter. But nevertheless, a
  German to English translator would still be welcome.}}
\label{sec:scrlayer.notecolumn}
%\iffalse
\labelbase{scrlayer-notecolumn}
%\fi

Sometimes documents need an additional notes column beside the main text
column and maybe beside the marginal note column. Problematicly may be
having page breaks inside the notes column. This package provides a
solution based on the layer interface of \Package{scrlayer}. You may
define several notes columns, each of them with page breaks
inside. It supports automatic page break inside of notes and recognises
note collisions and solve them by moving notes.

The idea of this package raised while an e-mail contact with Heiner
Richter from FH~Stralsund, who told me of a book project, and asked
whether or not such a functionality may be added to another package of
mine easily. It couldn't, but design and implementation of a first test
alpha of \Package{scrlayer-notecolumn} has been done in about three
hours. So maybe it was a really good idea to ask me the question.

%\iffalse^^A meta-comment
\begin{Declaration}
%\fi^^A meta-comment
% \DescribeMacro{\DeclareNoteColumn}
% \DescribeMacro{\DeclareNewNoteColumn}
% \DescribeMacro{\ProvideNoteColumn}
% \DescribeMacro{\RedeclareNoteColumn}
% The command
  \Macro{DeclareNoteColumn}%
  \OParameter{option list}\Parameter{note column name}%
%\iffalse^^A meta-comment
  \\
  \Macro{DeclareNewNoteColumn}%
  \OParameter{option list}\Parameter{note column name}\\%^^A
  \Macro{ProvideNoteColumn}%
  \OParameter{option list}\Parameter{note column name}\\%^^A
  \Macro{RedeclareNoteColumn}%
  \OParameter{option list}\Parameter{note column name}%
\end{Declaration}
\BeginIndex{Cmd}{DeclareNoteColumn}%
\BeginIndex{Cmd}{DeclareNewNoteColumn}%
\BeginIndex{Cmd}{ProvideNoteColumn}%
\BeginIndex{Cmd}{RedeclareNoteColumn}%
Command \Macro{DeclareNoteColumn}
%\fi^^A meta-comment
may be used to declare a note column. Each note column is referenced by its
name, defined by the obligatory argument \PName{note column name}. A note
column vertically span the text area. 

By default its horizontal position is the current position of the marginal
note column. It also regards \Macro{reversemarginpar} and
\Macro{normalmarginpar}, while output of a note. Note that this is not the
same like making a margin note. The default width is
\Length{marginparwidth}. But you may use the optional argument \PName{option
  list} to change this behaviour.

The \PName{option list} is a comma-separated list of
\texttt{\PName{key}=\PName{value}} options. Currently the following
\PName{key}s are supported:
\begin{labeling}[\ --]{\KOption{position}\PName{horizontal offset}}
\item [\KOption{font}\PName{font declaration}] set the initial font attributes
  to be used for the note column. Everything, that is allowed to be set by
  \Macro{setkomafont} or \Macro{addtokomafont} can be used as
  \PName{font declaration}. Note, that
  \Macro{normalfont}\Macro{normalsize} will be used
  before. So you don't need one of them at your own initialisation.
\item [\Option{marginpar}] set up \Option{position} and \Option{width} to use
  the marginal note column of \Macro{marginpar}.
\item [\Option{normalmarginpar}] set up \Option{position} and \Option{width}
  to use the normal marginal note column and ignore \Macro{reversemarginpar}
  and \Macro{normalmarginpar}.
\item [\KOption{position}\PName{horizontal offset}] set up the horizontal
  offset of the note column from the left edge of the paper. The
  \PName{horizontal offset} can be either a \LaTeX{} length, a \TeX{}
  dimension, a \TeX{} skip, a length value, or a dimensional expression using
  \texttt{+}, \texttt{-}, \texttt{*}, \texttt{/} and parenthesis (see
  \cite[section~3.5]{manual:eTeX} for more information about dimensional
  expressions). The value will be calculated at usage time not at definition
  time. So you may even use more complex constructs like:
\begin{lstcode}
  \ifodd\value{page}
    \oddsidemargin+1in
    +\textwidth+\marginparsep
  \else
    \evensidemargin+1in
    -\marginparsep
    -\marginparwidth
  \fi
\end{lstcode}
\item [\Option{reversemarginpar}] set up \Option{position} and \Option{width}
  to use the reverse marginal note column and ignore \Macro{reversemarginpar}
  and \Macro{normalmarginpar}.
\item [\KOption{width}\PName{size}] set up the horizontal size of the note
  column. You can use the same values for \PName{size} like for
  \PName{horizontal offset} of option \Option{position}.
\end{labeling}

You may use as much note columns as \LaTeX{} provides free box registers,
because every note column needs one box register. You may use package
\Package{etex} to increase the normal amount of box registers from 256 to
32768. This should be enough to avoid the ``\texttt{no room for
  \Macro{newbox}}'' error.

The implementation of note columns uses foreground layers from package
\Package{scrlayer}. Every \Macro{DeclareNoteColumn} generates a layer and adds
this layer to the pseudo page style \Pagestyle{@everystyle@}. Theoretically
you may modify the generated layer, but it is recommended not to modify them.

Overlapping of different note columns is allowed. There's one predefined note
column named ``\texttt{marginpar}''.

% \iffalse^^A meta-comment
\BeginIndex{FontElement}{notecolumn.\PName{note column name}}%
% \fi^^A meta-comment
Note, that if you change the initial font using
\begin{quote}
  \Macro{setkomafont}\linebreak[1]\PParameter{marginnote.\PName{note column
      name}}\Parameter{font declaration}
\end{quote}
or
\begin{quote}
  \Macro{addtokomafont}\linebreak[1]\PParameter{marginnote.\PName{note column
      name}}\Parameter{font declaration}
\end{quote}
the font of all succeeding note column outputs would change. This could make it
hard to find out, which notes will be affected by the change.
% \iffalse^^A meta-comment
See \autoref{sec:maincls.textmarkup},
\autopageref{desc:maincls.cmd.setkomafont} for more information about
\Macro{setkomafont} and \Macro{addtokomafont}.%
\EndIndex{FontElement}{notecolumn.\PName{note column name}}%
% \fi^^A meta-comment

The difference between \Macro{DeclareNoteColumn} and the other commands is,
that \Macro{DeclareNoteColumn} defines the note column independent whether a
note column with the same name has already been defined or
not. \Macro{DeclareNewNoteColumn} defined only note columns which names are
not yet used for another note column. It's an error to use it with an already
used \PName{note column name}. \Macro{ProvideNoteColumn} is like
\Macro{DeclareNewNoteColumn}, but if the \PName{note column name} is already
used for a note column nothing happens. \Macro{RedeclareNoteColumn} may be
used to declare a note column with a name, that is already used. Using it with
a new name is an error.
%\iffalse^^A meta-comment
\EndIndex{Cmd}{RedeclareNoteColumn}%^^A
\EndIndex{Cmd}{ProvideNoteColumn}%^^A
\EndIndex{Cmd}{DeclareNewNoteColumn}%^^A
\EndIndex{Cmd}{DeclareNoteColumn}%^^A
%\fi^^A meta-comment

%\iffalse^^A meta-comment
\begin{Declaration}
%\fi^^A meta-comment
% \DescribeMacro{\makenote}
% The command
  \Macro{makenote}%
  \OParameter{note column name}\Parameter{note text}
%\iffalse^^A meta-comment
\end{Declaration}
\BeginIndex{Cmd}{makenote}%
This command
%\fi^^A meta-comment
may be used to make a new note. The note will be written to a helper file with
extension \File{.slnc} in this run. In the next run, it will be
typeset. Normally it will be typeset with the same vertical position, that
would be used for a \Macro{parbox[t]}, but horizontally moved to the note
column. Collisions at this position of this note column (but not of other note
columns) will be recognised. In such a case the note may be moved down and
even to another page. Automatic page breaks at the note columns are
supported. This is something different to \Macro{marginpar},
\Macro{marginline} (\KOMAScript{} classes), or \Macro{marginnote} (package
\Package{marginnote}).

Note, that after changing the document, at least two \LaTeX{} runs are needed
to move the note to its final position.

Note, that fragile commands should be protected to avoid error messages while
writing or reading the helper file.

Note, that \Package{scrlayer-notecolumn} needs only one helper file for all
note columns together. You should not edit or change that helper file, because
the syntax is fragile. It won't be read using \Macro{input} but
\Macro{read}. Because of this, line breaks, empty lines and \Macro{par} should
be avoided.

Currently it is unknown where you may use \Macro{makenote} and where not. But
you must not use \Macro{makenote} inside of \Macro{makenote}!

The default for the optional argument \PName{makenote} is \PValue{marginpar},
that is the \PName{note column name} of the pre-defined note column.
%\iffalse^^A meta-comment
\EndIndex{Cmd}{makenote}
%\fi^^A meta-comment

%\iffalse^^A meta-comment
\begin{Declaration}
  \KOption{autoclearnotecolumns}\PName{simple switch}\\
%\fi^^A meta-comment
% \DescribeMacro{\clearnotecolumn}
% The commands
  \Macro{clearnotecolumn}\OParameter{name of a note column}%
% \iffalse^^A meta-comment
  \\
% \fi^^A meta-comment
% and
  \Macro{clearnotecolumns}\OParameter{list of note column names}
%\iffalse^^A meta-comment
\end{Declaration}
\BeginIndex{Cmd}{clearnotcolumn}%
\BeginIndex{Cmd}{clearnotcolumns}%
The commands
%\fi^^A meta-comment
may be used to output all hanging notes for either one or several note
columns. With \Macro{clearnotecolumn} only the notes of the note column with
the given \PName{name of a note column} will be output. If you omit the
optional argument (this is not the same like using an empty value!) note
column \PValue{marginnote} will be used.

With \Macro{clearnotecolumns} the notes of all note columns of the comma
separated \PName{list of note column names} will be output. If you omit the
optional Argument or if the optional Argument is empty (or start with
\Macro{relax}) the notes of all note columns will be output.

Macro \Macro{clearpage} will be used to output hanging notes and several
\LaTeX{} runs may be needed to terminate with the correct number of
\Macro{clearpage} for the whole document. You will get the message ``\LaTeX{}
Warning: Label(s) may have changed. Rerun to get cross-references right.'' as
long as the process hasn't been terminated.

But normally you don't need to us \Macro{clearnotecolum} or
\Macro{clearnotecolumns} yourself. Because by default option
\Option{autoclearnotecolumns} is switched on, which means, that
\Macro{clearnotecolumns} will be done at every \Macro{clearpage}. You may
change this, switching off \Macro{autoclearnotecolumns} using one of the
values for simple switches.

Note, that it is not allowed to use \Macro{clearnotecolumn} or
\Macro{clearnotecolumns} inside a note. You can use these commands only inside
the main text of the document.%
%\iffalse^^A meta-comment
\EndIndex{Cmd}{clearnotcolumns}%
\EndIndex{Cmd}{clearnotcolumn}%
%\fi^^A meta-comment

%\iffalse^^A meta-comment
\begin{Declaration}
%\fi^^A meta-comment
% \DescribeMacro{\syncwithnotecolumn}
% The commands
  \Macro{syncwithnotecolumn}\OParameter{name of a note column}%
% \iffalse^^A meta-comment
  \\
% \fi^^A meta-comment
% and
  \Macro{syncwithnotecolumns}\OParameter{list of note column names}%
%\iffalse^^A meta-comment
\end{Declaration}
\BeginIndex{Cmd}{syncwithnotecolumn}%
\BeginIndex{Cmd}{syncwithnotecolumns}%
These commands
%\fi^^A meta-comment
may be used to synchronise the vertical position of the main text with one or
several note columns. If you use the optional argument of
\Macro{syncwithnotecolumn} it should be one \PName{name of a note column}. If
you omit it, \PValue{marginpar} will be used as the \PName{name of a note
  column}. Usage of \Macro{syncwithnotecolumn} is exactly the same like usage
of \Macro{syncwithnotecolumns} with exactly one \PName{name of a note column}.

The optional argument of \Macro{syncwithnotecolumns} is a comma-separated list
of names of note columns. If you omit this optional argument or if you use an
empty argument or if the argument starts with \Macro{relax} synchronisation
will be done with all declared note columns.

Synchronisation with a note column means, that the current position of the
main text will be changed to be the current vertical position of the note
column after cleaning the note column. This differs in several point from
cleaning a note column:
\begin{itemize}
\item After cleaning a note column the text position would change to be at a
  new page, even if the note column doesn't fill the whole page
  before. Synchronisation will change the vertical position just after the
  last vertical position of the note column.
\item Cleaning a note column needs less \LaTeX{} runs than synchronising a
  note column.
\end{itemize}
Both, cleaning an synchronising a note column, uses the label mechanism of
\LaTeX{} without using \Macro{label}, \Macro{ref}, or \Macro{pageref} itself
(but \Macro{newlabel}). So you should have a look at \LaTeX{} rerun messages,
because of undefined or changed labels.

Note, that it is not allowed to use \Macro{syncwithnotecolumn} or
\Macro{syncwithnotecolumns} inside a note. If you do so, you need endless
\LaTeX{} runs without reaching a final state. But synchronisation of several
note columns in the main text of a document will also synchronise the notes
columns with each others.%
%\iffalse^^A meta-comment
\EndIndex{Cmd}{syncwithnotecolumns}
\EndIndex{Cmd}{syncwithnotecolumn}
%\fi^^A meta-comment


%\iffalse
%</dtx|doc>
%\fi
%
% \StopEventually{}
%
% \chapter{Implementation of \Package{scrlayer-notecolumn}}
%
% This section if for developers only.
%
% \iffalse
%<*interface>
%<*identify>
% \fi
%
%\iffalse
%</identify>
%\fi
%
%
% \section{Initialising some Values before the Options}
%
% \iffalse^^A meta-comment
%<*init>
% \fi^^A meta-comment
%
% Initialisation before all options (even the options from
% \File{scrlayer.dtx}).
%
% Here we test the used pdf\TeX{} primitives.
%    \begin{macrocode}
\@tempswatrue
\scr@ifundefinedorrelax{pdfsavepos}{%
  \expandafter\@tempswafalse
}{%
  \scr@ifundefinedorrelax{pdflastypos}{%
    \expandafter\@tempswafalse
  }{}%
}
\if@tempswa\else
  \PackageError{scrlayer-notecolumn}{missing pdfTeX features}{%
    This package needs \string\pdfsavepos\space and
    \string\pdflastypos.\MessageBreak
    This error is fatal, because usage of the package without these
    features\MessageBreak
    cannot work!\MessageBreak
    You shouldn't continue, but if you'd try, I'll try to abort the LaTeX run
  }%
  \batchmode\csname @@end\endcsname\end
\fi
%    \end{macrocode}
%
% \iffalse^^A meta-comment
%</init>
% \fi^^A meta-comment
%
% \section{Making a Note Column}
%
% The package supports a various number of note columns. Each is referenced by
% a unique name.
%
% \begin{macro}{\DeclareNoteColumn}
%   \begin{description}
%   \item[\OParameter{option list}:] a comma-separated list of
%     \texttt{\meta{key}=\meta{value}} pairs.
%   \item[\Parameter{string}:] the name of the note column (must be fully
%     expandable and expand to a string only).
%   \end{description}
% That's the primary command for note columns. It defines everything, the note
% column needs.
%    \begin{macrocode}
%<*body>
\scrlayerAddToInterface\DeclareNoteColumn{%
  \newcommand*{\DeclareNoteColumn}[2][]{%
%    \end{macrocode}
% First of all we need a box register. The contents of the note column will be
% build inside of this register. Since \eTeX{} registers shouldn't be a
% problem. User should use package \Package{etex}, if he or she runs out of
% registers. Note, that the registers will stay allocated, if the interface
% will be removed! Nevertheless, the name will be destroyed!
%    \begin{macrocode}
    \@ifundefined{slnc@#2@box}{%
      \expandafter\newsavebox\csname slnc@#2@box\endcsname
      \scrlayerOnAutoRemoveInterface[scrlayer-notecolumn.sty]{%
        \expandafter\let\csname slnc@#2@box\endcsname\relax
      }%
    }{}%
%    \end{macrocode}
% There's also a kind of item stack of unprocessed notes for each note column.
%    \begin{macrocode}
    \@ifundefined{slnc@#2@unprocessed}{%
      \@namedef{slnc@#2@unprocessed}{}%
      \scrlayerOnAutoRemoveInterface[scrlayer-notecolumn.sty]{%
        \expandafter\let\csname slnc@#2@unprocessed\endcsname\relax
      }%
    }{}%
%    \end{macrocode}
% Next we need a horizontal positions and a width for the note column. Neither
% the horizontal position nor the width are stretchable or shrinkable. The
% position should be variable depending on the page. So it's better to use a
% macro instead of a length. The width isn't more variable than, e.g., the
% text width. So we can use a macro too. Both will be initialised to the
% normal marginal note column.
%    \begin{macrocode}
    \@ifundefined{slnc@#2@pos}{%
      \scrlayerOnAutoRemoveInterface[scrlayer-notecolumn.sty]{%
        \expandafter\let\csname slnc@#2@pos\endcsname\relax
      }%
    }{}%
    \@ifundefined{slnc@#2@width}{%
      \scrlayerOnAutoRemoveInterface[scrlayer-notecolumn.sty]{%
        \expandafter\let\csname slnc@#2@width\endcsname\relax
      }%
    }{}%
%    \end{macrocode}
% If there isn't a font element for the (new) note column, we define a new one
% and add it to the auto-remove code:
%    \begin{macrocode}
    \@ifundefined{scr@fnt@notecolumn.#2}{%
      \@ifundefined{@notecolumn.#2font}{%
        \scrlayerOnAutoRemoveInterface[scrlayer-notecolumn.sty]{%
          \expandafter\let\csname @notecolumn.#2font\endcsname\relax
        }%
      }{%
        \PackageInfo{scrlayer-notecolumn}{using already defined
          macro\MessageBreak
          `\expandafter\string\csname @notecolumn.#2font\endcsname' for font
          element\MessageBreak
          `notecolumn.#2'%
        }%
      }%
      \newkomafont{notecolumn.#2}{}%
      \scrlayerOnAutoRemoveInterface[scrlayer-notecolumn.sty]{%
        \expandafter\let\csname scr@fnt@notecolumn.#2\endcsname\relax
      }%
    }{%
      \PackageInfo{scrlayer-notecolumn}{using already defined font
        element\MessageBreak
        `notecolumn.#2'%
      }%
    }%
%    \end{macrocode}
% After the initialisation we process the options, that may change the initial
% values.
%    \begin{macrocode}
    \newcommand*{\slnc@name}{}%
    \edef\slnc@name{#2}%
    \FamilyExecuteOptions[.definenotecolumn]{KOMAarg}{marginpar,#1}%
    \let\slnc@name\relax
%    \end{macrocode}
% The values are set up, so they may be used to declare a layer.
%    \begin{macrocode}
    \DeclareLayer[%
      foreground,%
      align=tl,%
      voffset=1in+\topmargin+\headheight+\headsep,%
      height=\dimexpr\textheight+\topskip\relax,%
      hoffset=\csname slnc@#2@pos\endcsname,%
      width=\csname slnc@#2@width\endcsname,%
      contents=\slnc@processnotes{#2}%
    ]{notecolumn.#2}
%    \end{macrocode}
% We need to add the layer to every page style. The easiest way to do this is
% to add it to the pseudo layer page style \Pagestyle{@everystyle@}.
%    \begin{macrocode}
    \AddLayersToPageStyle{@everystyle@}{notecolumn.#2}%
%    \end{macrocode}
% On auto-removing the interface, the layer should be removed from
% \Pagestyle{@everystyle@} and should be destroyed.
%    \begin{macrocode}
    \scrlayerOnAutoRemoveInterface[scrlayer-notecolumn.sty]{%
      \RemoveLayersFromPageStyle{@everystyle@}{notecolumn.#2}%
      \DestroyLayer{notecolumn.#2}%
    }%
%    \end{macrocode}
% Last but not least, we add the new note column to the note column procession
% list.
%    \begin{macrocode}
    \@cons\slnc@processnotecolumns{{#2}}%
  }%
}
%    \end{macrocode}
% \begin{macro}{\slnc@processnotecolumns}
% This is a list of all declared note columns in \LaTeX{} syntax (using
% \Macro{@cons} and \Macro{@elt} etc.).
%    \begin{macrocode}
\scrlayerAddToInterface\slnc@processnotecolumns{%
  \newcommand*{\slnc@processnotecolumns}{}%
}
%    \end{macrocode}
% \end{macro}^^A \slnc@processnotecolumns
%    \begin{macrocode}
%</body>
%    \end{macrocode}
% One note column will be declared by default:
%    \begin{macrocode}
%<*final>
\DeclareNoteColumn{marginpar}
%</final>
%<*body>
%    \end{macrocode}
% \begin{macro}{\slnc@testforpagestylewarning}
% Not all page styles are layer page styles, but only layer page styles can be
% extended by the note column layers. So we warn, if another page style has
% been selected.
%    \begin{macrocode}
\scrlayerAddToInterface\slnc@testforpagestylewarning{%
  \newcommand*{\slnc@testforpagestylewarning}{%
    \IfLayerPageStyleExists{\currentpagestyle}{}{%
      \PackageWarning{scrlayer-notecolumn}{%
        output of note columns delayed,\MessageBreak
        because with `\currentpagestyle'\MessageBreak
        a page style has been selected, that\MessageBreak
        isn't a layer page style,%
      }%
    }%
  }%
}
\AfterSelectAnyPageStyle{\slnc@testforpagestylewarning}
%    \end{macrocode}
% \end{macro}%^^A \slnc@testforpagestylewarning
% \begin{option}{position}
% \begin{option}{width}
% \begin{option}{font}
% \begin{option}{marginpar}
% \begin{option}{normalmarginpar}
% \begin{option}{reversemarginpar}
% Last but not least we have to define the options for the \PName{option
% list}.
%    \begin{macrocode}
\DefineFamilyMember[.definenotecolumn]{KOMAarg}
\DefineFamilyKey[.definenotecolumn]{KOMAarg}{position}{%
  \@namedef{slnc@\slnc@name @pos}{\dimexpr #1\relax}%
  \FamilyKeyStateProcessed
}
\scrlayer@AddCsToInterface{KV@KOMAarg.definenotecolumn@position}
\scrlayer@AddCsToInterface{KV@KOMAarg.definenotecolumn@position@default}
\DefineFamilyKey[.definenotecolumn]{KOMAarg}{width}{%
  \@namedef{slnc@\slnc@name @width}{\dimexpr #1\relax}%
  \FamilyKeyStateProcessed
}
\scrlayer@AddCsToInterface{KV@KOMAarg.definenotecolumn@width}
\scrlayer@AddCsToInterface{KV@KOMAarg.definenotecolumn@width@default}
\DefineFamilyKey[.definenotecolumn]{KOMAarg}{font}{%
  \setkomafont{notecolumn.\slnc@name}{#1}%
  \FamilyKeyStateProcessed
}
\scrlayer@AddCsToInterface{KV@KOMAarg.definenotecolumn@font}
\scrlayer@AddCsToInterface{KV@KOMAarg.definenotecolumn@font@default}
\DefineFamilyKey[.definenotecolumn]{KOMAarg}{marginpar}[\relax]{%
  \FamilyKeyStateProcessed
  \scrlayer@testunexpectedarg{marginpar}{#1}%
  \edef\reserved@a{\noexpand\slnc@defpos{\slnc@name}}\reserved@a
  \@namedef{slnc@\slnc@name @width}{\marginparwidth}%
}
\scrlayer@AddCsToInterface{KV@KOMAarg.definenotecolumn@marginpar}
\scrlayer@AddCsToInterface{KV@KOMAarg.definenotecolumn@marginpar@default}
%    \end{macrocode}
% \begin{macro}{\slnc@defpos}
% Little helper for option \Option{marginpar}. The argument is the expanded
% name of the note column.
%    \begin{macrocode}
\scrlayerAddToInterface\slnc@defpos{%
  \newcommand*\slnc@defpos[1]{%
    \@namedef{slnc@#1@pos}{%
      \ifodd\value{page}
        \if@reversemargin
%    \end{macrocode}
% The reverse marginal note column on odd pages is at the left margin.
%    \begin{macrocode}
          \dimexpr \oddsidemargin+1in
                  -\marginparsep-\csname slnc@#1@width\endcsname\relax
        \else
%    \end{macrocode}
% The normal marginal note column on odd pages is the right margin.
%    \begin{macrocode}
          \dimexpr \oddsidemargin+1in
                  +\textwidth+\marginparsep\relax
        \fi
      \else
        \if@twoside
          \if@reversemargin
%    \end{macrocode}
% The reverse marginal note column on even pages is the right margin.
%    \begin{macrocode}
            \dimexpr \evensidemargin+1in
                    +\textwidth+\marginparsep\relax
          \else
%    \end{macrocode}
% The normal marginal note column on even pages is at the left margin.
%    \begin{macrocode}
            \dimexpr \evensidemargin+1in
                    -\marginparsep-\csname slnc@#1@width\endcsname\relax
          \fi
        \else
%    \end{macrocode}
%    \begin{macrocode}
% If not in two-side mode, do the same already done for odd pages.
          \if@reversemargin
            \dimexpr \oddsidemargin+1in
                    -\marginparsep-\csname slnc@#1@width\endcsname\relax
          \else
            \dimexpr \oddsidemargin+1in
                    +\textwidth+\marginparsep\relax
          \fi
        \fi
      \fi
    }%
  }%
}%
%    \end{macrocode}
% \end{macro}%^^A \slnc@defpos
%    \begin{macrocode}
\DefineFamilyKey[.definenotecolumn]{KOMAarg}{normalmarginpar}[\relax]{%
  \FamilyKeyStateProcessed
  \scrlayer@testunexpectedarg{normalmarginpar}{#1}%
  \edef\reserved@a{\noexpand\slnc@defnormalpos{\slnc@name}}\reserved@a
  \@namedef{slnc@\slnc@name @width}{\marginparwidth}%
}
\scrlayer@AddCsToInterface{KV@KOMAarg.definenotecolumn@normalmarginpar}
\scrlayer@AddCsToInterface{KV@KOMAarg.definenotecolumn@normalmarginpar@default}
%    \end{macrocode}
% \begin{macro}{\slnc@defnormalpos}
% Little helper for option \Option{normalmarginpar}. The argument is the
% expanded name of the note column.
%    \begin{macrocode}
\scrlayerAddToInterface\slnc@defnormalpos{%
  \newcommand*\slnc@defnormalpos[1]{%
    \@namedef{slnc@#1@pos}{%
      \ifodd\value{page}
%    \end{macrocode}
% The normal marginal note column on odd pages is the right margin.
%    \begin{macrocode}
        \dimexpr \oddsidemargin+1in
                +\textwidth+\marginparsep\relax
      \else
        \if@twoside
%    \end{macrocode}
% The normal marginal note column on even pages is at the left margin.
%    \begin{macrocode}
          \dimexpr \evensidemargin+1in
                  -\marginparsep-\csname slnc@#1@width\endcsname\relax
        \else
%    \end{macrocode}
%    \begin{macrocode}
% If not in two-side mode, do the same already done for odd pages.
          \dimexpr \oddsidemargin+1in
                  +\textwidth+\marginparsep\relax
        \fi
      \fi
    }%
  }%
}%
%    \end{macrocode}
% \end{macro}%^^A \slnc@defnormalpos
%    \begin{macrocode}
\DefineFamilyKey[.definenotecolumn]{KOMAarg}{reversemarginpar}[\relax]{%
  \FamilyKeyStateProcessed
  \scrlayer@testunexpectedarg{reversemarginpar}{#1}%
  \edef\reserved@a{\noexpand\slnc@defreversepos{\slnc@name}}\reserved@a
  \@namedef{slnc@\slnc@name @width}{\marginparwidth}%
}
\scrlayer@AddCsToInterface{KV@KOMAarg.definenotecolumn@reversemarginpar}
\scrlayer@AddCsToInterface{KV@KOMAarg.definenotecolumn@reversemarginpar@default}
%    \end{macrocode}
% \begin{macro}{\slnc@defreversepos}
% Little helper for option \Option{reversemarginpar}. The argument is the
% expanded name of the note column.
%    \begin{macrocode}
\scrlayerAddToInterface\slnc@defreversepos{%
  \newcommand*\slnc@defreversepos[1]{%
    \@namedef{slnc@#1@pos}{%
      \ifodd\value{page}
%    \end{macrocode}
% The reverse marginal note column on odd pages is at the left margin.
%    \begin{macrocode}
        \dimexpr \oddsidemargin+1in
                -\marginparsep-\csname slnc@#1@width\endcsname\relax
      \else
        \if@twoside
%    \end{macrocode}
% The reverse marginal note column on even pages is the right margin.
%    \begin{macrocode}
          \dimexpr \evensidemargin+1in
                  +\textwidth+\marginparsep\relax
        \else
%    \end{macrocode}
%    \begin{macrocode}
% If not in two-side mode, do the same already done for odd pages.
          \dimexpr \oddsidemargin+1in
                  -\marginparsep-\csname slnc@#1@width\endcsname\relax
        \fi
      \fi
    }%
  }%
}%
%    \end{macrocode}
% \end{macro}%^^A \slnc@defreversepos
%    \begin{macrocode}
%</body>
%    \end{macrocode}
% \end{option}%^^A reversemarginpar
% \end{option}%^^A normalmarginpar
% \end{option}%^^A marginpar
% \end{option}%^^A font
% \end{option}%^^A width
% \end{option}%^^A position
% \end{macro}%^^A \DeclareNoteColumn
%
% \begin{macro}{\DeclareNewNoteColumn}
% \begin{macro}{\ProvideNoteColumn}
% \begin{macro}{\RedeclareNoteColumn}
% Like \Macro{DeclareNoteColumn} but with restrictions, if the note column has
% (not) been declared already.
%    \begin{macrocode}
%<*body>
\scrlayerAddToInterface\DeclareNewNoteColumn{%
  \newcommand*{\DeclareNewNoteColumn}[2][]{%
    \scr@ifundefinedorrelax{slnc@#2@box}{}{%
      \PackageError{scrlayer-notecolumn}{note column `#2' already defined}{%
        You may declare only note columns, that haven't been declared
        previously using\MessageBreak
        \string\DeclareNewNoteColumn. See also the alternatives
        \string\RedeclareNoteColumn,\MessageBreak
        \string\ProvideNoteColumn, and \string\DeclareNoteColumn.\MessageBreak
        Nevertheless, if you'll continue, declaration will be done.%
      }%
    }%
    \DeclareNoteColumn[{#1}]{#2}%
  }%
}
\scrlayerAddToInterface\ProvideNoteColumn{%
  \newcommand*{\ProvideNoteColumn}[2][]{%
    \scr@ifundefinedorrelax{slnc@#2@box}{}{%
      \PackageInfo{scrlayer-notecolumn}{\string\ProvideNoteColumn{#2}
        ignored,\MessageBreak
        because of already defined\MessageBreak
        not column}%
    }{%
      \DeclareNoteColumn[{#1}]{#2}%
    }%
  }%
}
\scrlayerAddToInterface\RedeclareNoteColumn{%
  \newcommand*{\RedeclareNoteColumn}[2][]{%
    \scr@ifundefinedorrelax{slnc@#2@box}{%
      \PackageError{scrlayer-notecolumn}{note column `#2' undefined}{%
        You may declare only note columns, that have been declared
        previously using\MessageBreak
        \string\RedeclareNoteColumn. See also the alternatives
        \string\DeclareNewNoteColumn,\MessageBreak
        \string\ProvideNoteColumn, and \string\DeclareNoteColumn.\MessageBreak
        Nevertheless, if you'll continue, declaration will be done.%
      }%
    }{}%
    \DeclareNoteColumn[{#1}]{#2}%
  }%
}
%</body>
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \section{Setting a Note Column}
%
% We already have commands to declare note columns. But we also need a command
% to put contents into the note columns and to output the note columns.
%
% \begin{macro}{\tf@slnc}
% \begin{macro}{\slnc@initwrite}
% \begin{macro}{\slnc@openwrite}
% First of all we need a file to write the notes to. We use the
% \File{aux}-file to write into the file, because we need to read the file
% while the document will be typeset and the same time we need to write into
% the file. Note, that the file will be still reserved on auto-removing the
% interface!
%    \begin{macrocode}
%<*body>
\scrlayerAddToInterface\tf@slnc{%
  \newwrite\tf@slnc
  \AtBeginDocument{%
    \immediate\write\@auxout{%
      \noexpand\csname slnc@initwrite\noexpand\endcsname
    }%
  }%
  \AtEndDocument{\let\slnc@initwrite\slnc@openwrite}%
}
\scrlayerAddToInterface\slnc@initwrite{}%
\scrlayerAddToInterface\slnc@openwrite{%
  \newcommand*{\slnc@openwrite}{%
    \immediate\closeout\slnc@file
%<*trace>
    \PackageInfo{scrlayer-notecolumn}{%
      Opening `\jobname.slnc'\MessageBreak
      for writing}%
%</trace>
    \immediate\openout\tf@slnc\jobname.slnc
  }%
}
\AfterReadingMainAux{%
  \immediate\closeout\tf@slnc
  \scr@ifundefinedorrelax{pdfmdfivesum}{%
    \PackageWarningNoLine{scrlayer-notecolumn}{%
      \string\pdfmdfivesum\space unavailable.\MessageBreak
      The package needs \string\pdfmdfivesum\space to test\MessageBreak
      whether or not one more LaTeX run will\MessageBreak
      be needed to make the note columns\MessageBreak
      right. If this command is unavailable\MessageBreak
      you have to do the decision without\MessageBreak
      this help of the package.%
    }%
  }{%
    \begingroup
      \edef\reserved@a{\pdfmdfivesum file {\jobname.slnc}}%
      \ifx \slnc@mdfivesum\reserved@a
%<*trace>
        \PackageInfo{scrlayer-notecolumn}{%
          MD5 of current `\jobname.slnc':\MessageBreak 
          \reserved@a}%
%</trace>
      \else
%<*trace>
        \PackageWarningNoLine{scrlayer-notecolumn}{%
          MD5 of slnc-file changed.\MessageBreak
          Last: \slnc@mdfivesum\MessageBreak
          New: \space \reserved@a\MessageBreak
          At least one more LaTeX rerun need to\MessageBreak
          make note columns right%
        }%
%</trace>
        \aftergroup\@tempswatrue
      \fi
    \endgroup
  }%
}
%</body>
%    \end{macrocode}
% \end{macro}^^A \slnc@openwrite
% \end{macro}^^A \slnc@initwrite
% \end{macro}^^A \tf@slnc
%
% \begin{macro}{\makenote}
%   \begin{description}
%   \item[\OParameter{string}:] the name of the note column the note should be
%     added to (must be fully expandable and expand to a string only). The
%     default value is \PValue{marginpar}.
%   \item[\Parameter{code}:] the code, that should become par of the note
%     column. Note, that this will be written protected to a file. So you have
%     to use \Macro{protect} if a macro shouldn't be expanded while writing or
%     may break while writing.
%   \end{description}
%    \begin{macrocode}
%<*body>
\scrlayerAddToInterface\makenote{%
  \newcommand{\makenote}[2][marginpar]{%
    \@bsphack
    \pdfsavepos
    \addtocontents{slnc}{%
      \string\slnc@note{#1}%
                       {\noexpand\number\value{slncpage}}%
                       {\noexpand\number\pdflastypos}%
                       {#2}%
    }%
    \@esphack
  }%
}
%    \end{macrocode}
%^^A \begin{counter}{slncpage}
% This counter should be increased once per page with note column. This may
% be done simply at a once per page executed hook of
% \Pagestyle{@everystyle@}. You should note, that auto-remove wouldn't
% remove the counter.
%    \begin{macrocode}
\@ifundefined{c@slncpage}{%
  \newcounter{slncpage}%
  \AddToLayerPageStyleOptions{@everystyle@}{%
    onbackground=\stepcounter{slncpage}%
  }%
}{}
%</body>
%    \end{macrocode}
%^^A \end{counter}^^A slncpage
% \end{macro}^^A \makenote
%
% \begin{macro}{\slnc@processnotes}
%   \begin{description}
%   \item[\Parameter{string}:] the name of the note column (must be fully
%     expandable an expand to a string only).
%   \end{description}
% Each note column typesets the notes with this command. It works in following
% steps:
%    \begin{macrocode}
%<*body>
\scrlayerAddToInterface\slnc@processnotes{%
  \newcommand*{\slnc@processnotes}[1]{%
%    \end{macrocode}
% Read as long notes from the notes file until the number at \#2 of
% \Macro{slnc@note} in the file is greater than \Counter{slncpage}. Put all
% these to the corresponding unprocessed list.
%    \begin{macrocode}
    \begingroup
      \slnc@readnotes{\value{slncpage}}%
%    \end{macrocode}
% Process the unprocessed list of the current note column
%    \begin{macrocode}
      \expandafter\let\expandafter\reserved@a
      \csname slnc@#1@unprocessed\endcsname
      \expandafter\global
      \expandafter\let\csname slnc@#1@unprocessed\endcsname\@empty
      \def\slnc@notesyncfonttest##1{%
        \ifhmode
          \PackageError{scrlayer-notecolumn}{%
            illegal font setting for `notecolumn.##1'%
          }{%
            Current setting of font for `notecolumn.##1' switches
            from\MessageBreak
            vertical mode to horizontal mode. This is
            illegal!\MessageBreak
            You have to change the font setting to fix
            this.\MessageBreak
            If you'll continue vertical alignment of notes may fail%
          }%
          \par\vskip-\dimexpr \baselineskip+\parskip\relax
        \fi
      }%
      \long\def\slnc@note##1##2##3##4{%
        \let\PackageInfo\PackageWarning
        \ifnum ##2>\value{slncpage}\relax
          \expandafter\g@addto@macro\csname slnc@#1@unprocessed\endcsname{%
            \slnc@note{##1}{##2}{##3}{##4}%
          }%
        \else
          \ifnum ##2<\value{slncpage}\relax
            \PackageWarning{scrlayer-notecolumn}{note of type `#1' delayed.}%
          \fi
          \boxmaxdepth\maxdepth
          \expandafter\setbox\csname slnc@#1@box\endcsname\vbox{%
            \expandafter\hsize\csname slnc@#1@width\endcsname
            \normalfont\normalsize
            {%
%    \end{macrocode}
% Question: Why is it not allowed to set a colour here?
%    \begin{macrocode}
              \let\color\@gobble
              \usekomafont{notecolumn.#1}{%
                \slnc@notesyncfonttest{#1}%
                \expandafter\ifvoid\csname slnc@#1@box\endcsname
                  \expandafter\setbox\csname slnc@#1@box\endcsname\vbox{%
                    \kern\dimexpr\topskip-\baselineskip\relax
                  }%
                \fi
                \scr@ifundefinedorrelax{pdfpageheight}{%
                  \@tempdima=\paperheight
                }{%
                  \@tempdima=\pdfpageheight
                }%
                \@tempdima=\dimexpr \@tempdima-##3sp
                                    -1in-\topmargin
                                    -\headheight-\headsep
                                    -\baselineskip
                           \relax
                \@tempdimb=\dimexpr \expandafter\ht\csname slnc@#1@box\endcsname
                                   +\expandafter\dp\csname slnc@#1@box\endcsname
                           \relax
                \typeout{Soll: \the\@tempdima^^JIst: \space\the\@tempdimb}%
                \ifdim\@tempdima<\@tempdimb
%<*trace>
                  \PackageInfo{scrlayer-notecolumn}{%
                    Note moved down from\MessageBreak
                    \the\@tempdima\space to \the\@tempdimb\MessageBreak
                    at note box `#1'
                  }%
%</trace>
                \else
                  \ifdim\@tempdima>\@tempdimb
%<*trace>
                    \PackageInfo{scrlayer-notecolumn}{%
                      Adding vertical white space from\MessageBreak
                      \the\@tempdimb\space to \the\@tempdima\MessageBreak
                      into note box `#1'
                    }%
%</trace> 
                    \expandafter\setbox\csname slnc@#1@box\endcsname
                    \vbox {%
                      \expandafter\unvbox\csname slnc@#1@box\endcsname
                      \kern\dimexpr\@tempdima-\@tempdimb\relax
                    }%
                  \fi
                \fi
                \expandafter\ifvoid\expandafter\csname slnc@#1@box\endcsname
                \else
                  \@tempdima\dimexpr
                              \dp\strutbox
                              -\dp\csname slnc@#1@box\endcsname
                            \relax
                  \expandafter\unvbox\csname slnc@#1@box\endcsname
                  \ifdim\@tempdima>\z@ \kern\@tempdima\fi
                \fi
                \strut\ignorespaces ##4\par
              }%
            }%
          }%
        \fi
      }%
      \def\slnc@sync##1##2##3##4{%
        \ifnum ##2>\value{slncpage}\relax
          \expandafter\g@addto@macro\csname slnc@#1@unprocessed\endcsname{%
            \slnc@sync{##1}{##2}{##3}{}%
          }%
        \else
          \if@filesw
            \expandafter\setbox\csname slnc@#1@box\endcsname\vbox{%
              \expandafter\unvbox\csname slnc@#1@box\endcsname
              \pdfsavepos
              \protected@write\@auxout{}{%
                \string\newlabel{notecolumn.##1.##3.syncnote.label}{%
                  {%
                    \noexpand\number\pdflastypos
                  }{\thepage}%
                }%
              }%
            }%
          \fi
        \fi
      }%
      \reserved@a
      \expandafter\ifvoid\csname slnc@#1@box\endcsname
%<*trace>
        \PackageInfo{scrlayer-notecolumn}{Note box `#1' empty}%
%</trace>
      \else
        \ifdim \dimexpr \expandafter\ht\csname slnc@#1@box\endcsname
                       +\expandafter\dp\csname slnc@#1@box\endcsname
               \relax >\textheight\relax
%<*trace>
          \PackageInfo{scrlayer-notecolumn}{Split note box `#1'}%
%</trace>
          \splittopskip\topskip
          \splitmaxdepth\baselineskip
%    \end{macrocode}
% Bring back the colours:
%    \begin{macrocode}
          \usekomafont{notecolumn.#1}{%
            \expandafter\vsplit\csname slnc@#1@box\endcsname to
            \textheight\relax
          }%
          \expandafter\ifvoid\csname slnc@#1@box\endcsname
          \else
            \expandafter\setbox\csname slnc@#1@box\endcsname\vbox{%
                  \expandafter\unvbox\csname slnc@#1@box\endcsname
            }%
          \fi
        \else
%<*trace>
          \PackageInfo{scrlayer-notecolumn}{Flush note box `#1'}%
%</trace>
%    \end{macrocode}
% Bring back the colours:
%    \begin{macrocode}
          \usekomafont{notecolumn.#1}{%
            \expandafter\box\csname slnc@#1@box\endcsname%
          }%
        \fi
      \fi
      \expandafter\global
      \expandafter\setbox\csname slnc@#1@box\expandafter\endcsname
      \expandafter\box\csname slnc@#1@box\endcsname
    \endgroup
  }
}
%    \end{macrocode}
% \begin{macro}{\slnc@readnotes}
% Read as long notes from the notes file until the number at \#2 of
% \Macro{slnc@note} or \Macro{slnc@sync} in the file is greater than
% \Counter{slncpage}. Put all these to the corresponding unprocessed list.
%    \begin{macrocode}
\scrlayerAddToInterface\slnc@readnotes{%
  \newcommand*\slnc@readnotes[1]{%
    \ifeof\slnc@file\else
      \ifnum \number #1<\slnc@unprocessed\relax
        \@tempswafalse
      \else
        \@tempswatrue
      \fi
      \@whilesw\if@tempswa\fi{%
        \edef\reserved@a{%
          \noexpand\makeatletter
          \endlinechar\m@ne
          \read\noexpand\slnc@file to\noexpand\reserved@a
          \endlinechar\the\endlinechar\relax
          \catcode`\noexpand\@=\the\catcode`\@\relax
        }%
        \reserved@a
        \expandafter\slnc@iofv\expandafter\reserved@b\reserved@a
        \@empty\@empty\@empty\@empty\@empty
        \@tempswafalse
        \@for\reserved@c :={\slnc@note },{\slnc@sync }\do{%
          \ifx\reserved@b\reserved@c \@tempswatrue\fi
        }%
        \if@tempswa
          \@tempswafalse
          \expandafter\slnc@iiiofv\expandafter\reserved@b\reserved@a
          \@empty\@empty\@empty\@empty\@empty
          \ifx\reserved@b\@empty
            \PackageError{scrlayer-notecolumn}{internal syntax error}{%
              Unexpected syntax of file `\jobname.slnc'.\MessageBreak
              Second argument should be a number.\MessageBreak
              I don't know what to do with\MessageBreak
              \expandafter\detokenize\expandafter{\reserved@a}%
            }%
            \@tempswatrue
          \else
            \global\let\slnc@unprocessed\reserved@b
            \expandafter\slnc@iiofv\expandafter\reserved@b\reserved@a
            \@empty\@empty\@empty\@empty\@empty
            \@ifundefined{slnc@\reserved@b @unprocessed}{%
              \PackageWarning{scrlayer-notecolumn}{%
                column `\reserved@b' undefined.\MessageBreak
                You should declare the column before the usage.\MessageBreak
                Notes will be lost
              }%
            }{%
              \expandafter\g@addto@macro
              \csname slnc@\reserved@b @unprocessed\expandafter\endcsname
              \expandafter{%
                \reserved@a
              }%
            }%
            \ifnum \number #1<\slnc@unprocessed\relax
              \@tempswafalse
            \else
              \@tempswatrue
            \fi
          \fi
        \else
%<*trace>
          \PackageInfo{scrlayer-notecolumn}{%
            Ignoring `\expandafter\detokenize\expandafter{\reserved@a}'}%
%</trace>
          \@tempswatrue
        \fi
        \ifeof\slnc@file\@tempswafalse\fi
      }%
    \fi
  }%
}
%    \end{macrocode}
% \end{macro}^^A \slnc@readnotes
% \begin{macro}{\slnc@iofv}
% \begin{macro}{\slnc@iiofv}
% \begin{macro}{\slnc@iiiofv}
%    \begin{macrocode}
\scrlayerAddToInterface\slnc@iofv{%
  \newcommand\slnc@iofv[6]{\def#1{#2}}%
}
\scrlayerAddToInterface\slnc@iiofiv{%
  \newcommand\slnc@iiofv[6]{\def#1{#3}}%
}
\scrlayerAddToInterface\slnc@iiiofiv{%
  \newcommand\slnc@iiiofv[6]{\def#1{#4}}%
}
%    \end{macrocode}
% \end{macro}^^A \slnc@iiiofv
% \end{macro}^^A \slnc@iiofv
% \end{macro}^^A \slnc@iofv
% \begin{macro}{\slnc@unprocessed}
% The \#2 of the last read note column from notes file.
%    \begin{macrocode}
\scrlayerAddToInterface\slnc@unprocessed{%
  \newcommand*{\slnc@unprocessed}{0}%
}
%</body>
%    \end{macrocode}
% \begin{macro}{\slnc@file}
% The input file with the unprocessed notes.
% \begin{macro}{\slnc@mdfivesum}
% The MD5 sum of the file before opening it for reading.
%    \begin{macrocode}
%<*body>
\scrlayerAddToInterface\slnc@mdfivesum{%
  \let\slnc@mdfivesum\@empty
}
\scrlayerAddToInterface\slnc@file{%
  \scr@ifundefinedorrelax{pdfmdfivesum}{}{%
    \xdef\slnc@mdfivesum{\pdfmdfivesum file {\jobname.slnc}}%
%<*trace>
    \PackageInfo{scrlayer-notecolumn}{%
      MD5 of last `\jobname.slnc':\MessageBreak
      \slnc@mdfivesum}%
%</trace>
  }%
  \newread\slnc@file
  \immediate\openin\slnc@file \jobname.slnc
  \scrlayerOnAutoRemoveInterface{\immediate\closeout\slnc@file}%
}
%</body>
%    \end{macrocode}
% \end{macro}^^A \slnc@mdfivesum
% \end{macro}^^A \slnc@file
% \end{macro}^^A \slnc@unprocessed
% \end{macro}^^A \slnc@processnotes
%
% \begin{option}{autoclearnotecolumns}
%    \begin{macrocode}
%<*options>
\KOMA@ifkey{autoclearnotecolumns}{slnc@autoclearnotecolumns}\slnc@autoclearnotecolumnstrue
\scrlayer@AddCsToInterface{KV@KOMA.\@currname.\@currext @autoclearnotecolumns}
\scrlayer@AddCsToInterface{KV@KOMA.\@currname.\@currext @autoclearnotecolumns@default}
%</options>
%<*final>
\let\reserved@a\clearpage
\def\clearpage{%
  \ifslnc@autoclearnotecolumns\clearnotecolumns\relax\fi
}%
\expandafter\g@addto@macro\expandafter\clearpage\expandafter{\reserved@a}
%</final>
%    \end{macrocode}
% \end{option}
%
% \begin{macro}{\clearnotecolumn}
%   \begin{description}
%   \item[\OParameter{string}:] the name of the note column (must be fully
%     expandable and expand to a string only). Default is \PValue{marginpar}.
%   \end{description}
% Output as many (empty) pages as needed to output all unprocessed notes of
% one note column. Note, that the output of the first page may result in more
% unprocessed notes. But the output of the following (empty) pages shouldn't.
%    \begin{macrocode}
%<*body>
\scrlayerAddToInterface\c@slnc@clearnote@label{%
  \newcounter{slnc@clearnote@label}%
}
\scrlayerAddToInterface\clearnotecolumn{%
  \newcommand*\clearnotecolumn[1][marginpar]{%
    \begingroup
      \slnc@autoclearnotecolumnsfalse
%    \end{macrocode}
% First of all we need to know the note column page of this page.
%    \begin{macrocode}
      \stepcounter{slnc@clearnote@label}%
      \if@filesw
        \protected@write\@auxout{%
          \let\theslncpage\relax
          \let\slnc@voidtest\relax
        }{%
          \string\newlabel{notecolumn.\theslnc@clearnote@label}%
          {{\theslncpage}{\slnc@voidtest{#1}}}%
        }%
      \fi
      \scr@ifundefinedorrelax{r@notecolumn.\theslnc@clearnote@label}{%
        \PackageInfo{scrlayer-notecolumn}{%
          Using estimated to low value for clearing\MessageBreak
          note colum `#1'%
        }
        \edef\slnc@cmp@value{\the\value{slncpage}}%
        \let\reserved@a\z@
      }{%
        \edef\reserved@a{%
          \@nameuse{r@notecolumn.\theslnc@clearnote@label}\@empty\@empty
        }%
        \edef\slnc@cmp@value{\expandafter\slnc@firstof\reserved@a\@nil}%
        \edef\reserved@a{\expandafter\slnc@secondof\reserved@a\@nil}%
      }%
      \ifnum \reserved@a=\z@
%    \end{macrocode}
% Next we read all notes until the end of the current page, but only
% if a \Macro{clearpage} wouldn't result in a new page.
%    \begin{macrocode}
        \ifvmode
          \ifdim \pagetotal<\topskip
          \else
            \slnc@readnotes{\slnc@cmp@value}%
          \fi
        \else
          \slnc@readnotes{\slnc@cmp@value}%
        \fi
        \begingroup
          \aftergroup\@tempswafalse
          \long\def\slnc@note##1##2##3##4{%
            \ifnum ##2>\slnc@cmp@value\relax \else \aftergroup\@tempswatrue\fi
          }%
          \let\slnc@sync\slnc@note
          \csname slnc@#1@unprocessed\endcsname
        \endgroup
      \else
        \PackageInfo{scrlayer-notecolumn}{%
          box of note column `#1'\MessageBreak
          not empty after page of \string\clearnotecolumn}%
        \@tempswatrue
      \fi
      \if@tempswa
%    \end{macrocode}
% Yes, we have!
%    \begin{macrocode}
        \IfLayerPageStyleExists{\currentpagestyle}{}{%
          \PackageWarning{scrlayer-notecolumn}{%
            \string\clearnotecolumn\space while active non-layer page
            style.\MessageBreak
            Activate empty page style until note column\MessageBreak
            has been cleared%
          }%
          \pagestyle{empty}%
        }%
        \@tempswatrue
      \fi
      \@whilesw\if@tempswa\fi{%
%    \end{macrocode}
% Yes, we have (maybe again)!
%    \begin{macrocode}
        \clearpage
        \expandafter\ifcase \slnc@voidtest{#1}%
          \begingroup
            \aftergroup\@tempswafalse
            \long\def\slnc@note##1##2##3##4{%
              \ifnum ##2>\slnc@cmp@value\relax \else \aftergroup\@tempswatrue\fi
            }%
            \let\slnc@sync\slnc@note
            \csname slnc@#1@unprocessed\endcsname
          \endgroup
        \else
          \@tempswatrue
        \fi
        \if@tempswa
%    \end{macrocode}
% And we still have: So we have to output one more page.
%    \begin{macrocode}
          \null
        \fi
      }%
    \endgroup
  }%
}
%    \end{macrocode}
% \begin{macro}{\slnc@firstof}
% \begin{macro}{\slnc@secondof}
%   We need these little helpers, because some packages like
%   \Package{hyperref} extend the label mechanism by additional arguments.
%    \begin{macrocode}
\scrlayerAddToInterface{\slnc@firstof}{%
  \def\slnc@firstof#1#2\@nil{#1}%
}
\scrlayerAddToInterface{slnc@secondof}{%
  \def\slnc@secondof#1#2#3\@nil{#2}%
}
%    \end{macrocode}
% \end{macro}^^A \slnc@firstof
% \end{macro}^^A \slnc@secondof
% \begin{macro}{\slnc@voidtest}
%   \begin{description}
%   \item[\Parameter{string}:] the name of a note column (must be fully
%     expandable and expand to a string only).
%   \end{description}
% If the box of the note column is empty/void it returns \Macro{z@} otherwise
% \Macro{@ne}.
%    \begin{macrocode}
\scrlayerAddToInterface\slnc@voidtest{%
  \newcommand*{\slnc@voidtest}[1]{%
    \expandafter\ifvoid \csname slnc@#1@box\endcsname \z@\else \@ne\fi
  }%
}
%</body>
%    \end{macrocode}
% \end{macro}^^A \slnc@voidtest
% \end{macro}^^A \clearnotecolumn
% 
% \begin{macro}{\clearnotecolumns}
%   \begin{description}
%   \item[\OParameter{string list}:] comma separated list of note column names
%     (must be fully expandable and each element must expand to a string only,
%     that is the name of a note column); if omitted or empty all note columns
%     will be used.
%   \end{description}
% Output as many (empty) pages as needed to output all unprocessed notes of
% all (given) note columns. Note, that the output of the first page may
% result in more unprocessed notes. But the output of the following (empty)
% pages shouldn't.
%    \begin{macrocode}
%<*body>
\scrlayerAddToInterface\clearnotecolumns{%
  \newcommand*\clearnotecolumns[1][\relax]{%
    \begingroup
      \slnc@autoclearnotecolumnsfalse
      \ifx\relax#1\relax\else
        \let\slnc@processnotecolumns\@empty
        \edef\reserved@a{#1}%
        \expandafter\@for\expandafter\reserved@a\expandafter:\expandafter=%
        \reserved@a\do {%
          \ifx\reserved@a\@empty\else
            \expandafter\l@addto@macro\expandafter\slnc@processnotecolumns
            \expandafter{\expandafter\@elt\expandafter{\reserved@a}}%
          \fi
        }%
      \fi
%    \end{macrocode}
% First of all we need to know the note column page of this page.
%    \begin{macrocode}
      \stepcounter{slnc@clearnote@label}%
      \if@filesw
        \begingroup
          \def\@elt##1{+\slnc@voidtest{##1}}%
          \protected@write\@auxout{%
            \let\theslncpage\relax
            \let\slnc@voidtest\relax
          }{%
            \string\newlabel{notecolumn.\theslnc@clearnote@label}%
            {{\theslncpage}{\numexpr \slnc@processnotecolumns\relax}}%
          }%
        \endgroup
      \fi
      \scr@ifundefinedorrelax{r@notecolumn.\theslnc@clearnote@label}{%
        \begingroup
          \def\@elt##1{, `##1'}%
          \PackageInfo{scrlayer-notecolumn}{%
            Using estimated to low value for\MessageBreak
            clearing note colums\MessageBreak
            \expandafter\@gobble\slnc@processnotecolumns
          }%
        \endgroup
        \edef\slnc@cmp@value{\the\value{slncpage}}%
        \let\reserved@a\z@
      }{%
        \edef\reserved@a{%
          \@nameuse{r@notecolumn.\theslnc@clearnote@label}\@empty\@empty
        }%
        \edef\slnc@cmp@value{\expandafter\slnc@firstof\reserved@a\@nil}%
        \edef\reserved@a{\expandafter\slnc@secondof\reserved@a\@nil}%
      }%
      \ifcase \reserved@a\relax
%    \end{macrocode}
% Next we read all notes until the end of the current page, but only
% if a \Macro{clearpage} wouldn't result in a new page.
%    \begin{macrocode}
        \ifvmode
          \ifdim \pagetotal<\topskip
          \else
            \slnc@readnotes{\slnc@cmp@value}%
          \fi
        \else
          \slnc@readnotes{\slnc@cmp@value}%
        \fi
        \begingroup
          \aftergroup\@tempswafalse
          \long\def\slnc@note##1##2##3##4{%
            \ifnum ##2>\slnc@cmp@value\relax \else \aftergroup\@tempswatrue\fi
          }%
          \let\slnc@sync\slnc@note
          \def\@elt##1{\csname slnc@##1@unprocessed\endcsname}%
          \slnc@processnotecolumns
        \endgroup
      \else
        \PackageInfo{scrlayer-notecolumn}{%
          box of at least one note column\MessageBreak
          not empty after page of \string\clearnotecolumns}%
        \@tempswatrue
      \fi
      \if@tempswa
%    \end{macrocode}
% Yes, we have!
%    \begin{macrocode}
        \IfLayerPageStyleExists{\currentpagestyle}{}{%
          \PackageWarning{scrlayer-notecolumn}{%
            \string\clearnotecolumns\space while active non-layer page
            style.\MessageBreak
            Activate empty page style until note column\MessageBreak
            has been cleared%
          }%
          \pagestyle{empty}%
        }%
        \@tempswatrue
      \fi
      \@whilesw\if@tempswa\fi{%
%    \end{macrocode}
% Yes, we have (maybe again)!
%    \begin{macrocode}
        \clearpage
        \begingroup
          \def\@elt##1{+\slnc@voidtest{##1}}%
          \ifcase \numexpr \slnc@processnotecolumns\relax
            \aftergroup\@tempswafalse
            \long\def\slnc@note##1##2##3##4{%
              \ifnum ##2>\slnc@cmp@value\relax \else \aftergroup\@tempswatrue\fi
            }%
            \let\slnc@sync\slnc@note
            \def\@elt##1{\csname slnc@##1@unprocessed\endcsname}%
            \slnc@processnotecolumns
          \else
            \aftergroup\@tempswatrue
          \fi
        \endgroup
        \if@tempswa
%    \end{macrocode}
% And we still have: So we have to output one more page.
%    \begin{macrocode}
          \null
        \fi
      }%
    \endgroup
  }%
}
%</body>
%    \end{macrocode}
% \end{macro}^^A \clearnotecolumns
%
%
% \section{Syncronisation of Text and Note}
% \label{sec:scrlayer-notecolumn.sync}
%
% Until yet we have the text and we have note columns. Normally note entries
% to a note column are in sync with the text position, that makes the
% note. But if there are collisions the sync may be lost. In this case the
% note may be later (but never earlier), so we need a mechanism to force
% synchronisation of the text with the note.
%
% \begin{macro}{\syncwithnotecolumn}
%   \begin{description}
%   \item[\OParameter{string}:] the name of the note column to sync with (this
%     must be fully expandable and expand to the name of a note column). By
%     default sync with note column \PValue{marginpar}.
%   \end{description}
% Add at the \LaTeX{} run after the next \LaTeX{} run as much space to the
% text (not the note column!) as needed to reach the next position at the
% note column. This is not the same like \Macro{clearnotecolumn}, because it
% doesn't need to go to the next page, but it needs at least three \LaTeX{}
% runs to terminate.
%    \begin{macrocode}
%<*body>
\scrlayerAddToInterface{\c@slnc@syncpoint}{%
  \newcounter{slnc@syncpoint}%
}
\scrlayerAddToInterface{\syncwithnotecolumn}{%
  \newcommand*{\syncwithnotecolumn}[1][marginpar]{%
    \begingroup
      \edef\reserved@a{\endgroup\noexpand\syncwithnotecolumns[{#1}]}%
    \reserved@a
  }%
}
\scrlayerAddToInterface{\syncwithnotecolumns}{%
  \newcommand*{\syncwithnotecolumns}[1][\relax]{%
    \begingroup
      \ifx\relax#1\relax\else
        \let\slnc@processnotecolumns\@empty
        \edef\reserved@a{#1}%
        \expandafter\@for\expandafter\reserved@a\expandafter:\expandafter=%
        \reserved@a\do {%
          \ifx\reserved@a\@empty\else
            \expandafter\l@addto@macro\expandafter\slnc@processnotecolumns
            \expandafter{\expandafter\@elt\expandafter{\reserved@a}}%
          \fi
        }%
      \fi
      \stepcounter{slnc@syncpoint}%
      \def\@elt##1{%
        \addtocontents{slnc}{%
          \string\slnc@sync{##1}%
                           {\noexpand\number\value{slncpage}}%
                           {\theslnc@syncpoint}%
                           {}%
        }%
      }%
      \slnc@processnotecolumns
      \ifvmode
        \let\slnc@voffset\@empty%
        \expandafter\@firstofone
      \else
        \PackageWarning{scrlayer-notecolumn}{%
          \string\syncwithnotecolumn\space in hmode.\MessageBreak
          Using \string\syncwithnotecolumn\space in horizontal\MessageBreak
          mode may result in unwanted vertical\MessageBreak
          space inside paragraphs and may lost\MessageBreak
          colours of text of notes. \space So perhaps you\MessageBreak
          should move \string\syncwithnotecolumn\space before\MessageBreak
          or after the paragraph%
        }%
        \let\slnc@voffset\@empty%\def\slnc@voffset{-\number\baselineskip}%
        \expandafter\slnc@vadjust
      \fi
      {%
        \if@filesw
          \pdfsavepos
          \protected@write\@auxout{}{%
            \string\newlabel{notecolumn.\theslnc@syncpoint.synctext.label}{%
              {%
                \noexpand\number
                \numexpr \pdflastypos\slnc@voffset\relax
              }{\thepage}%
            }%
          }%
        \fi
        \@ifundefined{r@notecolumn.\theslnc@syncpoint.synctext.label}{%
          \PackageInfo{scrlayer-notecolumn}{%
            No text label for \string\syncwithnotecolumn.\MessageBreak
            Need rerun to sync position}%
        }{%
          \edef\reserved@a{%
            \@nameuse{r@notecolumn.\theslnc@syncpoint.synctext.label}%
            \@empty\@empty
          }%
          \edef\slnc@textpos{\expandafter\slnc@firstof\reserved@a\@nil}%
          \edef\slnc@textpage{\expandafter\slnc@secondof\reserved@a\@nil}%
          \let\slnc@notepos\slnc@textpos
          \let\slnc@notepage\slnc@textpage
          \def\@elt##1{%
            \@ifundefined{r@notecolumn.##1.\theslnc@syncpoint.syncnote.label}{%
              \PackageInfo{scrlayer-notecolumn}{%
                No note label for sync with note column\MessageBreak
                `##1'.\MessageBreak
                Need rerun to sync position}%
              \G@refundefinedtrue
            }{%
              \edef\reserved@a{%
                \@nameuse{r@notecolumn.##1.\theslnc@syncpoint.syncnote.label}%
                \@empty\@empty
              }%
              \edef\reserved@b{\expandafter\slnc@firstof\reserved@a\@nil}%
              \edef\reserved@c{\expandafter\slnc@secondof\reserved@a\@nil}%
              \ifnum \slnc@notepage<\reserved@c\relax
                \let\slnc@notepos=\reserved@b
                \let\slnc@notepage=\reserved@c
              \else
                \ifnum \slnc@notepage=\reserved@c\relax
                  \ifnum \slnc@notepos>\reserved@b
                    \let\slnc@notepos=\reserved@b
                    \let\slnc@notepage=\reserved@c
                  \fi
                \fi
              \fi
            }%
          }%
          \slnc@processnotecolumns
          \ifnum\slnc@textpage>\slnc@notepage\relax
            \PackageInfo{scrlayer-notecolumn}{%
              Last note page before last text page.\MessageBreak
              Need rerun to sync position}%
          \else
            \ifnum\slnc@textpage<\slnc@notepage\relax
             \@whilenum \slnc@textpage<\slnc@notepage\do {%
               \newpage\null\vskip-\dimexpr \baselineskip+\parskip\relax
                \edef\slnc@textpage{\the\numexpr\slnc@textpage+1\relax}%
              }%
              \scr@ifundefinedorrelax{pdfpageheight}{%
                \@tempdima=\paperheight
              }{%
                \@tempdima=\pdfpageheight
              }%
              \@tempdima=\dimexpr \@tempdima
                                 -\topmargin-1in
                                 -\headheight-\headsep
                                 -\topskip+\baselineskip
                                 \relax
              \edef\slnc@textpos{\number\@tempdima}%
%<*trace>
              \PackageInfo{scrlayer-notecolumn}{%
                Top position is \slnc@textpos%
              }%
%</trace>
            \fi
            \ifnum\slnc@notepos>\slnc@textpos\relax
              \PackageInfo{scrlayer-notecolumn}{%
                Last note position before last text\MessageBreak
                position.\MessageBreak
                Need rerun to sync position%
              }%
            \else
              \ifnum\slnc@notepos<\slnc@textpos\relax
                \@tempdima=\numexpr \slnc@textpos-\slnc@notepos\relax sp
                \PackageInfo{scrlayer-notecolumn}{%
                  skipping \the\@tempdima\space to sync%
                }%
                \vskip\@tempdima
              \fi
            \fi
          \fi
        }%
      }%
    \endgroup
  }%
}
%    \end{macrocode}
% \begin{macro}{\slnc@vadjust}
%    \begin{macrocode}
\scrlayerAddToInterface\slnc@vadjust{%
  \newcommand{\slnc@vadjust}[1]{%
    \@bsphack
    \vadjust{#1}%
    \@esphack
  }%
}
%</body>
%    \end{macrocode}
% \end{macro}^^A \slnc@vadjust
% \end{macro}^^A \syncwithnotecolumn
% 
%
% \iffalse^^A meta-comment
%</interface>
% \fi^^A meta-comment
%
% \Finale
% \let\subsection\section
% \let\section\chapter
% \let\chapter\restorechapter
%
\endinput
%
% end of file `scrlayer-notecolumn.dtx'

%%% Local Variables:
%%% mode: doctex
%%% mode: flyspell
%%% ispell-local-dictionary: "en_GB"
%%% TeX-master: t
%%% End:
