% ======================================================================
% scrlayer.tex
% Copyright (c) Markus Kohm, 2013
%
% This file is part of the LaTeX2e KOMA-Script bundle.
%
% This work may be distributed and/or modified under the conditions of
% the LaTeX Project Public License, version 1.3c of the license.
% The latest version of this license is in
%   http://www.latex-project.org/lppl.txt
% and version 1.3c or later is part of all distributions of LaTeX 
% version 2005/12/01 or later and of this work.
%
% This work has the LPPL maintenance status "author-maintained".
%
% The Current Maintainer and author of this work is Markus Kohm.
%
% This work consists of all files listed in manifest.txt.
% ----------------------------------------------------------------------
% scrlayer.tex
% Copyright (c) Markus Kohm, 2013
%
% Dieses Werk darf nach den Bedingungen der LaTeX Project Public Lizenz,
% Version 1.3c, verteilt und/oder veraendert werden.
% Die neuste Version dieser Lizenz ist
%   http://www.latex-project.org/lppl.txt
% und Version 1.3c ist Teil aller Verteilungen von LaTeX
% Version 2005/12/01 oder spaeter und dieses Werks.
%
% Dieses Werk hat den LPPL-Verwaltungs-Status "author-maintained"
% (allein durch den Autor verwaltet).
%
% Der Aktuelle Verwalter und Autor dieses Werkes ist Markus Kohm.
% 
% Dieses Werk besteht aus den in manifest.txt aufgefuehrten Dateien.
% ======================================================================
%
% Chapter about scrlayer of the KOMA-Script guide
% Maintained by Markus Kohm
%
% ----------------------------------------------------------------------
%
% Kapitel über scrlayer in der KOMA-Script-Anleitung
% Verwaltet von Markus Kohm
%
% ============================================================================

\KOMAProvidesFile{scrlayer.tex}
                 [$Date: 2013-12-10 19:50:34 +0100 (Di, 10. Dez 2013) $
                  KOMA-Script guide (chapter:scrlayer)]

\chapter[{Definition von Ebenen und Seitenstilen mit \Package{scrlayer}}]
  {Definition\ChangedAt{v3.12}{\Package{scrlayer}} von Ebenen und Seitenstilen
    mit \Package{scrlayer}}
\labelbase{scrlayer}

\BeginIndex{Package}{scrlayer}

Anwender von Grafikprogrammen sind mit dem Modell der Ebenen für eine Seite
bereits vertraut. \LaTeX{} selbst ist ein solches Modell jedoch eher
fremd. Dennoch gibt es bereits einige Pakete wie \Package{eso-pic} oder
\Package{textpos}, mit denen bereits eine Art Hintergrund- oder
Vor\-der\-grund\-ebe\-ne in \LaTeX{} verfügbar gemacht wurden. Das Paket
\Package{scrlayer} ist ein weiteres Paket, das solche Hintergrund- und
Vordergrundebenen zur Verfügung stellt. Im Unterschied zu den anderen
genannten Paketen sind die Ebenen bei \Package{scrlayer} jedoch Teil des
Seitenstils. Dadurch ist eine einfache Umschaltung zwischen der Verwendung
unterschiedlicher Ebenen durch die Umschaltung des Seitenstils möglich.

Um dies zu erreichen, stellt das Paket auf unterer Stufe zusätzlich eine
Schnittstelle zur Definition von Seitenstilen, die auf einem Stapel oder einer
Liste von Ebenen beruhen, zum Hinzufügen von Ebenen wahlweise am Anfang oder
Ende einer solchen Liste von Ebenen oder unmittelbar vor oder hinter einer
anderen Ebene in einer solchen Liste, zum Löschen einer Ebene aus einer
solchen Liste und zum Löschen aller Dubletten einer Ebene aus einer solchen
Liste bereit. Oder kurz und verständlich gesagt: Die Seitenstil-Schnittstelle
von \Package{scrlayer} stellt Befehle bereit, um einen Seitenstil, der auf
einer Liste von Ebenen basiert, zu definieren und diese Ebenenliste zu
verwalten.

Nichtsdestoweniger wird die direkte Verwendung der Ebenen nur erfahrenen
Anwendern empfohlen. Schnittstellen für Anfänger und durchschnittliche
Anwender werden als zusätzliche Pakete angeboten, die dann ihrerseits
\Package{scrlayer} laden. Siehe hierzu \autoref{cha:scrlayer-scrpage} in
\autoref{part:forAuthors} diese\iffree{r Anleitung}{s Buches}.


\section{Hinweis zum Entwicklungsstand}
\label{sec:scrlayer.draft}

Die Entwicklung dieses Pakets ist noch nicht abgeschlossen. Teile des Pakets
sind auch noch als experimentell einzustufen. Daher können sich in Zukunft
insbesondere die internen Funktionalitäten und Funktionsweisen noch ändern. Es
ist auch noch mit Erweiterungen zu rechnen. Wegen dieses noch nicht
abgeschlossenen Entwicklungsstandes sollte der Leser auch keine abgeschlossene
Anleitung erwarten. Dennoch gibt diese Anleitung, die sich vor allem an
erfahrene Anwender und Entwickler richtet, den aktuellen Entwicklungsstand der
Teile von \Package{scrlayer} wieder, die als zur Verwendung freigegeben
eingestuft sind. Dinge, die hier nicht dokumentiert sind, sollten allenfalls
zu Testzwecken Verwendung finden.

\LoadCommon{0} % \section{Frühe oder späte Optionenwahl}

\section{Einige grundlegende Informationen}
\label{sec:scrlayer.generic.information}

Das Paket benötigt einige grundlegende Informationen über die
verwendete Klasse. Autoren von Klassen können \Package{scrlayer} helfen, indem
sie entsprechende Angaben machen. Anderenfalls versucht das Paket diese
Informationen selbst zu ermitteln. Das funktioniert beispielsweise für die
Standardklassen oder für die \KOMAScript-Klassen. Mit anderen Klassen kann es
funktionieren oder auch ganz oder teilweise fehlschlagen.

Dieser Abschnitt beschreibt einige der Informationen, die Autoren von Klassen
bereitstellen können. Anwender sollten sich im Normalfall nicht darum zu
kümmern brauchen.

\begin{Declaration}
  \Macro{if@chapter}\ \PName{Dann-Code} \Macro{else}\ \PName{Sonst-Code}
  \Macro{fi}
\end{Declaration}
\BeginIndex{Cmd}{if@chapter}%
Wenn \Macro{if@chapter} definiert ist und \Macro{iftrue}\IndexCmd{iftrue}
entspricht, wird \Package{scrlayer} bei seiner Arbeit die Kapitel-Ebene
beispielsweise bei Option \Option{automark} mit berücksichtigen. Wenn es
definiert ist, aber nicht \Macro{iftrue} entspricht, behandelt
\Package{scrlayer} nur die Ebenen der Befehle \Macro{part}, \Macro{section},
\Macro{subsection}, \Macro{sub\dots subsection}, \Macro{paragraph},
\Macro{subparagraph}, \Macro{sub\dots subparagraph}. Wenn das Makro nicht
definiert ist, macht \Package{scrlayer} die Frage, ob auch die
Kapitel-Ebene zu behandeln ist, an der Anweisung \Macro{chapter} fest. Ist
diese Anweisung definiert und entspricht sie nicht \Macro{relax}, dann
definiert \Package{scrlayer} das Makro \Macro{if@chapter} selbst als Synonym für
\Macro{iftrue}. Anderenfalls definiert es \Macro{if@chapter} als Synonym für
\Macro{iffalse}\IndexCmd{iffalse}.%
%
\EndIndex{Cmd}{if@chapter}%

\begin{Declaration}
  \Macro{if@mainmatter}\ \PName{Dann-Code} \Macro{else}\ \PName{Sonst-Code}
  \Macro{fi}
\end{Declaration}
\BeginIndex{Cmd}{if@mainmatter}%
Klassen wie \Class{book} definieren \Macro{frontmatter}\IndexCmd{frontmatter},
\Macro{mainmatter}\IndexCmd{mainmatter} und
\Macro{backmatter}\IndexCmd{backmatter}, um zwischen Vorderteil, Hauptteil und
Endteil eines Buches umschalten zu können. In der Regel verwenden diese Klassen
intern \Macro{if@mainmatter}, um entscheiden zu können, ob gerade im Hauptteil
des Dokuments gearbeitet wird oder nicht. Klassen wie \Class{report} oder
\Class{article} haben kein \Macro{frontmatter}, \Macro{mainmatter} oder
\Macro{backmatter} und deshalb auch kein \Macro{if@mainmatter}. Stattdessen
gehen sie davon aus, dass es nur einen Hauptteil gibt.

Für \Package{scrlayer} ist es aber einfacher, nicht ständig erneut die
Existenz und Verwendung der Umschaltanweisungen zu erkennen und damit zu
entscheiden, ob nun gerade im Hauptteil gearbeitet wird oder nicht, sondern
stattdessen auch bei Klassen wie \Class{report} oder \Class{article} mit
\Macro{if@mainmatter} zu arbeiten. Das sollte bei den genannten Klassen dann
schlicht \Macro{iftrue}\IndexCmd{iftrue} entsprechen. Wenn also
\Macro{if@mainmatter} nicht definiert ist, dann definiert \Package{scrlayer}
es als Synonym für \Macro{iftrue}.

Einige Klassen haben jedoch tatsächlich \Macro{frontmatter},
\Macro{mainmatter} oder \Macro{backmatter} und trotzdem kein
\Macro{if@mainmatter}. In diesem Fall definiert \Package{scrlayer} ebenfalls
\Macro{if@mainmatter} als Synonym für \Macro{iftrue} und erweitert
die gefundenen Definitionen von \Macro{frontmatter}, \Macro{mainmatter} und
\Macro{backmatter} so, dass diese \Macro{if@mainmatter} passend
umdefinieren. Falls es jedoch weitere, vergleichbare Befehle zur Umschaltung
zwischen unterschiedlichen Dokumentteilen gibt, so kennt \Package{scrlayer}
diese nicht, testet nicht auf diese und erweitert sie daher auch nicht
passend. In diesem Fall ist \Package{scrlayer} also auf die Mitarbeit des
Klassenautors angewiesen.%
\EndIndex{Cmd}{if@mainmatter}%

\begin{Declaration}
  \Macro{DeclareSectionNumberDepth}%
  \Parameter{Name der Gliederungsebene}\Parameter{Tiefe der Gliederungsebene}
\end{Declaration}
\BeginIndex{Cmd}{DeclareSectionNumberDepth}%
Jeder Gliederungsebene ist normalerweise eine nummerische Tiefe
zugeordnet. Das ist notwendig, damit \LaTeX{} die Hierarchie der
Gliederungsebenen verwalten kann. Allerdings sind die Werte normalerweise nur
der jeweiligen Klasse bekannt, in der die Gliederungsbefehle definiert
sind. Diese setzt dann in den entsprechenden \LaTeX-Befehlen selbst die
zugehörigen Nummern ein.

Das Paket \Package{scrlayer} benötigt ebenfalls Informationen über die
Hierarchie. Mit Hilfe der Anweisung \Macro{DeclareSectionNumberDepth} kann
\Package{scrlayer} zum Namen einer Gliederungsebene die zugehörige nummerische
Tiefe bekannt gemacht werden. Für die Standardklassen wäre \Parameter{Name der
  Gliederungsebene} beispielsweise \PValue{part}, \PValue{chapter},
\PValue{section}, \PValue{subsection}, \PValue{subsubsection},
\PValue{paragraph} oder \PValue{subparagraph} und die jeweils zugehörige
\PName{Tiefe der Gliederungsebene} wäre -1, 0, 1, 2, 3, 4 oder 5.

Das Paket \Package{scrlayer} versucht diese nummerischen Werte zunächst beim
Laden des Pakets und dann noch einmal während
\Macro{begin}\PParameter{document} selbst zu ermitteln. Aber für den Fall,
dass dies einmal nicht zu einem korrekten Ergebnis führt, beispielsweise falls
es vollkommen andere Gliederungsbefehle gibt, kann man die Zuordnung eben mit
\Macro{DeclareSectionNumberDepth} auch explizit vornehmen.%
%
\EndIndex{Cmd}{DeclareSectionNumberDepth}%

\section{Deklaration von Ebenen}
\label{sec:scrlayer.layers}

Eine Ebene (engl. \emph{layer}) ist ein Denkmodell für eine Seite. Im
Gegensatz zu echtem, physischem Papier, ist diese Seite vollständig
transparent. Üblicherweise werden mehrere Ebenen übereinander gestapelt und
undurchsichtiges Material auf einer Ebene überdeckt Material auf den Ebenen
darunter. Ein solcher Stapel von Ebenen wird dann auf eine reale Seite Papier
abgebildet. Das Paket \Package{scrlayer} stellt zwei solche Stapel für jede
Seite zur Verfügung: einen Hintergrundstapel und einen Vordergrundstapel. Der
Hintergrundstapel befindet sich unter oder hinter dem normalen Seiteninhalt,
während der Vordergrundstapel über oder vor dem normalen Seiteninhalt
ausgegeben wird. Der normale Seiteninhalt ist daher eine Art von Trennebene
zwischen den beiden Ebenenstapeln.

Eine Ebene hat mehrere Eigenschaften. Die erste Eigenschaft ist Antwort auf
die Frage, ob die Ebene zum Hintergrund oder zum Vordergrund
gehört. Hintergrundebenen werden ausgegeben, bevor der normale Inhalt der
Seite gedruckt wird. Optisch erscheinen sie daher \emph{hinter} oder
\emph{unter} dem normalen Inhalt der Seite.  Vordergrundebenen werden an den
normalen Inhalt anschließend ausgegeben. Optisch erscheinen sie daher
\emph{vor}, \emph{auf} oder \emph{über} dem normalen Inhalt der Seite. In der
Voreinstellung ist eine Ebene sowohl eine Hintergrundebene als auch eine
Vordergrundebene und wird daher zweimal ausgegeben.

Die zweite und dritte Eigenschaft sind die horizontale und vertikale Position
der Ebene. Die vierte und fünfte Eigenschaft sind die horizontale und
vertikale Größe der Ebene. Daraus ergibt sich, dass eine Ebene auch kleiner
oder größer als das Papier sein kann.

Aber wie werden die horizontale und die vertikale Position gemessen? Aus der
Antwort ergibt sich die sechste Eigenschaft, die Ausrichtung. Man kann von der
linken Papierkante zur linken Kante der Ebene, zur Mitte der Ebene oder zur
rechten Kante der Ebene messen. Entsprechend kann man von der oberen Kante des
Papiers zur oberen Kante der Ebene, zur Mitte der Ebene oder zur unteren Kante
der Ebene messen.

Die siebte Eigenschaft ist, ob eine Ebene auf linken oder rechten Seiten eines
Dokuments gedruckt werden soll. In der Voreinstellung wird eine Ebene auf
allen Seiten gedruckt. Es ist zu beachten, dass \LaTeX{} Seiten mit geraden
Seitenzahlen als linke Seiten und Seiten mit ungeraden Seitenzahlen als rechte
Seiten behandelt, dass es jedoch im einseitigen Modus unabhängig von der
Nummer nur rechte Seiten gibt. \LaTeX{} bezeichnet den Gepflogenheiten in der
englischen Sprache entsprechend linke Seiten auch als gerade Seiten und rechte
Seiten als ungerade Seiten.

Die achte Eigenschaft ist, ob eine Ebene auf den einseitigen oder den
doppelseitigen Modus beschränkt sein soll. In der Voreinstellung ist die Ebene
diesbezüglich unbeschränkt, wird also sowohl im einseitigen als auch im
doppelseitigen Modus ausgegeben. Nichtsdestotrotz wird eine Ebene, die auf
gerade Seiten beschränkt ist, im einseitigen Modus niemals ausgegeben werden
und ist daher auch keine einseitige Ebene.

Die neunte Eigenschaft ist, ob eine Ebene auf Gleitseiten oder auf
Normalseiten beschränkt ist. \LaTeX{} erzeugt Gleitseiten für Objekte aus
Umgebungen wie \Environment{table} oder \Environment{figure}, wenn diesen
erlaubt wurde, auf eigenen Seiten ohne Teile des normalen Dokumentinhalts
ausgegeben zu werden (siehe Option \PValue{p} für \Environment{table} oder
\Environment{figure}). In gewisser Weise ist es so der gesamten Seite erlaubt,
im Dokument zu gleiten. Normalseiten in diesem Sinne sind alle Seiten, die
keine Gleitseiten sind. Normalseiten können ebenfalls Gleitumgebungen am
Anfang, im Inneren oder am Ende enthalten. Sehr große Gleitumgebungen können
auch den Eindruck einer Gleitseite erzeugen, obwohl es sich bei ihnen in
Wirklichkeit um oben auf einer Normalseite platzierte Gleitumgebungen handelt.

Die zehnte und letzte Eigenschaft ist der Inhalt der Ebene. Das ist schlicht
das, was gedruckt werden soll, wann immer die Ebene ausgegeben wird.

Damit haben wir also zehn Eigenschaften. Später in dieser Anleitung werden wir
weitere Eigenschaften sehen, die jedoch auf diese zehn Eigenschaften
abgebildet werden können. Daher nennen wir diese zehn Eigenschaften die
primären Eigenschaften.

\begin{Declaration}
  \Macro{DeclareLayer}\OParameter{Optionenliste}\Parameter{Name der Ebene}\\
  \Macro{DeclareNewLayer}\OParameter{Optionenliste}\Parameter{Name der Ebene}\\
  \Macro{ProvideLayer}\OParameter{Optionenliste}\Parameter{Name der Ebene}\\
  \Macro{RedeclareLayer}\OParameter{Optionenliste}\Parameter{Name der Ebene}\\
  \Macro{ModifyLayer}\OParameter{Optionenliste}\Parameter{Name der Ebene}
\end{Declaration}
\BeginIndex{Cmd}{DeclareLayer}%
\BeginIndex{Cmd}{DeclareNewLayer}%
\BeginIndex{Cmd}{ProvideLayer}%
\BeginIndex{Cmd}{RedeclareLayer}%
\BeginIndex{Cmd}{ModifyLayer}%
Diese Anweisungen können verwendet werden, um Ebenen zu definieren. Der
\PName{Name der Ebene} muss voll expandierbar sein. Die Expansion sollte in
ASCII-Buchstaben resultieren. Einige zusätzliche Zeichen werden ebenfalls
akzeptiert, ihre Verwendung wird jedoch nicht empfohlen.

Dabei spielt es bei Verwendung von \Macro{DeclareLayer} keine Rolle, ob eine
Ebene \PName{Name der Ebene} bereits existiert oder nicht. Sie wird in jedem
Fall mit den über die \PName{Optionenliste} angegebenen Eigenschaften
definiert. Einzelne Optionen bestehen entweder nur aus einem Schlüssel oder
aus einem Schlüssel, gefolgt von einem Gleichheitszeichen und einem Wert. Die
Optionen sind durch Komma voneinander getrennt. Um innerhalb der Werte einer
Option ein Komma oder ein Leerzeichen verwenden zu können, muss der
entsprechende Wert in geschweifte Klammern gesetzt werden.  Eine Übersicht
über die Optionen und die Eigenschaften, die sie repräsentieren, findet sich
in \autoref{tab:scrlayer.layerkeys}.

Im Unterschied zu \Macro{DeclareLayer} meldet \Macro{DeclareNewLayer} einen
Fehler, falls eine Ebene mit dem angegebenen Namen bereits existiert. Damit
wird der Anwender davor bewahrt, versehentlich mehrmals denselben Namen zu
verwenden. Dies ist insbesondere auch dann nützlich, wenn Klassen oder Pakete
intern ebenfalls Ebenen definieren.

Dagegen definiert \Macro{ProvideLayer} die Ebene nur, wenn nicht bereits eine
Ebene mit dem angegebenen Namen existiert. Ist der Name hingegen bereits für
eine andere Ebene verwendet, so wird die neuerliche Definition ignoriert. Die
Anweisung hat also die Bedeutung: \emph{Definiere die Ebene, falls sie noch
  nicht existiert.}

Soll eine bereits existierende Ebene umdefiniert werden, so kann wahlweise
\Macro{RedeclareLayer} oder \Macro{ModifyLayer} verwendet werden. Während mit
\Macro{RedeclareLayer} die Ebene zunächst auf die Grundeinstellungen
zurückgesetzt und damit über die angegebene \PName{Optionenliste} komplett neu
definiert wird, unterbleibt bei \Macro{ModifyLayer} das Zurücksetzen. Es
werden dann nur die Eigenschaften geändert, für die in der
\PName{Optionenliste} auch Angaben vorhanden sind. Die Anwendung auf eine
zuvor noch nicht definierte Ebene stellt bei beiden Anweisungen einen Fehler
dar.

\begin{desclist}
  \desccaption{%
    Optionen für die Definition von Seiten-Ebenen mit ihrer jeweiligen
    Bedeutung als Ebenen-Eigenschaft\label{tab:scrlayer.layerkeys}%
  }{%
    Optionen für die Definition von Ebenen (\emph{Fortsetzung})%
  }%
  \nentry{\KOption{align}\PName{Ausrichtungszeichen}}{%
    Über die \PName{Ausrichtungszeichen} wird die gewünschte Ausrichtung der
    Ebene bestimmt. Dabei steht jedes einzelne \PName{Ausrichtungszeichen} für
    eine mögliche Anwendung der Werte \PName{Abstand} der Optionen
    \Option{hoffset} oder \Option{voffset}. Mehrere
    \PName{Ausrichtungszeichen} können ohne Leerzeichen oder Komma direkt
    hintereinander geschrieben werden und werden in der Reihenfolge ihres
    Auftretens ausgewertet. Makros sind im Wert der Option jedoch
    nicht zulässig. Zulässige \PName{Ausrichtungszeichen} sind:
    \begin{description}
    \item[\PValue{b} --] der Wert der Option \Option{voffset} ist der Abstand
      der Unterkante der Ebene von der Oberkante des Papiers.
    \item[\PValue{c} --] die Werte der Optionen \Option{hoffset} und
      \Option{voffset} sind die Abstände des Zentrums der Ebene von der linken
      und der oberen Kante des Papiers.
    \item[\PValue{l} --] der Wert der Option \Option{hoffset} ist der Abstand
      der linken Kante der Ebene von der linken Kante des Papiers.
    \item[\PValue{r} --] der Wert der Option \Option{hoffset} ist der Abstand
      der rechten Kante der Ebene von der linken Kante des Papiers.
    \item[\PValue{t} --] der Wert der Option \Option{voffset} ist der Abstand
      der Oberkante der Ebene von der Oberkante des Papiers.
    \end{description}
  }%
  \entry{\KOption{area}\Parameter{horizontaler Abstand}\Parameter{vertikaler
      Abstand}\Parameter{Breite}\Parameter{Höhe}}{%
    Die zusammengesetzte Eigenschaft, resultiert in den primären Eigenschaften
    \KOption{hoffset}\PName{horizontaler Abstand},
    \KOption{voffset}\PName{vertikaler Abstand},
    \KOption{width}\PName{Breite}, \KOption{height}\PName{Höhe}.%
  }%
  \entry{\Option{background}}{%
    Mit dieser Option wird die Ebene zu einer reinen Hintergrundebene. Sie
    wird also im Gegensatz zur Grundeinstellung nicht mehr gleichzeitig im
    Hintergrund und im Vordergrund, sondern nur noch im Hintergrund
    ausgegeben. Diese Option erwartet und erlaubt keinen Wert.%
  }%
  \entry{\Option{bottommargin}}{%
    Die zusammengesetzte Eigenschaft setzt die primären Eigenschaften
    \Option{hoffset}, \Option{voffset}, \Option{width}, \Option{height} und
    \Option{align} so, dass die Ebene horizontal von der linken Kante bis zur
    rechten Kante des Papiers reicht und vertikal den gesamten Bereich unter
    dem Seitenfuß bis zur unteren Papierkante abdeckt. Diese Option erwartet
    und erlaubt keinen Wert.%
  }%
  \entry{\KOption{clone}\PName{Name einer Ebene}}{%
    Die zusammengesetzte Eigenschaft setzt alle primären Eigenschaften
    entsprechend der aktuellen, primären Eigenschaften der Ebene mit dem
    angegebenen \PName{Name einer Ebene}. Es ist zu beachten, dass \PName{Name
      einer Ebene} voll expandierbar sein muss und zu Buchstaben expandieren
    sollte. Einige weitere Zeichen werden toleriert, ihre Verwendung wird
    jedoch nicht empfohlen! Die Ebene mit dem angegebenen \PName{Name einer
      Ebene} muss außerdem bereits existieren.%
  }%
  \entry{\KOption{contents}\PName{Code}}{%
    Der angegebene \PName{Code} wird immer dann expandiert und ausgeführt,
    wenn die Ebene ausgegeben wird. Damit definiert \PName{Code} das, was auf
    der Ebene zu sehen ist. Es werden keine Tests durchgeführt, ob
    \PName{Code} gültig und korrekt ist. Fehler in \PName{Code} können daher
    zu verschiedenen Fehlermeldungen auf jeder Seite führen, auf der die Ebene
    ausgegeben wird.%
  }%
  \entry{\Option{evenpage}}{%
    Mit dieser Option wird die Ebene zu einer Ebene für linke Seiten. Sie wird
    also im Gegensatz zur Grundeinstellung nicht mehr sowohl auf linken als
    auch auf rechten Seiten ausgegeben. Da es linke Seiten nur im
    doppelseitigen Satz gibt, schließt diese Eigenschaft quasi
    \Option{twoside} mit ein. Diese Option erwartet und erlaubt keinen Wert.%
  }%
  \entry{\Option{floatpage}}{%
    Mit dieser Option wird die Ebene zu einer Gleitseitenebene. Sie wird also
    im Gegensatz zur Grundeinstellung nicht mehr auf allen Seiten, sondern nur
    noch auf Gleitseiten ausgegeben. Näheres zu Gleitseiten ist der Einleitung
    zu diesem Abschnitt zu entnehmen. Diese Option erwartet und erlaubt keinen
    Wert.%
  }%
  \entry{\Option{foot}}{%
    Die zusammengesetzte Eigenschaft setzt die primären Eigenschaften
    \Option{hoffset}, \Option{voffset}, \Option{width}, \Option{height} und
    \Option{align} so, dass die Ebene den Seitenfuß in der Breite des
    Textbereichs überdeckt. Diese Option erwartet und erlaubt keinen Wert.%
  }%
  \entry{\Option{footskip}}{%
    Die zusammengesetzte Eigenschaft setzt die primären Eigenschaften
    \Option{hoffset}, \Option{voffset}, \Option{width}, \Option{height} und
    \Option{align} so, dass die Ebene vertikal den Bereich zwischen dem
    Textbereich und dem Seitenfuß in Breite des Textbereichs überdeckt. Es ist
    zu beachten, dass die Höhe dieses Bereichs zwar von der Länge
    \Length{footskip} abhängt, dieser jedoch nicht entspricht. Diese Option
    erwartet und erlaubt keinen Wert.%
  }%
  \entry{\Option{foreground}}{%
    Mit dieser Option wird die Ebene zu einer reinen Vodergrundebene. Sie wird
    also im Gegensatz zur Grundeinstellung nicht mehr gleichzeitig im
    Hintergrund und im Vordergrund, sondern nur noch im Vordergrund
    ausgegeben. Diese Option erwartet und erlaubt keinen Wert.%
  }%
  \entry{\Option{head}}{%
    Die zusammengesetzte Eigenschaft setzt die primären Eigenschaften
    \Option{hoffset}, \Option{voffset}, \Option{width}, \Option{height} und
    \Option{align} so, dass die Ebene den Seitenkopf in der Breite des
    Textbereichs überdeckt. Diese Option erwartet und erlaubt keinen Wert.%
  }%
  \entry{\Option{headsep}}{%
    Die zusammengesetzte Eigenschaft setzt die primären Eigenschaften
    \Option{hoffset}, \Option{voffset}, \Option{width}, \Option{height} und
    \Option{align} so, dass die Ebene den Abstand zwischen dem Seitenkopf und
    dem Textbereich in der Breite des Textbereichs überdeckt. Ihre Höhe
    entspricht damit der Länge \Length{headsep}. Diese Option erwartet und
    erlaubt keinen Wert.%
  }%
  \entry{\KOption{height}\PName{Höhe}}{%
    Setzt die \PName{Höhe} der Ebene. Beachten Sie, dass \PName{Höhe}
    wahlweise eine \LaTeX-Länge sein kann, die mit \Macro{newlength} definiert
    wurde, eine \TeX-Länge, die mit \Macro{newdimen} oder \Macro{newskip}
    definiert wurde, ein Längenwert wie 10\Unit{pt} oder ein Längenausdruck
    unter Verwendung von +, -, /, *, (, und ). Die genaue Syntax eines
    Längenausdrucks ist \cite[Abschnitt~3.5]{manual:eTeX} zu entnehmen.%
  }%
  \entry{\KOption{hoffset}\PName{Abstand}}{%
    Setzt den \PName{Abstand} der Ebene von der linken Kante des Papiers. Wie
    der \PName{Abstand} gemessen wird, hängt von Eigenschaft \Option{align}
    ab. Beachten Sie, dass \PName{Abstand} wahlweise eine \LaTeX-Länge sein
    kann, die mit \Macro{newlength} definiert wurde, eine \TeX-Länge, die mit
    \Macro{newdimen} oder \Macro{newskip} definiert wurde, ein Längenwert wie
    10\Unit{pt} oder ein Längenausdruck unter Verwendung von +, -, /, *, (,
    und ). Die genaue Syntax eines Längenausdrucks ist
    \cite[Abschnitt~3.5]{manual:eTeX} zu entnehmen.%
  }%
  \entry{\Option{innermargin}}{%
    Die zusammengesetzte Eigenschaft setzt die primären Eigenschaften
    \Option{hoffset}, \Option{voffset}, \Option{width}, \Option{height} und
    \Option{align} so, dass die Ebene den inneren Rand der Seite von der
    Papieroberkante bis zur Papierunterkante überdeckt. Der innere Rand
    entspricht im einseitigen Satz dem linken Rand. Diese Option erwartet und
    erlaubt keinen Wert.%
  }%
  \entry{\Option{leftmargin}}{%
    Die zusammengesetzte Eigenschaft setzt die primären Eigenschaften
    \Option{hoffset}, \Option{voffset}, \Option{width}, \Option{height} und
    \Option{align} so, dass die Ebene den linken Rand der Seite von der
    Papieroberkante bis zur Papierunterkante überdeckt. Diese Option erwartet
    und erlaubt keinen Wert.%
  }%
  \entry{\Option{nonfloatpage}}{%
    Mit dieser Option wird die Ebene auf Seiten beschränkt, die keine
    Gleitseiten sind. Sie wird also im Gegensatz zur Grundeinstellung nicht
    mehr auf allen Seiten, sondern nur noch auf Nichtgleitseiten
    ausgegeben. Näheres zu Gleitseiten und Nichtgleitseiten ist der Einleitung
    zu diesem Abschnitt zu entnehmen. Diese Option erwartet und erlaubt keinen
    Wert.%
  }%
  \entry{\Option{oddpage}}{%
    Mit dieser Option wird die Ebene zu einer Ebene für rechte Seiten. Sie wird
    also im Gegensatz zur Grundeinstellung nicht mehr sowohl auf linken als
    auch auf rechten Seiten ausgegeben. Es ist zu beachten, dass im
    einseitigen Satz alle Seiten unabhängig von der Seitenzahl rechte Seiten
    sind. Diese Option erwartet und erlaubt keinen Wert.%
  }%
  \entry{\Option{oneside}}{%
    Mit dieser Option wird die Ebene zu einer Ebene für den einseitigen
    Satz. Sie wird also im Gegensatz zur Grundeinstellung nicht mehr sowohl
    im einseitigen als auch im doppelseitigen Satz ausgegeben. Diese Option
    erwartet und erlaubt keinen Wert.%
  }%
  \entry{\Option{outermargin}}{%
    Die zusammengesetzte Eigenschaft setzt die primären Eigenschaften
    \Option{hoffset}, \Option{voffset}, \Option{width}, \Option{height} und
    \Option{align} so, dass die Ebene den äußeren Rand der Seite von der
    Papieroberkante bis zur Papierunterkante überdeckt. Der äußere Rand
    entspricht im einseitigen Satz dem rechten Rand. Diese Option erwartet und
    erlaubt keinen Wert.%
  }%
  \entry{\Option{page}}{%
    Die zusammengesetzte Eigenschaft setzt die primären Eigenschaften
    \Option{hoffset}, \Option{voffset}, \Option{width}, \Option{height} und
    \Option{align} so, dass die Ebene die komplette Seite überdeckt. Diese
    Option erwartet und erlaubt keinen Wert.%
  }%
  \entry{\Option{rightmargin}}{%
    Die zusammengesetzte Eigenschaft setzt die primären Eigenschaften
    \Option{hoffset}, \Option{voffset}, \Option{width}, \Option{height} und
    \Option{align} so, dass die Ebene den rechten Rand der Seite von der
    Papieroberkante bis zur Papierunterkante überdeckt. Diese Option erwartet
    und erlaubt keinen Wert.%
  }%
  \entry{\Option{textarea}}{%
    Die zusammengesetzte Eigenschaft setzt die primären Eigenschaften
    \Option{hoffset}, \Option{voffset}, \Option{width}, \Option{height} und
    \Option{align} so, dass die Ebene den kompletten Textbereich
    überdeckt. Diese Option erwartet und erlaubt keinen Wert.%
  }%
  \entry{\Option{topmargin}}{%
    Die zusammengesetzte Eigenschaft setzt die primären Eigenschaften
    \Option{hoffset}, \Option{voffset}, \Option{width}, \Option{height} und
    \Option{align} so, dass die Ebene den oberen Rand der Seite von der linken
    Kante des Papiers bis zu dessen rechter Kante überdeckt. Diese Option
    erwartet und erlaubt keinen Wert.%
  }%
  \entry{\Option{twoside}}{%
    Mit dieser Option wird die Ebene zu einer Ebene für den doppelseitigen
    Satz. Sie wird also im Gegensatz zur Grundeinstellung nicht mehr sowohl
    im einseitigen als auch im doppelseitigen Satz ausgegeben. Diese Option
    erwartet und erlaubt keinen Wert.%
  }%
  \entry{\KOption{voffset}\PName{Abstand}}{%
    Setzt den \PName{Abstand} der Ebene von der Papieroberkante. Wie der
    \PName{Abstand} gemessen wird, hängt von Eigenschaft \Option{align}
    ab. Beachten Sie, dass \PName{Abstand} wahlweise eine \LaTeX-Länge sein
    kann, die mit \Macro{newlength} definiert wurde, eine \TeX-Länge, die mit
    \Macro{newdimen} oder \Macro{newskip} definiert wurde, ein Längenwert wie
    10\Unit{pt} oder ein Längenausdruck unter Verwendung von +, -, /, *, (,
    und ). Die genaue Syntax eines Längenausdrucks ist
    \cite[Abschnitt~3.5]{manual:eTeX} zu entnehmen.%
  }%
  \entry{\KOption{width}\PName{Breite}}{%
    Setzt die \PName{Breite} der Ebene. Beachten Sie, dass \PName{Breite}
    wahlweise eine \LaTeX-Länge sein kann, die mit \Macro{newlength} definiert
    wurde, eine \TeX-Länge, die mit \Macro{newdimen} oder \Macro{newskip}
    definiert wurde, ein Längenwert wie 10\Unit{pt} oder ein Längenausdruck
    unter Verwendung von +, -, /, *, (, und ). Die genaue Syntax eines
    Längenausdrucks ist \cite[Abschnitt~3.5]{manual:eTeX} zu entnehmen.%
  }%
\end{desclist}
%
\EndIndex{Cmd}{ModifyLayer}%
\EndIndex{Cmd}{RedeclareLayer}%
\EndIndex{Cmd}{ProvideLayer}%
\EndIndex{Cmd}{DeclareNewLayer}%
\EndIndex{Cmd}{DeclareLayer}%

\begin{Declaration}
  \Macro{layerxoffset}\\
  \Macro{layeryoffset}\\
  \Macro{layerwidth}\\
  \Macro{layerheight}%
\end{Declaration}
\BeginIndex{Cmd}{layerxoffset}%
\BeginIndex{Cmd}{layeryoffset}%
\BeginIndex{Cmd}{layerwidth}%
\BeginIndex{Cmd}{layerheight}%
Diese Anweisungen sind nur innerhalb der Ausgabe des mit \Option{contents}
angegebenen \PName{Code} gültig. In diesem Fall enthalten sie die tatsächlich
verwendete Position und Ausdehnung der Ebene, die für die Ausgabe verwendet
werden. Dies ist jedoch nicht zwangsläufig auch die tatsächliche Ausdehnung des
Inhalts, falls dieser beispielsweise überbreit oder überhoch ist oder die
Ebene nicht komplett ausfüllt. Eine Umdefinierung der Anweisungen und damit
Änderung der in ihnen gespeicherten Werte ist nicht gestattet und führt zu
unvorhersehbaren Ergebnissen.%
\EndIndex{Cmd}{layerheight}%
\EndIndex{Cmd}{layerwidth}%
\EndIndex{Cmd}{layeryoffset}%
\EndIndex{Cmd}{layerxoffset}%

\begin{Declaration}
  \Macro{IfLayerExists}%^^A
  \Parameter{Name}\Parameter{Dann-Code}\Parameter{Sonst-Code}
\end{Declaration}
\BeginIndex{Cmd}{IfLayerExists}%
Diese Anweisung kann dazu verwendet werden, Code in Abhängigkeit davon, ob ein
eine Ebene existiert oder nicht, auszuführen. Wenn die Ebene mit dem
angegebenen \PName{Name} existiert, so wird der \PName{Dann-Code}
ausgeführt, anderenfalls der \PName{Sonst-Code}. Bitte beachten Sie, dass die
Anweisung nicht wirklich testen kann, ob eine Ebene existiert. Sie verwendet
stattdessen Heuristiken, die niemals falsch-negativ sein können, jedoch im
Extremfall falsch-positiv sein könnten. Nichts desto trotz: Falls der Test
falsch-positiv ist, läuft etwas schief. Beispielsweise könnte dies ein
Indikator für die Verwendung eines inkompatiblen Pakets oder dafür sein, dass
der Anwender etwas tut, was er besser nicht tun sollte.%
\EndIndex{Cmd}{IfLayerExists}

\begin{Declaration}
  \Macro{DestroyLayer}\Parameter{Name der Ebene}
\end{Declaration}
\BeginIndex{Cmd}{DestroyLayer}%
Existiert eine Ebene mit dem angegebenen \PName{Name der Ebene}, so werden
alle zu dieser Ebene gehörenden Makros zu \Macro{relax}. Anschließend kann die
Ebene nicht länger verwendet werden. Allerdings ist es kein Problem, falls die
Ebene Bestandteil eines mit \Package{scrlayer} definierten Seitenstils ist, da
derart zerstörte Ebenen schlicht ignoriert werden. Nichtsdestotrotz können
zerstörte Ebenen anschließend mit \Macro{DeclareNewLayer} oder
\Macro{ProvideLayer} neu definiert werden. Sie können jedoch vor einer
neuerlichen Definition nicht länger mit \Macro{RedeclareLayer} oder
\Macro{ModifyLayer} verändert werden.

Die Anweisung ist dazu bestimmt, innerhalb von
\Macro{scrlayerOnAutoRemoveInterface} verwendet zu werden. Damit können Ebenen
die unter Verwendung von entfernbaren Anweisungen einer entfernbaren
Benutzerschnittstelle definiert wurden, zusammen mit dieser
Benutzerschnittstelle entfernt werden.%
%
\EndIndex{Cmd}{DestroyLayer}%


\begin{Declaration}
  \Macro{layercontentsmeasure}
\end{Declaration}
\BeginIndex{Cmd}{layercontentsmeasure}%
Mit Hilfe der \KOMAScript-Option
\Option{draft}\IndexOption{draft~=\PName{Ein-Aus-Wert}} kann für das Paket
\Package{scrlayer} ein Entwurfsmodus aktiviert werden. In diesem Entwurfsmodus
wird hinter jeder Ebene zunächst eine Bemaßung der Ebene ausgegeben. Diese
Bemaßung erfolgt mit \Macro{layercontentsmeasure}. Diese Anweisung zeigt am
oberen und linken Rand der Ebene ein Maßband in Zentimeter und am rechten und
unteren Rand der Ebene ein Maßband in Zoll. Die Anweisung
\Macro{layercontentsmeasure} kann statt über die Option auch schlicht als
alleiniger \PName{Code} für die Eigenschaft \Option{contents} einer Ebene
verwendet werden.%
%
\EndIndex{Cmd}{layercontentsmeasure}%


\section{Deklaration und Verwaltung von Seitenstilen}
\label{sec:scrlayer.pagestyles}

Wir kennen nun Ebenen und wissen, wie diese definiert und verwaltet
werden. Aber bisher wissen wir noch nicht, wie sie verwendet werden. Die
möglicherweise überraschende Antwort lautet: mit Hilfe von
Seitenstilen. Üblicherweise werden Seitenstile in \LaTeX{} zur Definition von
Kopf und Fuß der Seite verwendet.

Kopf und Fuß für ungerade oder rechte Seiten werden im doppelseitigen Modus
auf Seiten mit ungerader Seitenzahl ausgegeben. Im einseitigen Modus werden
sie auf allen Seiten verwendet. Das ist unmittelbar mit den Optionen
\Option{oddpage} und \Option{evenpage} für Ebenen vergleichbar.

Der Seitenkopf wird vor dem normalen Seiteninhalt ausgegeben. Der Seitenfuß
wird entsprechend nach dem normalen Seiteninhalt ausgegeben. Dies
korrespondiert also unmittelbar mit den Optionen \Option{background} und
\Option{foreground} für Ebenen.

Daher liegt es nahe, Seitenstile als Listen von Ebenen zu definieren. Aber
statt nur die genannten vier Optionen, können dabei alle Eigenschaften
verwendet werden, die in \autoref{sec:scrlayer.layers} erklärt wurden.

Als Ergebnis dieser Überlegungen ist eine Form von Seitenstilen, die
\Package{scrlayer} bietet, der Ebenen-Seitenstil. Ein solcher Ebenen-Seitenstil
besteht aus Ebenen und zusätzlich aus mehreren Haken (engl. \emph{hooks}). Die
Ebenen wurden bereits in \autoref{sec:scrlayer.layers} beschrieben. Die Haken
sind Punkte in der Expansion oder Anwendung von Seitenstilen, zu denen
zusätzlicher Code hinzugefügt werden kann. Erfahrene Anwender kennen dieses
Konzept bereits von beispielsweise \Macro{AtBeginDocument} (siehe
\cite{latex:usrguide}) oder \Macro{BeforeClosingMainAux} (siehe
\autopageref{desc:scrlfile.cmd.BeforeClosingMainAux}).

Eine zweite Form von Seitenstilen, die \Package{scrlayer} bietet, ist der
Alias-Seitenstil oder Seitenstil-Alias. Ein Seitenstil-Alias besteht in
Wirklichkeit aus einem anderen Seitenstil. Anders ausgedrückt ist der Name eines
Seitenstil-Alias ein Alias-Name für einen anderen Seitenstil-Alias oder einen
primären Seitenstil. Daher führt die Manipulation an einem Seitenstil-Alias
zu einer Manipulation am originären Seitenstil. Ist der originäre Seitenstil
selbst ebenfalls ein Seitenstil-Alias, so führt dessen Manipulation wiederum
zu einer Manipulation dessen originären Seitenstils und immer so weiter, bis
schließlich ein realer Seitenstil verändert wird. Der Ausdruck
\emph{realer Seitenstil} wird zur Unterscheidung von einem Seitenstil-Alias
verwendet. Alle Seitenstile, die kein Seitenstil-Alias sind, sind reale
Seitenstile. Seitenstil-Aliase können nicht nur für Seitenstile definiert
werden, die mit \Package{scrlayer} definiert wurden, sondern für alle
Seitenstile.

\begin{Declaration}
  \Macro{currentpagestyle}
\end{Declaration}
\BeginIndex{Cmd}{currentpagestyle}%
Das Paket \Package{scrlayer} erweitert die \LaTeX-Anweisung
\Macro{pagestyle}\IndexCmd{pagestyle} so, dass diese \Macro{currentpagestyle}
als den Namen des jeweils aktiven Seitenstils
definiert. Es\textnote{Achtung!} ist zu beachten, dass
\Macro{thispagestyle}\IndexCmd{thispagestyle} selbst \Macro{currentpagestyle}
nicht verändert. Wird \Macro{thispagestyle} verwendet, so kann sich
\Macro{currentpagestyle} aber innerhalb der \LaTeX-Ausgabefunktion
verändern. Dies hat jedoch nur dann Auswirkungen, wenn
\Macro{currentpagestyle} bis in die \LaTeX-Ausgabefunktion geschützt
verwendet wird.

Es sei darauf hingewiesen, dass die später in diesem Abschnitt dokumentierten
Ebenen-Seitenstile nicht auf diese Erweiterung von \Macro{pagestyle} angewiesen
sind, da sie selbst ebenfalls \Macro{currentpagestyle} umdefinieren. Die
Erweiterung wurde für die Verwendung von anderen Seitenstilen, die nicht auf
\Package{scrlayer} basieren, vorgenommen. Es ist außerdem zu
beachten\textnote{Achtung!}, dass \Macro{currentpagestyle} vor der ersten
Verwendung von \Macro{pagestyle} nach dem Laden von \Package{scrlayer} leer
ist. Bei der Definition einer Endanwender-Schnittstelle dürfte es daher
nützlich sein, mit einer impliziten \Macro{pagestyle}-Anweisung den aktuellen
Seitenstil auf eine Voreinstellung zu setzen.%
\EndIndex{Cmd}{currentpagestyle}%

\begin{Declaration}
  \Macro{BeforeSelectAnyPageStyle}\Parameter{Code}\\
  \Macro{AfterSelectAnyPageStyle}\Parameter{Code}%
\end{Declaration}
\BeginIndex{Cmd}{BeforeSelectAnyPageStyle}%
\BeginIndex{Cmd}{AfterSelectAnyPageStyle}%
Die Anweisung \Macro{BeforeSelectAnyPageStyle} fügt einem Haken
(engl. \emph{hook}) \PName{Code} hinzu, der innerhalb der Ausführung von
\Macro{pagestyle}, unmittelbar vor der Auswahl des Seitenstils ausgeführt
wird. Innerhalb von \PName{Code} kann \texttt{\#1} als Platzhalter für das
Argument von \Macro{pagestyle} verwendet werden.

Die Anweisung \Macro{AfterSelectAnyPageStyle} arbeitet ähnlich. Allerdings
wird hier \PName{Code} ausgeführt, nachdem der Seitenstil gewählt und
\Macro{currentpagestyle} auf den Namen des realen Seitenstils gesetzt wurde.

Es ist zu beachten\textnote{Achtung!}, dass \PName{Code} jeweils nur bei der
Wahl eines Seitenstils mit Hilfe von \Macro{pagestyle} ausgeführt wird. Wird
ein Seitenstil auf andere Art, beispielsweise mit Hilfe von
\Macro{thispagestyle}, gewählt, so wird \PName{Code} nicht ausgeführt. Es ist
außerdem zu beachten\textnote{Achtung!}, dass einmal hinzugefügter
\PName{Code} nicht mehr entfernt werden kann. Allerdings wird der \PName{Code}
lokal hinzugefügt. Sein Gültigkeitsbereich kann daher mit einer Gruppe
beschränkt werden.%
\EndIndex{Cmd}{AfterSelectAnyPageStyle}%
\EndIndex{Cmd}{BeforeSelectAnyPageStyle}%


\begin{Declaration}
  \Macro{DeclarePageStyleAlias}%
  \Parameter{Seitenstil-Alias-Name}\Parameter{originärer Seitenstil-Name}\\
  \Macro{DeclareNewPageStyleAlias}%
  \Parameter{Seitenstil-Alias-Name}\Parameter{originärer Seitenstil-Name}\\
  \Macro{ProvidePageStyleAlias}%
  \Parameter{Seitenstil-Alias-Name}\Parameter{originärer Seitenstil-Name}\\
  \Macro{RedeclarePageStyleAlias}%
  \Parameter{Seitenstil-Alias-Name}\Parameter{originärer Seitenstil-Name}%
\end{Declaration}
\BeginIndex{Cmd}{DeclarePageStyleAlias}%
\BeginIndex{Cmd}{DeclareNewPageStyleAlias}%
\BeginIndex{Cmd}{ProvidePageStyleAlias}%
\BeginIndex{Cmd}{RedeclarePageStyleAlias}%
Diese Anweisungen können verwendet werden, um einen Seitenstil mit dem Namen
\PName{Seitenstil-Alias-Name} zu definieren, der einfach nur ein Alias für
einen bereits existierenden Seitenstil mit dem Namen \PName{originärer
  Seitenstil-Name} ist. Falls bereits ein Seitenstil mit dem Namen
\PName{Seitenstil-Alias-Name} existiert, wird dieser vor der Erzeugung des
Alias mit \Macro{DeclarePageStyleAlias} oder \Macro{RedeclarePageStyleAlias}
zerstört.

Die Anweisung \Macro{DeclareNewPageStyleAlias} erzeugt eine Fehlermeldung,
falls zuvor bereits ein Seitenstil mit dem Namen \PName{Seitenstil-Alias-Name}
definiert wurde. Dabei spielt es keine Rolle, ob der existierende Seitenstil
selbst ein Alias-Seitenstil, ein Ebenen-Seitenstil oder eine andere Art von
Seitenstil ist.

Die Anweisung \Macro{ProvidePageStyleAlias} definiert den Alias-Seitenstil
nur, falls nicht bereits ein Seitenstil mit dem Namen
\PName{Seitenstil-Alias-Name} existiert. Falls ein solcher Seitenstil
existiert, bleibt dieser erhalten und die Anweisung tut schlicht nichts.

Im Gegensatz zu den anderen Anweisungen erwartet
\Macro{RedeclarePageStyleAlias}, dass bereits ein Seitenstil mit dem Namen
\PName{Seitenstil-Alias-Name} existiert. Anderenfalls erzeugt die Anweisung
eine Fehlermeldung.%
\EndIndex{Cmd}{RedeclarePageStyleAlias}%
\EndIndex{Cmd}{ProvidePageStyleAlias}%
\EndIndex{Cmd}{DeclareNewPageStyleAlias}%
\EndIndex{Cmd}{DeclarePageStyleAlias}

\begin{Declaration}
  \Macro{DestroyPageStyleAlias}\Parameter{Seitenstil-Alias-Name}%
\end{Declaration}
\BeginIndex{Cmd}{DestroyPageStyleAlias}%
Mit dieser Anweisung wird der Seitenstil-Alias mit dem angegebenen Namen
\PName{Seitenstil-Alias-Name} für \LaTeX{} wieder undefiniert, wenn es
tatsächlich einen Alias-Seitenstil dieses Namens gibt. Anschließend kann der
Seitenstil beispielsweise mit \Macro{DeclareNewAliasPageStyle} oder
\Macro{ProvideAliasPageStyle} neu definiert werden.

Die Anweisung ist dazu bestimmt innerhalb von
\Macro{scrlayerOnAutoRemoveInterface} verwendet zu werden, um Seitenstile, die
als Teil eines Endanwender-Interfaces definiert wurden, beim Entfernen dieses
Interfaces mit zu entfernen.%
\EndIndex{Cmd}{DestroyPageStyleAlias}%

\begin{Declaration}
  \Macro{GetRealPageStyle}\Parameter{Seitenstil-Name}%
\end{Declaration}
\BeginIndex{Cmd}{GetRealPageStyle}%
Diese Anweisung sucht rekursiv nach dem tatsächlichen Namen eines
Seitenstils, wenn der angegebene \PName{Seitenstil-Name} zu einem
Alias-Seitenstil gehört. Ist \PName{Seitenstil-Name} nicht der Name eines
Alias-Seitenstils, so ist das Ergebnis \PName{Seitenstil-Name} selbst. Das
gilt auch, falls ein Seitenstil namens \PName{Seitenstil-Name} gar nicht
existiert. Die Anweisung ist voll expandierbar und kann damit beispielsweise
auch im zweiten Argument einer \Macro{edef}-Anweisung verwendet werden.
%
\EndIndex{Cmd}{GetRealPageStyle}%


\begin{Declaration}
  \Macro{DeclarePageStyleByLayers}%
  \OParameter{Optionenliste}\Parameter{Seitenstil-Name}%
  \Parameter{Ebenenliste}\\
  \Macro{DeclareNewPageStyleByLayers}%
  \OParameter{Optionenliste}\Parameter{Seitenstil-Name}%
  \Parameter{Ebenenliste}\\
  \Macro{ProvidePageStyleByLayers}%
  \OParameter{Optionenliste}\Parameter{Seitenstil-Name}%
  \Parameter{Ebenenliste}\\
  \Macro{RedeclarePageStyleByLayers}%
  \OParameter{Optionenliste}\Parameter{Seitenstil-Name}%
  \Parameter{Ebenenliste}%
\end{Declaration}
\BeginIndex{Cmd}{DeclarePageStyleByLayers}%
\BeginIndex{Cmd}{DeclareNewPageStyleByLayers}%
\BeginIndex{Cmd}{ProvidePageStyleByLayers}%
\BeginIndex{Cmd}{RedeclarePageStyleByLayers}%
Diese Anweisungen deklarieren einen Seitenstil mit dem
Namen \Parameter{Seitenstil-Name}. Der Seitenstil besteht aus einer Anzahl von
Ebenen, die in der mit Komma separierten \PName{Ebenenliste} angegeben
sind. Es ist zu beachten\textnote{Achtung!}, dass sowohl
\PName{Seitenstil-Name} als auch \PName{Ebenenliste} voll expandierbar sein
muss und die Expansion zu einer Reihe von Buchstaben führen sollte. Einige
andere Zeichen werden zwar toleriert, ihre Verwendung wird jedoch nicht
empfohlen.

Die \PName{Optionenliste} ist eine mit Komma separierte Liste von
\texttt{\PName{Schlüssel}=\PName{Wert}}-Optionen. Diese Optionen können
verwendet werden, um zusätzliche Eigenschaften zu setzen und zusätzliche
Möglichkeiten zu nutzen. Derzeit werden sie verwendet, um Code an bestimmten
Stellen der Aktivierung oder Verwendung eines Seitenstils über Haken
(engl. \emph{hooks}) auszuführen. Für allgemeine Informationen zu Haken sei
auf die Einleitung zu diesem Abschnitt verwiesen. Details zu den Haken und
ihrer Bedeutung sind \autoref{tab:scrlayer.pagestyle.hooks} zu entnehmen.

\begin{desclist}
  \desccaption{%
    Optionen und gleichnamige Haken für Ebenen-Seitenstile (in der Reihenfolge
    ihrer Abarbeitung)\label{tab:scrlayer.pagestyle.hooks}%
  }{%
    Optionen für die Haken von Ebenen-Seitenstilen (\emph{Fortsetzung})%
  }%
  \entry{\KOption{onselect}\PName{Code}}{%
    Der \PName{Code} dieses Hakens wird immer dann ausgeführt, wenn der
    Seitenstil beispielsweise mit \Macro{pagestyle} ausgewählt wird. Es ist zu
    beachten, dass \Macro{thispagestyle} selbst keinen Seitenstil unmittelbar
    auswählt, sondern der Seitenstil in diesem Fall erst innerhalb der
    Ausgaberoutine von \LaTeX{} aktiviert wird.%
  }%
  \entry{\KOption{oninit}\PName{Code}}{%
    Der \PName{Code} dieses Hakens wird immer dann ausgeführt, wenn die
    Ausgabe der Ebenen für den Seitenstil initialisiert wird. Beachten Sie,
    dass dies für jede Seite zweimal geschieht: einmal für Hintergrund-Ebenen
    und einmal für Vordergrund-Ebenen.%
  }%
  \entry{\KOption{ononeside}\PName{Code}}{%
    Der \PName{Code} dieses Hakens wird immer dann ausgeführt, wenn im
    einseitigen Modus die Ausgabe der Ebenen für den Seitenstil initialisiert
    wird. Beachten Sie, dass dies für jede Seite zweimal geschieht: einmal für
    Hintergrund-Ebenen und einmal für Vordergrund-Ebenen.%
  }%
  \entry{\KOption{ontwoside}\PName{Code}}{%
    Der \PName{Code} dieses Hakens wird immer dann ausgeführt, wenn im
    doppelseitigen Modus die Ausgabe der Ebenen für den Seitenstil
    initialisiert wird. Beachten Sie, dass dies für jede
    Seite zweimal geschieht: einmal für Hintergrund-Ebenen und einmal für
    Vordergrund-Ebenen.%
  }%
  \entry{\KOption{onoddpage}\PName{Code}}{%
    Der \PName{Code} dieses Hakens wird immer dann ausgeführt, wenn die
    Ausgabe der Ebenen für den Seitenstil auf einer rechten Seite
    initialisiert wird. Beachten Sie, dass dies für jede
    Seite zweimal geschieht: einmal für Hintergrund-Ebenen und einmal für
    Vordergrund-Ebenen. Beachten Sie außerdem, dass im
    einseitigen Modus alle Seiten rechte Seiten sind.%
  }%
  \entry{\KOption{onevenpage}\PName{Code}}{%
    Der \PName{Code} dieses Hakens wird immer dann ausgeführt, wenn die
    Ausgabe der Ebenen für den Seitenstil auf einer linken Seite initialisiert
    wird. Beachten Sie, dass dies für jede Seite zweimal
    geschieht: einmal für Hintergrund-Ebenen und einmal für
    Vordergrund-Ebenen. Beachten Sie außerdem, dass im
    einseitigen Modus keine linken Seiten existieren.%
  }%
  \entry{\KOption{onfloatpage}\PName{Code}}{%
    Der \PName{Code} dieses Hakens wird immer dann ausgeführt, wenn die
    Ausgabe der Ebenen für den Seitenstil auf einer Gleitumgebungsseite
    initialisiert wird. Beachten Sie, dass dies für jede
    Seite zweimal geschieht: einmal für Hintergrund-Ebenen und einmal für
    Vordergrund-Ebenen. Beachten Sie außerdem, dass
    Gleitumgebungsseiten nur diejenigen Seiten sind, auf denen eine oder
    mehrere p-platzierte Gleitumgebungen ausgegeben werden.%
  }%
  \entry{\KOption{onnonfloatpage}\PName{Code}}{%
    Der \PName{Code} dieses Hakens wird immer dann ausgeführt, wenn die
    Ausgabe der Ebenen für den Seitenstil auf einer Seite initialisiert wird,
    die keine Gleitumgebungsseite ist. Beachten Sie, dass
    dies für jede Seite zweimal geschieht: einmal für Hintergrund-Ebenen und
    einmal für Vordergrund-Ebenen. Beachten Sie außerdem,
    dass Gleitumgebungsseiten nur diejenigen Seiten sind, auf denen eine oder
    mehrere p-platzierte Gleitumgebungen ausgegeben werden, und auf anderen
    Seiten sehr wohl t-, b- oder h-platzierte Gleitumgebungen stehen können.%
  }%
  \entry{\KOption{onbackground}\PName{Code}}{%
    Der \PName{Code} dieses Hakens wird immer dann ausgeführt, wenn die
    Ausgabe der Ebenen für den Hintergrund einer Seite initialisiert
    wird. Beachten Sie, dass dies auf jeder Seite genau
    einmal der Fall ist.%
  }%
  \entry{\KOption{onforeground}\PName{Code}}{%
    Der \PName{Code} dieses Hakens wird immer dann ausgeführt, wenn die
    Ausgabe der Ebenen für den Vordergrund einer Seite initialisiert
    wird. Beachten Sie, dass dies auf jeder Seite genau
    einmal der Fall ist.%
  }%
\end{desclist}

Der Unterschied zwischen \Macro{DeclarePageStyleByLayers} und
\Macro{DeclareNewPageStyleByLayers} besteht darin, dass
\Macro{DeclareNewPageStyleByLayers} eine Fehlermeldung erzeugt, falls bereits
ein Seitenstil des Namens \PName{Seitenstil-Name}
existiert. Beachten\textnote{Achtung!} Sie, dass die Deklaration eines
Seitenstils, der bereits ein Alias für einen anderen Seitenstil ist (siehe
\Macro{DeclareAliasPageStyle} zuvor in diesem Abschnitt) nicht zu der
Umdefinierung des angegebenen Alias-Seitenstils, sondern des realen
Seitenstils (siehe \Macro{GetRealPageStyle} zuvor in diesem Abschnitt) führt.

Im Unterschied dazu wird bei \Macro{ProvidePageStyleByLayers} der Seitenstil
unverändert erhalten, wenn bereits ein Seitenstil des Namens
\PName{Seitenstil-Name} existiert. Existiert kein solcher Seitenstil, so wird
er wie bei \Macro{DeclarePageStyleByLayers} oder
\Macro{DeclareNewPageStyleByLayers} neu definiert.

Die Anweisung \Macro{RedeclarePageStyleByLayers} wiederum erwartet, dass
bereits ein Seitenstil des Namens \PName{Seitenstil-Name} existiert und
definiert dessen realen Seitenstil dann um. Existiert jedoch noch kein
Seitenstil des angegebenen Namens, so resultiert daraus eine Fehlermeldung.

Beachten Sie auch die nachfolgenden Anmerkungen zum Pseudo-Seitenstil
\Pagestyle{@everystyle@}.%
\EndIndex{Cmd}{RedeclarePageStyleByLayers}%
\EndIndex{Cmd}{ProvidePageStyleByLayers}%
\EndIndex{Cmd}{DeclareNewPageStyleByLayers}%
\EndIndex{Cmd}{DeclarePageStyleByLayers}%


\begin{Declaration}
  \Pagestyle{@everystyle@}\\
  \Pagestyle{empty}
\end{Declaration}
\BeginIndex{Pagestyle}{@everysel@}%
\BeginIndex{Pagestyle}{empty}%
Das Paket \Package{scrlayer} definiert von sich aus bereits zwei in gewisser
Weise spezielle Seitenstile. Der erste davon ist
\Pagestyle{@everystyle@}. Dieser Seitenstil sollte niemals als normaler
Seitenstil beispielsweise mit \Macro{pagestyle} oder \Macro{thispagestyle}
oder als Ziel eines Alias-Seitenstils verwendet werden. Stattdessen werden die
Ebenen und Haken dieses Seitenstils von allen anderen Ebenen-Seitenstilen mit
verwendet. Dabei werden die Haken von \Pagestyle{@everystyle@} jeweils vor den
entsprechenden Haken und die Ebenen jeweils vor den entsprechenden Ebenen des
aktiven Seitenstils ausgeführt. Damit ist das Hinzufügen einer Ebene zum
Seitenstil \Pagestyle{@everystyle@} oder von Code zu einem Haken dieses
Seitenstils vergleichbar mit dem Hinzufügen einer Ebene beziehungsweise von
Haken-Code zu allen Ebenen-Seitenstile. Der eine entscheidende Unterschied
ist: Befehle, die sich auf die Ebenen eines Seitenstils beziehen,
beispielsweise \Macro{ForEachLayerOfPageStyle},
\Macro{AddLayersToPageStyleBeforeLayer} oder
\Macro{AddLayersToPageStyleAfterLayer} lassen die Ebenen des Seitenstils
\Pagestyle{@everystyle@} unberücksichtigt, wenn sie auf einen anderen
Ebenen-Seitenstil angewendet werden.

Der zweite etwas andere Ebenen-Seitenstil ist \Pagestyle{empty}. Normalerweise
wird bereits vom \LaTeX-Kern ein Seitenstil dieses Namens definiert. Dieser
Seitenstil hat einen leeren Kopf und Fuß. Das Paket \Package{scrlayer}
definiert diesen Seitenstil als Ebenen-Seitenstil ohne Ebenen
um. Nichtsdestotrotz kann er wie jeder andere Ebenen-Seitenstil verwendet
werden. Der Hauptvorteil dieses Ebenen-Seitenstils gegenüber dem
ursprünglichen Seitenstil aus dem \LaTeX-Kern ist, dass er ebenfalls die Haken
und Ebenen des Pseudo-Seitenstils \Pagestyle{@everystyle@} ausführt.%
\EndIndex{Pagestyle}{empty}%
\EndIndex{Pagestyle}{@everysel@}%


\begin{Declaration}
  \KOption{onpsselect}\PValue{Code}\\
  \KOption{onpsinit}\PValue{Code}\\
  \KOption{onpsoneside}\PValue{Code}\\
  \KOption{onpstwoside}\PValue{Code}\\
  \KOption{onpsoddpage}\PValue{Code}\\
  \KOption{onpsevenpage}\PValue{Code}\\
  \KOption{onpsfloatpage}\PValue{Code}\\
  \KOption{onpsnonfloatpage}\PValue{Code}\\
  \KOption{onpsbackground}\PValue{Code}\\
  \KOption{onpsforeground}\PValue{Code}
\end{Declaration}
\BeginIndex{Option}{onpsselect~=\PName{Code}}%
\BeginIndex{Option}{onpsinit~=\PName{Code}}%
\BeginIndex{Option}{onpsoneside~=\PName{Code}}%
\BeginIndex{Option}{onpstwoside~=\PName{Code}}%
\BeginIndex{Option}{onpsoddpage~=\PName{Code}}%
\BeginIndex{Option}{onpsevenpage~=\PName{Code}}%
\BeginIndex{Option}{onpsfloatpage~=\PName{Code}}%
\BeginIndex{Option}{onpsnonfloatpage~=\PName{Code}}%
\BeginIndex{Option}{onpsbackground~=\PName{Code}}%
\BeginIndex{Option}{onpsforeground~=\PName{Code}}%
Für jeden der Haken aus \autoref{tab:scrlayer.pagestyle.hooks} existiert
außerdem eine \KOMAScript-Option. Die Namen der \KOMAScript-Optionen ähneln
den Namen der Optionen für die Befehle zur Deklaration von
Ebenen-Seitenstilen. Es wird lediglich ein »\texttt{ps}« nach dem
»\texttt{on}« am Anfang des Namens eingefügt. Die Werte dieser
\KOMAScript-Optionen werden als Anfangswerte für die entsprechenden Haken
verwendet. Dieser Anfangswert wird dann um alle Werte, die dem entsprechenden
Haken in der \PName{Optionenliste} der Deklarationsbefehle zugewiesen werden,
erweitert. Der Anfangswert kann mit Hilfe der Anweisung
\Macro{ModifyLayerPageStyleOptions}, die später in diesem Abschnitt erklärt
wird, entfernt werden.%
\EndIndex{Option}{onpsforeground~=\PName{Code}}%
\EndIndex{Option}{onpsbackground~=\PName{Code}}%
\EndIndex{Option}{onpsnonfloatpage~=\PName{Code}}%
\EndIndex{Option}{onpsfloatpage~=\PName{Code}}%
\EndIndex{Option}{onpsevenpage~=\PName{Code}}%
\EndIndex{Option}{onpsoddpage~=\PName{Code}}%
\EndIndex{Option}{onpstwoside~=\PName{Code}}%
\EndIndex{Option}{onpsoneside~=\PName{Code}}%
\EndIndex{Option}{onpsinit~=\PName{Code}}%
\EndIndex{Option}{onpsselect~=\PName{Code}}%

\begin{Declaration}
  \KOption{deactivatepagestylelayers}\PName{Ein-Aus-Wert}\\
  \Macro{ForEachLayerOfPageStyle}\Parameter{Seitenstil-Name}%
  \Parameter{Code}
\end{Declaration}
\BeginIndex{Option}{deactivatepagestylelayers~=\PName{Ein-Aus-Wert}}%
\BeginIndex{Cmd}{ForEachLayerOfPageStyle}%
Solange die \KOMAScript-Option \Option{deactivatepagestylelayers} nicht
aktiviert ist, kann mit \Macro{ForEachLayerOfPageStyle} für jede Ebene des
Seitenstils mit dem Namen \PName{Seitenstil-Name} beliebiger \PName{Code}
ausgeführt werden. Innerhalb von \PName{Code} dient dabei \PValue{\#1} als
Platzhalter für den Namen der gerade abgearbeiteten Ebene.
\begin{Example}
  Angenommen, Sie wollen die Namen aller Ebenen des Seitenstils
  \PValue{scrheadings} als Komma-separierte Liste, so können Sie dies mit
\begin{lstcode}
  \newcommand*\commaatlist{}
  \ForEachLayerOfPageStyle{scrheadings}{%
    \commaatlist#1\gdef\commaatlist{, }}
  \let\commaatlist\relax
\end{lstcode}
  erreichen.
\end{Example}
Die Verwendung von \Macro{gdef} an Stelle von \Macro{def} ist im Beispiel
notwendig, weil \PName{Code} innerhalb einer Gruppe ausgeführt wird, um
unerwünschte Seiteneffekte zu minimieren. Die Anweisung \Macro{gdef} definiert
\Macro{commaatlist} jedoch global um, so dass beim Aufruf des Codes für die
nächste Ebene die Änderung Bestand hat.

Diverse Anweisungen von \Package{scrlayer} setzen ebenfalls
\Macro{ForEachLayerOfPageStyle} ein. Auch deren Funktion kann daher über die
\KOMAScript-Option \Option{deactivatepagestylelayers} verändert werden. Diese
Option kann daher verwendet werden, um alle Ebenen aller Seitenstile temporär
zu deaktivieren oder zu verstecken.
%
\EndIndex{Cmd}{ForEachLayerOfPageStyle}%
\EndIndex{Option}{deactivatepagestylelayers~=\PName{Ein-Aus-Wert}}%

\begin{Declaration}
  \Macro{AddLayersToPageStyle}%
  \Parameter{Seitenstil-Name}\Parameter{Ebenenliste}\\
  \Macro{AddLayersAtBeginOfPageStyle}%
  \Parameter{Seitenstil-Name}\Parameter{Ebenenliste}\\
  \Macro{AddLayersAtEndOfPageStyle}%
  \Parameter{Seitenstil-Name}\Parameter{Ebenenliste}\\
  \Macro{RemoveLayersFromPageStyle}%
  \Parameter{Seitenstil-Name}\Parameter{Ebenenliste}%
\end{Declaration}
\BeginIndex{Cmd}{AddLayersToPageStyle}%
\BeginIndex{Cmd}{AddLayersAtBeginOfPageStyle}%
\BeginIndex{Cmd}{AddLayersAtEndOfPageStyle}%
\BeginIndex{Cmd}{RemoveLayersFromPageStyle}%
Diese Anweisungen können verwendet werden, um Ebenen zu einem Seitenstil
hinzuzufügen oder davon zu entfernen. Der Seitenstil wird dabei über seinen
\PName{Seitenstil-Name} referenziert. Die Ebenen werden in einer durch Komma
separierten \PName{Ebenenliste} angegeben. 

Die Anweisungen \Macro{AddLayersToPageStyle} und
\Macro{AddLayersAtEndOfPageStyle} fügen die Ebenen am Ende der Ebenenliste des
Seitenstils ein. Logisch liegen die neu hinzugefügten Ebenen also über oder
vor den bereits vorhandenen Ebenen, wobei Hintergrund-Ebenen natürlich
weiterhin logisch hinter der Textebene und damit auch hinter allen
Vordergrund-Ebenen liegen.

Die Anweisung \Macro{AddLayersAtBeginOfPageStyle} fügt die Ebenen hingegen am
Anfang der Ebenenliste des Seitenstils ein. Dabei werden die Ebenen in der
Reihenfolge am Anfang eingefügt, in der sie auch in der \PName{Ebenenliste}
stehen. Damit wird die Ebene, die ganz am Ende von \PName{Ebenenliste} steht,
nach dem Einfügen die erste und damit die unterste oder hinterste Ebene
(jeweils entweder der Vordergrund oder der Hintergrundebenen) sein. 

Der Versuch, mit Hilfe von \Macro{RemoveLayersFromPageStyle} Ebenen von einem
Seitenstil zu entfernen, die gar nicht Teil des Seitenstils sind, wird
ignoriert, führt also nicht zu einer Fehlermeldung. Dagegen ist der Versuch,
Ebenen zu einem Seitenstil, der kein Ebenen-Seitenstil ist und auch kein
Alias-Seitenstil, der zu einem Ebenen-Seitenstil führt, hinzuzufügen oder von
einem solchen zu entfernen ein Fehler und wird als solcher gemeldet.%
\EndIndex{Cmd}{RemoveLayersFromPageStyle}%
\EndIndex{Cmd}{AddLayersAtEndOfPageStyle}%
\EndIndex{Cmd}{AddLayersAtBeginOfPageStyle}%
\EndIndex{Cmd}{AddLayersToPageStyle}%

\begin{Declaration}
  \Macro{AddLayersToPageStyleBeforeLayer}%
  \Parameter{Seitenstil-Name}\Parameter{Ebenenliste}%
  \Parameter{Referenzebenen-Name}\\
  \Macro{AddLayersToPageStyleAfterLayer}%
  \Parameter{Seitenstil-Name}\Parameter{Ebenenliste}%
  \Parameter{Referenzebenen-Name}%
\end{Declaration}
\BeginIndex{Cmd}{AddLayersToPageStyleBeforeLayer}%
\BeginIndex{Cmd}{AddLayersToPageStyleAfterLayer}%
Diese beiden Befehle ähneln den vorangegangenen. Allerdings wird hier
zusätzlich ein \PName{Referenzebenen-Name} angegeben. Die Ebenen des über den
\PName{Seitenstil-Name} angegebenen Seitenstils werden nach dieser
Referenzebene durchsucht. Die Ebenen der \PName{Ebenenliste} werden dann vor
respektive nach jedem Auf"|treten der Referenzebene in die Ebenen des
Seitenstils eingefügt. Dabei bleibt die Reihenfolge der Ebenen der
\PName{Ebenenliste} erhalten.%|

Ist die Referenzebene nicht Bestandteil des Seitenstils, so wird auch nichts
eingefügt. Ist der Seitenstil hingegen kein Ebenen-Seitenstil und auch kein
Alias-Seitenstil, der zu einem Ebenen-Seitenstil führt, so wird ein Fehler
gemeldet.%
\EndIndex{Cmd}{AddLayersToPageStyleAfterLayer}%
\EndIndex{Cmd}{AddLayersToPageStyleBeforeLayer}%

\begin{Declaration}
  \Macro{UnifyLayersAtPageStyle}\Parameter{Seitenstil-Name}
\end{Declaration}
\BeginIndex{Cmd}{UnifyLayersAtPageStyle}%
Bei den Befehlen zur Definition eines Seitenstils oder zum Hinzufügen von
Ebenen zu einem Seitenstil wird nicht darauf geachtet, ob eine Ebene mehrfach
Bestandteil eines Seitenstils ist oder wird. Dies ist also durchaus
zulässig. In den meisten Fällen hat es allerdings keinen Sinn, eine Ebene
mehrfach als Bestandteil eines Seitenstils zu haben. Daher kann mit Hilfe von
\Macro{UnifyLayersAtPageStyle} dafür gesorgt werden, dass alle
Ebenen-Dubletten vom Seitenstil mit dem angegebenen \PName{Seitenstil-Name}
entfernt werden.

Es ist zu beachten\textnote{Achtung!}, dass sich dabei die Reihenfolge der
Ebenen ändern kann. Wird also eine spezielle Reihenfolge gewünscht, sollten
stattdessen alle Ebenen entfernt und die gewünschten Ebenen in der erwarteten
Reihenfolge neu hinzugefügt werden. \Macro{UnifyLayersAtPageStyle} ist in einem
solchen Fall also nicht geeignet.%
\EndIndex{Cmd}{UnifyLayersAtPageStyle}%

\begin{Declaration}
  \Macro{ModifyLayerPageStyleOptions}%
  \Parameter{Seitenstil-Name}\Parameter{Optionenliste}\\
  \Macro{AddToLayerPageStyleOptions}%
  \Parameter{Seitenstil-Name}\Parameter{Optionenliste}%
\end{Declaration}
\BeginIndex{Cmd}{ModifyLayerPageStyleOptions}%
\BeginIndex{Cmd}{AddToLayerPageStyleOptions}%
Mit diesen beiden Anweisungen können die Optionen und damit die Haken eines
Ebenen-Seitenstils nachträglich verändert werden. Bei
\Macro{ModifyLayerPageStyleOptions} werden dabei genau die Optionen, die in
der durch Komma separierten \PName{Optionenliste} angegeben sind auf die
dortigen neuen Werte gesetzt. Die bisherigen Werte gehen dabei verloren. Es
sind alle Optionen aus \autoref{tab:scrlayer.pagestyle.hooks},
\autopageref{tab:scrlayer.pagestyle.hooks} erlaubt. Optionen beziehungsweise
Haken, die nicht in der \PName{Optionenliste} angegeben sind, bleiben hingegen
unverändert. Diese Anweisung ist damit auch die einzige Möglichkeit, die
globalen Voreinstellungen der \KOMAScript-Optionen von einem Seitenstil zu
entfernen.

Die Anweisung \Macro{AddToLayerPageStyleOptions} unterscheidet sich insofern,
als die neuen Werte die bisher vorhandenen Werte nicht überschreiben, sondern
diesen hinzugefügt oder -- genauer gesagt -- an diese angehängt werden.%
\EndIndex{Cmd}{AddToLayerPageStyleOptions}%
\EndIndex{Cmd}{ModifyLayerPageStyleOptions}%

\begin{Declaration}
  \Macro{IfLayerPageStyleExists}%
  \Parameter{Seitenstil-Name}\Parameter{Dann-Code}\Parameter{Sonst-Code}\\
  \Macro{IfRealLayerPageStyleExists}%^
  \Parameter{Seitenstil-Name}\Parameter{Dann-Code}\Parameter{Sonst-Code}%
\end{Declaration}
\BeginIndex{Cmd}{IfLayerPageStyleExists}%
\BeginIndex{Cmd}{IfRealLayerPageStyleExists}%
Mit diesen Anweisungen kann Code in Abhängigkeit davon ausgeführt werden, ob
ein Seitenstil ein Ebenen-Seitenstil ist oder nicht. Dabei führt
\Macro{IfLayerPageStyleExists} den \PName{Dann-Code} nur dann aus, wenn
\PName{Seitenstil-Name} der Name eines Ebenen-Seitenstils oder der Name eines
Alias-Seitenstils ist, der zu einem Ebenen-Seitenstil führt. Anderenfalls
führt die Anweisung den \PName{Sonst-Code} aus.

Die Anweisung \Macro{IfRealLayerPageStyleExists} geht einen Schritt weiter und
führt den \PName{Dann-Code} nur dann aus, wenn der über
\PName{Seitenstil-Name} angegebene Seitenstil selbst ein Ebenen-Seitenstil
ist. Im Falle eines Alias-Seitenstils führt diese Anweisung also selbst dann
\PName{Sonst-Code} aus, wenn dieser Alias-Seitenstil zu einem
Ebenen-Seitenstil führt.%
\EndIndex{Cmd}{IfRealLayerPageStyleExists}%
\EndIndex{Cmd}{IfLayerPageStyleExists}%

\begin{Declaration}
  \Macro{IfLayerAtPageStyle}%
  \Parameter{Seitenstil-Name}\Parameter{Ebenen-Name}%
  \Parameter{Dann-Code}\Parameter{Sonst-Code}\\
  \Macro{IfSomeLayersAtPageStyle}%
  \Parameter{Seitenstil-Name}\Parameter{Ebenenliste}%
  \Parameter{Dann-Code}\Parameter{Sonst-Code}\\
  \Macro{IfLayersAtPageStyle}%
  \Parameter{Seitenstil-Name}\Parameter{Ebenenliste}%
  \Parameter{Dann-Code}\Parameter{Sonst-Code}%
\end{Declaration}
\BeginIndex{Cmd}{IfLayerAtPageStyle}%
\BeginIndex{Cmd}{IfSomeLayersAtPageStyle}%
\BeginIndex{Cmd}{IfLayersAtPageStyle}%
Mit diesen Anweisungen kann überprüft werden ob ein oder mehrere Ebenen
Bestandteil eines Seitenstils sind. Anweisung \Macro{IfLayerAtPageStyle}
erwartet dabei nach dem \PName{Seitenstil-Name} im ersten Argument im zweiten
Argument genau einen \PName{Ebenen-Name}. Ist die entsprechende Ebene
Bestandteil des Seitenstils, so wird der \PName{Dann-Code} ausgeführt,
anderenfalls der \PName{Sonst-Code}.

Die Anweisungen \Macro{IfSomeLayersAtPageStyle} und
\Macro{IfLayersAtPageStyle} erlauben hingegen im zweiten Argument eine durch
Komma separierte \PName{Ebenenliste}. Dabei führt
\Macro{IfSomeLayersAtPageStyle} den \PName{Dann-Code} bereits aus, wenn
\emph{mindestens eine} der Ebenen Bestandteil des Seitenstils ist. Dagegen
führt \Macro{IfLayersAtPageStyle} den \PName{Dann-Code} nur aus, wenn
\emph{alle} Ebenen Bestandteil des Seitenstils sind. Ist die Bedingung nicht
erfüllt, so wird jeweils \PName{Sonst-Code} ausgeführt. 

Durch geeignete Schachtelung sind auch komplexe Bedingungen abbildbar. Gibt
man statt einer \PName{Ebenenliste} jeweils nur einen \PName{Ebenen-Name} an,
so sind alle drei Anweisungen gleichbedeutend.%
\EndIndex{Cmd}{IfLayersAtPageStyle}%
\EndIndex{Cmd}{IfSomeLayersAtPageStyle}%
\EndIndex{Cmd}{IfLayerAtPageStyle}%

\begin{Declaration}
  \Macro{DestroyRealLayerPageStyle}\Parameter{Ebenen-Seitenstil-Name}
\end{Declaration}
\BeginIndex{Cmd}{DestroyRealLayerPageStyle}%
Mit dieser Anweisung kann ein Ebenen-Seitenstil aus \LaTeX-Sicht wieder
undefiniert werden. Dies gilt jedoch nur, wenn es einen Ebenen-Seitenstil mit
dem Namen \PName{Ebenen-Seitenstil-Name} auch tatsächlich gibt. Handelt es sich
stattdessen um einen Alias-Seitentstil -- auch wenn dieser zu einem
Ebenen-Seitenstil führt -- oder um einen anderen Seitenstil oder ist gar kein
Seitenstil mit dem Namen \PName{Ebenen-Seitenstil-Name} bekannt, so geschieht
nichts, die Anweisung wird ignoriert.

Falls \PName{Ebenen-Seitenstil-Name} der Name des aktuellen Seitenstils ist, so
wird der aktuelle Seitenstil auf eine Art leerer Seitenstil gesetzt. Falls der
Spezial-Seitenstil, der durch \Macro{thispagestyle} gesetzt wurde, auf
\PName{Ebenen-Seitenstil-Name} lautet, so wird dieser einfach nur
zurückgesetzt. Die vorherige Anweisung \Macro{thispagestyle} verliert damit
ihre aktuelle Auswirkung.

Es ist zu beachten\textnote{Achtung!}, dass die Ebenen des Seitenstils nicht
automatisch mit vernichtet werden. Falls Sie die Ebenen ebenfalls vernichten
möchten, so können Sie dies beispielsweise mit:
\begin{lstcode}[belowskip=\dp\strutbox]
  \ForEachLayerOfPageStyle{...}{\DestroyLayer{#1}}
\end{lstcode}
vor der Vernichtung des Seitenstils selbst erreichen.

Die Anweisung ist dazu gedacht innerhalb der automatischen Entfernung einer
Endanwender-Schnittstelle verwendet zu werden. Siehe
\autoref{sec:scrlayer.enduserinterfaces} für weitere Informationen zu diesem
Thema.%
\EndIndex{Cmd}{DestroyRealLayerPageStyle}%

\LoadCommon{20} % \section{Höhe von Kopf und Fuß}

\LoadCommon{21} % \section{Beeinflussung der Inhalte von Seitenstilen}

\section{Definition und Verwaltung von Schnittstellen für Endanwender}
\label{sec:scrlayer.enduserinterfaces}

Das Paket \Package{scrlayer} stellt eine Benutzerschnittstelle zur Verfügung
um (konkurrierende) Schnittstellen für Endanwender definieren und verwalten zu
können. Möglicherweise wird diese Schnittstelle langfristig wieder aus
\Package{scrlayer} verschwinden und dann stattdessen von \Package{scrbase}
übernommen werden. Derzeit ist diese Schnittstelle aber noch hoch
experimentell und wird daher von eigenen Befehlen innerhalb von
\Package{scrlayer} nur für Unterpakete von \Package{scrlayer} bereit
gestellt. Es empfiehlt sich derzeit nicht, sich darauf zu verlassen, dass die
automatische Entfernung einer konkurrierenden Schnittstelle
funktioniert. Stattdessen sollte die Verwendung konkurrierender Schnittstellen
vermieden werden.

Dieser Abschnitt beschreibt lediglich die Schnittstellen-Anweisungen für die
Definition einer Endanwender-Schnittstelle. Für Endanwender selbst ist es
damit von geringem Interesse. Vielmehr richtet sich dieser Teil der Anleitung
an Autoren von Paketen und Klassen, die auf \Package{scrlayer}
aufbauen. Endanwender finden Informationen zu konkreten
Endanwender-Schnittstellen in \autoref{cha:scrlayer-scrpage},
\autoref{cha:scrlayer-scrpage-experts} und \autoref{cha:scrlayer-notecolumn}.

\begin{Declaration}
  \Macro{scrlayerInitInterface}\OParameter{Schnittstellen-Name}
\end{Declaration}
\BeginIndex{Cmd}{scrlayerInitInterface}%
Mit dieser Anweisung wird eine neue Schnittstelle mit dem Namen
\PName{Schnittstellen-Name} registriert. Das Argument
\PName{Schnittstellen-Name} muss einzigartig sein. Das bedeutet, dass eine
Schnittstelle gleichen Namens noch nicht registriert sein darf. Sollte dies
doch der Fall sein, so wird ein Fehler ausgegeben.

Diese Anweisung sollte immer ganz am Anfang einer Endanwender-Schnittstelle
stehen. Daher wird sie hier auch zuerst erklärt. Wird das optionale Argument
-- einschließlich der eckigen Klammern -- weg gelassen, so wird dafür
\PValue{\Macro{@currname}.\Macro{@currext}} verwendet. Für Klassen und
Pakete ist dies der Dateiname der Klasse respektive des Pakets. Aber
selbstverständlich kann jede andere Zeichenfolge der Kategorie \emph{letter}
oder \emph{other} verwendet werden. Dies ist beispielsweise sinnvoll, wenn
eine Klasse oder ein Paket mehrere Endanwender-Schnittstellen definiert.%
\EndIndex{Cmd}{scrlayerInitInterface}%

\begin{Declaration}
  \KOption{forceoverwrite}\PName{Ein-Aus-Wert}\\
  \KOption{autoremoveinterfaces}\PName{Ein-Aus-Wert}\\
  \Macro{scrlayerAddToInterface}%
  \OParameter{Schnittstellen-Name}\Parameter{Befehl}\Parameter{Code}\\
  \Macro{scrlayerAddCsToInterface}%
  \OParameter{Schnittstellen-Name}\Parameter{Befehlssequenz}\Parameter{Code}
\end{Declaration}
\BeginIndex{Option}{forceoverwrite}%
\BeginIndex{Option}{autoremoveinterfaces}%
\BeginIndex{Cmd}{scrlayerAddToInterface}%
\BeginIndex{Cmd}{scrlayerAddCsToInterface}%
Eine der besonderen Eigenschaften der Endanwender-Schnittstellen von
\Package{scrlayer} ist es, dass die Schnittstelle verwendete Befehle (auch
bekannt als \emph{Makros} oder engl. \emph{macros}) registrieren sollte. Dies
kann mit \Macro{scrlayerAddToInterface} erfolgen. Das optionale Argument
\PName{Schnittstellen-Name} entspricht hier dem Namen, der mit
\Macro{scrlayerInitInterface} zuvor registriert wurde.

Werden\textnote{Achtung!} Anweisungen nicht nur während des Ladens einer
Klasse oder eines Pakets, sondern auch zur Laufzeit definiert, so ist das
optionale Argument auch dann zu verwenden, wenn es dem Dateinamen der Klasse
beziehungsweise des Pakets entspricht, da die Werte von \Macro{@currname} und
\Macro{@currext} nur während des Ladens Gültigkeit besitzen.

Das erste obligatorische Argument ist der \PName{Befehl}\footnote{\PName{Befehl}
  besteht aus einem umgekehrten Schrägstrich (engl. \emph{backslash}) gefolgt
  von einer \PName{Befehlssequenz}, die entweder aus Zeichen der
  Kategorie \emph{letter} oder aus genau einem Zeichen der Kategorie
  \emph{other} besteht, oder aus einem Zeichen der Kategorie \texttt{active}
  (ohne umgekehrten Schrägstrich davor).}, der zu der
Endanwender-Schnittstelle hinzugefügt werden soll. Falls der Befehl
definiert werden kann, erfolgt dies. Außerdem wird dann der Befehl auf
\Macro{relax} gesetzt und \PName{Code} wird ausgeführt. Innerhalb von
\PName{Code} kann der \PName{Befehl} dann beispielsweise mit Hilfe von
\Macro{newcommand}\PName{Befehl} definiert werden.

Wann aber kann ein \PName{Befehl} definiert werden? Ist ein \PName{Befehl}
undefiniert oder \Macro{relax}, so kann er immer definiert werden. Wurde ein
\PName{Befehl} bereits definiert \emph{und} für eine andere
Endanwender-Schnittstelle registriert \emph{und} wurde die \KOMAScript-Option
\Option{autoremoveinterface} aktiviert, so wird diese andere
Endanwender-Schnittstelle automatisch entfernt, der \PName{Befehl} auf
\Macro{relax} gesetzt und für die angegebene neue Endanwender-Schnittstelle
registriert. Damit ist \PName{Befehl} auch dann definierbar. Falls ein
\PName{Befehl} bereits definiert ist, \emph{aber nicht} Teil einer anderen
Endanwender-Schnittstelle ist, \emph{und} falls die \KOMAScript-Option
\Option{forceoverwrite} aktiviert wurde, wird \PName{Befehl} ebenfalls
\Macro{relax} und für die angegebene Endanwender-Schnittstelle
registriert. Der \PName{Befehl} ist also auch in diesem Fall definierbar. In
allen anderen Fällen ist er jedoch nicht definierbar, also insbesondere, falls
er bereits definiert ist und die \KOMAScript-Optionen
\Option{autoremoveinterface} und \Option{forceoverwrite} deaktiviert sind.

Die Anweisung \Macro{scrlayerAddCsToInterface} arbeitet ganz ähnlich der
vorgenannten Anweisung \Macro{scrlayerAddToInterface}. Allerdings erwartet sie
als erstes Argument keinen \PName{Befehl}, sondern eine
\PName{Befehlssequenz}\footnote{Eine \PName{Befehlssequenz} muss voll
  expandierbar sein und ihre Expansion muss zu Zeichen der Kategorie
  \emph{letter}, \emph{other} oder \emph{space} führen.}.%
%
\EndIndex{Cmd}{scrlayerAddCsToInterface}%
\EndIndex{Cmd}{scrlayerAddToInterface}%
\EndIndex{Option}{autoremoveinterfaces}%
\EndIndex{Option}{forceoverwrite}%

\begin{Declaration}
  \Macro{scrlayerOnAutoRemoveInterface}%^^A
  \OParameter{Schnittstellen-Name}\Parameter{Code}
\end{Declaration}
\BeginIndex{Cmd}{scrlayerOnAutoRemoveInterface}%
Für den Fall, dass die Endanwender-Schnittstelle namens
\PName{Schnittstellen-Name} automatisch entfernt wird (siehe
\KOMAScript-Option \Option{autoremoveinterface} zuvor in diesem Abschnitt)
kann zusätzlich \PName{Code} ausgeführt werden. Dies kann beispielsweise
verwendet werden, um Ebenen oder Seitenstile automatisch mit zu vernichten
(siehe \Macro{DestroyLayer}, \Macro{DestroyAliasPageStyle}, and
\Macro{DestroyRealLayerPageStyle}), die auf Befehlen der
Endanwender-Schnittstelle beruhen. Bezüglich des optionalen Arguments
\PName{Schnittstellen-Name} sei auf die Erklärung zu
\Macro{scrlayerInitInterface} verwiesen.%
\EndIndex{Cmd}{scrlayerOnAutoRemoveInterface}%
%
\EndIndex{Package}{scrlayer}%

%%% Local Variables:
%%% mode: latex
%%% mode: flyspell
%%% coding: iso-latin-1
%%% ispell-local-dictionary: "de_DE"
%%% TeX-master: "../guide"
%%% End: 
