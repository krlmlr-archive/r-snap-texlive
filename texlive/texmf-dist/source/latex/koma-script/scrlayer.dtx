% \CheckSum{3307}
% \iffalse^^A meta-comment
% ======================================================================
% scrlayer.dtx
% Copyright (c) Markus Kohm, 2012-2013
%
% This file is part of the LaTeX2e KOMA-Script bundle.
%
% This work may be distributed and/or modified under the conditions of
% the LaTeX Project Public License, version 1.3c of the license.
% The latest version of this license is in
%   http://www.latex-project.org/lppl.txt
% and version 1.3c or later is part of all distributions of LaTeX
% version 2005/12/01 and of this work.
%
% This work has the LPPL maintenance status "author-maintained".
%
% The Current Maintainer and author of this work is Markus Kohm.
%
% This work consists of all files listed in manifest.txt.
% ----------------------------------------------------------------------
% scrlayer.dtx
% Copyright (c) Markus Kohm, 2012-2013
%
% Diese Datei ist Teil der LaTeX2e KOMA-Script-Sammlung.
%
% Dieses Werk darf nach den Bedingungen der LaTeX Project Public Lizenz,
% Version 1.3c.
% Die neuste Version dieser Lizenz ist
%   http://www.latex-project.org/lppl.txt
% und Version 1.3c ist Teil aller Verteilungen von LaTeX
% Version 2005/12/01 und dieses Werks.
%
% Dieses Werk hat den LPPL-Verwaltungs-Status "author-maintained"
% (allein durch den Autor verwaltet).
%
% Der Aktuelle Verwalter und Autor dieses Werkes ist Markus Kohm.
%
% Dieses Werk besteht aus den in manifest.txt aufgefuehrten Dateien.
% ======================================================================
% \fi^^A meta-comment
%
% \CharacterTable
%  {Upper-case    \A\B\C\D\E\F\G\H\I\J\K\L\M\N\O\P\Q\R\S\T\U\V\W\X\Y\Z
%   Lower-case    \a\b\c\d\e\f\g\h\i\j\k\l\m\n\o\p\q\r\s\t\u\v\w\x\y\z
%   Digits        \0\1\2\3\4\5\6\7\8\9
%   Exclamation   \!     Double quote  \"     Hash (number) \#
%   Dollar        \$     Percent       \%     Ampersand     \&
%   Acute accent  \'     Left paren    \(     Right paren   \)
%   Asterisk      \*     Plus          \+     Comma         \,
%   Minus         \-     Point         \.     Solidus       \/
%   Colon         \:     Semicolon     \;     Less than     \<
%   Equals        \=     Greater than  \>     Question mark \?
%   Commercial at \@     Left bracket  \[     Backslash     \\
%   Right bracket \]     Circumflex    \^     Underscore    \_
%   Grave accent  \`     Left brace    \{     Vertical bar  \|
%   Right brace   \}     Tilde         \~}
%
% \iffalse^^A meta-comment
%<identify>%%% From File: $Id: scrlayer.dtx 1480 2013-10-31 10:00:02Z mjk $ (identify)
%<init>%%% From File: $Id: scrlayer.dtx 1480 2013-10-31 10:00:02Z mjk $ (init)
%<options>%%% From File: $Id: scrlayer.dtx 1480 2013-10-31 10:00:02Z mjk $ (options)
%<body>%%% From File: $Id: scrlayer.dtx 1480 2013-10-31 10:00:02Z mjk $ (body)
%<final>%%% From File: $Id: scrlayer.dtx 1480 2013-10-31 10:00:02Z mjk $ (final)
%<*dtx>
\ifx\ProvidesFile\undefined\def\ProvidesFile#1[#2]{}\fi
\begingroup
  \def\filedate$#1: #2-#3-#4 #5${\gdef\filedate{#4/#3/#2}}
  \filedate$Date: 2013-10-31 11:00:02 +0100 (Do, 31. Okt 2013) $
  \def\filerevision$#1: #2 ${\gdef\filerevision{v0.9.#2}}
  \filerevision$Revision: 1480 $
\endgroup
\ProvidesFile{scrlayer.dtx}[\filedate\space\filerevision\space
%</dtx>
%<*identify|doc>
%<package>\NeedsTeXFormat{LaTeX2e}[1995/12/01]
%<package>\ProvidesPackage{scrlayer}[%
%<doc>\ProvidesFile{scrlayer.tex}[%
% Sometimes following will be replaced by !KOMASCRIPTVERSION:
%!SCRLAYERVERSION
%<package>  package
%</identify|doc>
%<*dtx|identify|doc>
  (defining layers and page styles)]
%</dtx|identify|doc>
%<*dtx>
\ifx\documentclass\undefined
  \input scrdocstrip.tex
  \@@input scrkernel-version.dtx
  \@@input scrstrip.inc
  \KOMAdefVariable{COPYRIGHTFROM}{2012}
  \KOMAdefVariable{SCRLAYERVERSION}{\space\space\filedate\space\filerevision}%
  \generate{\usepreamble\defaultpreamble
    \file{scrlayer.sty}{%
      \from{scrlayer.dtx}{package,trace,scrlayer,identify}%
      \from{scrlayer.dtx}{package,trace,scrlayer,init}%
      \from{scrlayer.dtx}{package,trace,scrlayer,options}%
      \from{scrlayer.dtx}{package,trace,scrlayer,body}%
      \from{scrlayer.dtx}{package,trace,scrlayer,final}%
      \from{scrlogo.dtx}{logo}%
    }%
  }

  \batchinput{scrlayer-scrpage.dtx}
  \batchinput{scrlayer-notecolumn.dtx}
  \@@input scrstrop.inc
\else
  \let\endbatchfile\relax
\fi
\endbatchfile
%</dtx>
%<*driver>
  \documentclass{scrdoc}
  \addtolength{\textwidth}{-1em}
  \addtolength{\marginparwidth}{2em}
  \addtolength{\oddsidemargin}{2em}
  \usepackage[ngerman,english]{babel}
  \usepackage{url,babelbib}\bibliographystyle{babalpha-fl}
  \usepackage{listings}
  \usepackage{scrhack}
  \usepackage{etoolbox}
  \pretocmd\DescribeMacro{\ifhmode\else\bigskip\noindent\fi}{}{}
  \pretocmd\DescribeEnv{\ifhmode\else\bigskip\noindent\fi}{}{}
  \pretocmd\DescribeOption{\ifhmode\else\bigskip\noindent\fi}{}{}

  \CodelineIndex
  \RecordChanges
  \GetFileInfo{scrlayer.dtx}
  \title{The \KOMAScript{} package \texttt{scrlayer}%
    \footnote{This is version \fileversion\ of file \texttt{\filename}.}}
  \date{\filedate}
  \author{Markus Kohm}
  
  \newenvironment{Explain}{\par}{\par}
  \newcommand*{\length}{}
  \let\length\Length
  \let\endlength\endLength
  \let\Macro\cs
  \let\Length\Macro
  \let\Package\textsf
  \let\Class\Package
  \let\File\texttt
  \let\Option\texttt
  \newcommand*{\KOption}[1]{\Option{#1}\texttt{=}}
  \newcommand*{\OptionValue}[2]{\Option{#1}\texttt{=}\PValue{#2}}
  \let\Counter\texttt
  \let\Environment\texttt
  \let\ShowOutput\quote
  \let\endShowOutput\endquote
  \let\Pagestyle\texttt
  \newcommand*{\Parameter}[1]{\texttt{\marg{#1}}\linebreak[1]}
  \newcommand*{\OParameter}[1]{\texttt{\oarg{#1}}\linebreak[1]}
  \newcommand*{\MParameter}[2]{\texttt{(\meta{#1},\meta{#2})}\linebreak[1]}
  \providecommand\PParameter[1]{\mbox{\texttt{\{#1\}}}\linebreak[1]}
  \let\PName\meta
  \let\PValue\texttt
  \providecommand*{\autoref}[1]{\expandafter\AUTOREF#1:}
  \providecommand*{\AUTOREF}{}
  \makeatletter
  \def\AUTOREF#1:#2:{%
    \edef\@tempa{#1}%
    \edef\@tempb{tab}\ifx\@tempa\@tempb table~\fi
    \edef\@tempb{sec}\ifx\@tempa\@tempb section~\fi
    \ref{#1:#2}%
  }
  \providecommand*{\IndexCmd}[2][]{}
  \providecommand*{\textnote}[2][]{}
  \providecommand*\eTeX{\leavevmode\hbox{$\varepsilon$}-\TeX}
  \providecommand*\NTS{%
    \leavevmode\hbox{$\cal N\kern-0.35em\lower0.5ex\hbox{$\cal T$}%
      \kern-0.2emS$}}

  \lstnewenvironment{lstcode}{\lstset{language=[LaTeX]TeX}}{}
  \makeatother
  \sloppy% YOU SHOULD NOT DO THIS!!!

  \begin{document}
  \maketitle
  \DocInput{\filename}
  \DocInput{scrlayer-scrpage.dtx}
  \DocInput{scrlayer-notecolumn.dtx}
  \bibliography{guide}
  \PrintChanges
  \PrintIndex
  \end{document}
%</driver>
% \fi^^A meta-comment
%
% \selectlanguage{english}
%
% \changes{v0.0}{2012/01/01}{Start of new package}
%
%\iffalse^^A meta comment
%<*dtx|doc>
\chapter[{Defining Layers and Page Styles Using \Package{scrlayer}}]%
{Defining Layers and Page Styles Using \Package{scrlayer}%
%\footnote{This chapter has been generated from \File{scrlayer.dtx}.}%
}
\labelbase{scrlayer}

\BeginIndex{Package}{scrlayer}

%\fi^^A meta comment
% \begin{abstract}
\LaTeX{} itself doesn't know layers, but there are already packages
like \Package{eso-pic} or \Package{textpos}, that provide a kind of
background or foreground layer. \Package{scrlayer} is another package,
that provides such background and foreground layers, but in difference
to the other packages mentioned above these layers are part of the
page style definition. With this you may simply switch between usage
of layers by switching the page style.

To do so, the package also supports a low level interface to define page
styles using a layer stack, to put layers onto a page style's layer stack, to
put layers at the lowest position of a page style's layer stack, to put layers
before or after a layer of a page style's layer stack, to remove a layer from
a page style's layer stack and to remove doublets of layers of a page style's
layer stack. In short words: The page style interface of \Package{scrlayer}
provides commands to define layer-stack-based page styles and to manage those
layer stacks.

Nevertheless using the layers directly is recommended for advanced users only.
End user interfaces for beginners or average users are provided by additional
packages, that load \Package{scrlayer} on their own.
% \end{abstract}
%
% \tableofcontents
%

\section{State of Development Note}
\label{sec:scrlayer.draft}

Development of this package hasn't been finished yet. Because of this,
especially internal functionality may be changed in future. Most likely the
package will be extended. And because of the early state of development, you
should not expect any user documentation. In fact there's at least only some
developers documentation needed by the main developer himself.

%\iffalse^^A meta-comment
\EndIndex{Package}{scrlayer}
%\fi^^A meta-comment

\section{Early or Late Selection of Options}
\label{sec:scrlayer.options}

Package \Package{scrlayer} uses the option interface of \KOMAScript. Therefore
you may set options either within the optional argument of
\Macro{documentclass} as global options, or within the optional argument of
\Macro{usepackage} as local options, or with \Macro{KOMAoptions} or
\Macro{KOMAoption} as \KOMAScript{} option. Several of these options expect a
value. See the \KOMAScript{} manual, \File{scrguide.pdf}, for more information
about this.


\section{Some Generic Information}
\label{sec:scrlayer.generic}

The package needs some generic information about the class. Class authors may
help \Package{scrlayer} setting this information. Otherwise the package tries
to detect the information itself. This works, e.g., for the standard classes
and the \KOMAScript{} classes. But it may or may not fail with other classes.

This section describes some of the information, that class authors may
provide. Generally users need not to care about this.

%\iffalse^^A meta-comment
\begin{Declaration}
  \Macro{if@chapter}\ \PName{then code} \Macro{else}\ \PName{else code} \Macro{fi}%
\end{Declaration}
\BeginIndex{Cmd}{if@chapter}%
%\fi^^A meta-comment
% \DescribeMacro{\if@chapter}
If \Macro{if@chapter} is defined and \Macro{iftrue}, \Package{scrlayer} will
work including the chapter level, e.g., at option \Option{automark}. If it is
defined, but not \Macro{iftrue}, it only handles part, section, subsection,
sub\dots subsection, paragraph, subparagraph, sub\dots subparagraph. If the
macro isn't defined, \Package{scrlayer} searches for \Macro{chapter}. If
\Macro{chapter} is defined and not \Macro{relax}, \Package{scrlayer} will
define \Macro{if@chapter} to \Macro{iftrue}, otherwise \Macro{if@chapter} will
become \Macro{iffalse}.
%\iffalse^^A meta-comment
\EndIndex{Cmd}{if@chapter}
%\fi^^A meta-comment

%\iffalse^^A meta-comment
\begin{Declaration}
  \Macro{if@mainmatter}\ \PName{then code} \Macro{else}\ \PName{else code} \Macro{fi}%
\end{Declaration}
\BeginIndex{Cmd}{if@mainmatter}%
%\fi^^A meta-comment
% \DescribeMacro{\if@mainmatter}
Classes like \Class{book} define \Macro{frontmatter}, \Macro{mainmatter}, and
\Macro{backmatter}. They also use \Macro{if@mainmatter} to distinguish whether
or the current matter is the main matter. Classes like \Class{report} and
\Class{article} don't have \Macro{frontmatter}, \Macro{mainmatter}, or
\Macro{backmatter} and therefore also don't have \Macro{if@mainmatter}. 

For \Package{scrlayer} it's easier not to test always for the existence of the
matter commands, but to have \Macro{if@mainmatter} even with classes like
\Class{report} and \Class{article}, simply set to \Macro{iftrue}. So if
\Macro{if@mainmatter} is not defined, it will be defined to \Macro{iftrue}.

Some classes have \Macro{frontmatter}, \Macro{mainmatter}, or
\Macro{backmatter} but not \Macro{if@mainmatter}. In this case
\Package{scrlayer} will also define \Macro{if@mainmatter} to be \Macro{iftrue}
and it'll extend definition of \Macro{frontmatter}, \Macro{mainmatter}, and
\Macro{backmatter} to set \Macro{if@mainmatter} properly. Other matter
commands are not known, not tested, and not extended. So if there other matter
commands \Package{scrlayer} needs help of the class author to get
\Macro{if@mainmatter} set correctly.
%\iffalse^^A meta-comment
\EndIndex{Cmd}{if@mainmatter}
%\fi^^A meta-comment

%\iffalse^^A meta-comment
\begin{Declaration}
%\fi^^A meta-comment
% \DescribeMacro{\DeclareSectionNumberDepth}
% The command
  \Macro{DeclareSectionNumberDepth}%^^A
  \Parameter{level name}\Parameter{level depth}
% maps
%\iffalse^^A meta-comment
\end{Declaration}
\BeginIndex{Cmd}{DeclareSectionNumberDepth}%
With this command you may map
%\fi^^A meta-comment
the name of a heading level to a section numbering depth. With standard class
book, e.g., the \PName{level name} could be \PValue{part}, \PValue{chapter},
\PValue{section}, \PValue{subsection}, \PValue{subsubsection},
\PValue{paragraph}, or \PValue{subparagraph} and the corresponding
\PName{level depth}s would be -1, 0, 1, 2, 3, 4, and 5. Package
\Package{scrlayer} tries to determine the levels on it's own while loading
and while \Macro{begin}\PParameter{document}. But, if it fails, you may set it
on yourself using this command.
%\iffalse^^A meta-comment
\EndIndex{Cmd}{DeclareSectionNumberDepth}
%\fi^^A meta-comment


%\iffalse^^A meta-comment
\begin{Declaration}
%\fi^^A meta-comment
% \DescribeMacro{\footheight}
%\iffalse^^A meta-comment
  \Length{footheight}%
\end{Declaration}
\BeginIndex{Length}{footheight}%
%\fi^^A meta-comment
While \LaTeX{} already provides \Length{headheight} to set up the height of
the page head, it doesn't provide a corresponding length for the page
footer. Nevertheless \Package{scrlayer} needs this in several cases. So if
\Length{footheight} doesn't already exist, \Package{scrlayer} will define
it and initialise it to -12345\,sp. If it's value is still this magic value
while \Macro{begin}\PParameter{document}, it will be set to
\Length{baselineskip} then.
%\iffalse^^A meta-comment
\EndIndex{Length}{footheight}
%\fi^^A meta-comment


\section{Declaration of Layers}
\label{sec:scrlayer.layers}

A layer is a kind of logical sheet of transparent paper (in opposite to a
physical sheet of paper). One layer is stacked onto another layer and opaque
material on one layer may hide material on the layers below. The stack of all
layers together makes the physical page. Package \Package{scrlayer}
provides two such layer stacks for each page: a background layer stack and a
foreground layer stack. The background layer stack is behind the normal page
contents, the foreground layer stack is above the normal page contents. So the
normal contents is a kind of a separating layer.

A layer has several attributes. The first attribute is, whether or not
the layer is part of the foreground or the background. Background
layers will be printed before the main contents of the page. Optically
they will be behind the main contents. Foreground layers will be
printed after the main contents of the page. Optically they will be in
front of the main contents. By default, a layer is both, a background
layer \emph{and} a foreground layer and therefore will be printed
twice.

The second and third attributes are the horizontal and vertical position of
the layer. The forth and fifth attributes are the horizontal and vertical size
of the layer. As you can see, a layer may be smaller or larger than the
paper. 

But how are the horizontal an vertical positions measured? The answer
is the sixth attribute, the alignment. We can measure from the left edge of
the paper to the left edge of the layer, or from the left edge of the paper to
the middle of the layer, or from the left edge of the paper to the right edge
of the layer. We can measure from the top edge of the paper to the top edge of
the layer, or to the middle of the layer, or to the bottom edge of the layer.

The seventh and eights attributes are, whether or not a layer should be
printed onto left or right pages. By default a layer will be printed at both,
left and right pages. Note, that \LaTeX{} names left pages as even pages and
right pages as odd pages and that there are no left or even pages in
single-sided mode.

The ninth and tenth attributes are, whether or not a layer should be printed in
single-side mode or in two-side mode. By default a layer will be printed in
both, single-side mode and two-side mode. Nevertheless an even page layer will
never be printed in single-side mode and therefore isn't really a two-side
mode layer.

The eleventh and twelveth attributes are, whether or not a layer should be
printed onto float pages or non-float pages. \LaTeX{} produces float pages for
float environment like tables or figures, if they are allowed to be printed on
a page without normal page contents (see option \PValue{p} for
\Environment{figure} or \Environment{table}). Non-float pages aren't pages
without floats, but pages, that aren't float pages. They may contain floats
inside the text, on the top of the page, or on the bottom of the page. Very
large floats may seem to be page floats, while in reality they are top floats.

The thirteenth and last attribute is the contents of the layer. This is simply,
what should be printed, whenever the layer will be printed.

So we have thirteen attributes yet. Below in this manual we will see additional
attributes, that may be build by these twelve attribute. Because of this, we
call these twelve attributes the primary attributes.

%\iffalse^^A meta-comment
\begin{Declaration}
%\fi^^A meta-comment
% \DescribeMacro{\DeclareLayer}
% \DescribeMacro{\DeclareNewLayer}
% \DescribeMacro{\ProvideLayer}
% \DescribeMacro{\RedeclareLayer}
% \DescribeMacro{\ModifyLayer}
% The command:
  \Macro{DeclareLayer}\OParameter{option list}\Parameter{layer name}
%\iffalse^^A meta-comment
  \\\Macro{DeclareNewLayer}\OParameter{option list}\Parameter{layer name}
  \\\Macro{ProvideLayer}\OParameter{option list}\Parameter{layer name}
  \\\Macro{RedeclareLayer}\OParameter{option list}\Parameter{layer name}
  \\\Macro{ModifyLayer}\OParameter{option list}\Parameter{layer name}
\end{Declaration}
\BeginIndex{Cmd}{DeclareLayer}%
\BeginIndex{Cmd}{DeclareNewLayer}%
\BeginIndex{Cmd}{ProvideLayer}%
\BeginIndex{Cmd}{RedeclareLayer}%
\BeginIndex{Cmd}{ModifyLayer}%
Command \Macro{DeclareLayer}
%\fi^^A meta-comment
declares or defines a layer with the name \PName{layer name}. It doesn't care
whether or not a layer with this name already exists. Argument \PName{layer
  name} must be fully expandable and the expansion has to result in
letters. Some other characters will be tolerated, but only letters are
recommended.

The \PName{option list} is a comma separated list of \PName{option}s. An
\PName{option} may be either a \PName{key} or a \PName{key} followed be an
equal sign followed by a \PName{value}. We call this a
\OptionValue{\PName{key}}{\PName{value}} option. Each \PName{key} is the
representation of a layer attribute. See \autoref{tab:scrlayer.layerkeys} for
more information about the names of the \PName{key}s and the corresponding
attributes.

\begin{center}
  \captionaboveof{table}{The \PName{key}s representing a layer attribute}%
  \label{tab:scrlayer.layerkeys}%
  \begin{description}
  \item[\OptionValue{align}{\PName{alignment character}s} --] a description
    of the wanted alignment. Each \PName{alignment character} influences
    either, how the \PName{length} of \Option{hoffset} or \Option{voffset}
    will be used. Several \PName{alignment character}s may be used together
    (without comma or space). No macros should be used here! Valid
    \PName{alignment character}s are:
    \begin{description}
    \item[\PValue{b} --] align the layer with its bottom edge to the given
      \Option{length} of \Option{voffset} from the top edge of the paper.
    \item[\PValue{c} --] align the layer with its centre to the given
      \PValue{length} of \Option{hoffset} from the left edge and of
      \Option{voffset} from the top edge of the paper.
    \item[\PValue{l} --] align the layer with its left edge to the given
      \PValue{length} of \Option{hoffset} from the left edge of the paper.
    \item[\PValue{r} --] align the layer with its right edge to the given
      \PValue{length} of \Option{hoffset} from the left edge of the paper.
    \item[\PValue{t} --] align the layer with its top edge to the given
      \Option{length} of \Option{voffset} from the top edge of the paper.
    \end{description}
  \item[\OptionValue{area}{%^^A
      \Parameter{hoffset}\Parameter{voffset}%^^A
      \Parameter{width}\Parameter{height}} --] composing option, that results
    in \OptionValue{hoffset}{\PName{hoffset}},
    \OptionValue{voffset}{\PName{voffset}},
    \OptionValue{width}{\PName{width}}, \OptionValue{height}{\PName{height}}.
  \item[\Option{background} --] print the layer only in the background, but not
    in the foreground. This makes a background-only layer in opposite to the
    default of layers which are both, background and foreground layers. The
    option doesn't expect any value. By the default the attribute is not set.
  \item[\Option{bottommargin} --] composing option, that sets
    \Option{hoffset}, \Option{voffset}, \Option{width}, \Option{height}, and
    \Option{align} to horizontally span the paper from the left edge to the
    right and vertically span the area below the footer down to the bottom
    edge of the paper.
  \item[\OptionValue{clone}{\PName{layer name}} --] composing option, that
    sets all primary attributes of the layer to the same values as the primary
    attributes of the layer with the given \PName{layer name}. Note, that
    \PName{layer name} has to be fully expandable and should expand to letters
    only. Some additional characters will be tolerated, but they are not
    recommended!
  \item[\OptionValue{contents}{\PName{code}} --] the \PName{code} will be
    expanded whenever the layer is printed. So the \PName{code} is what you
    will see. No checks for valid code will be done. So errors in \PName{code}
    may result in several failures on each page, that prints the layer.
  \item[\Option{evenpage} --] print the layer on even pages only, but not on
    odd pages. The option doesn't expect any value. By the default the
    attribute is not set. Note, that this attribute includes \Option{twoside}.
  \item[\Option{floatpage} --] print the layer on float pages only, but not on
    other pages. The option doesn't expect any value. By the default the
    attribute is not set.
  \item[\Option{foot} --] composing option, that sets \Option{hoffset},
    \Option{voffset}, \Option{width}, \Option{height}, and \Option{align} to
    horizontally span the text area and vertically span the page footer
    defined by the new \LaTeX{} length \Length{footheight}.
  \item[\Option{footskip} --] composing option, that sets \Option{hoffset},
    \Option{voffset}, \Option{width}, \Option{height}, and \Option{align} to
    horizontally span the text area and vertically span the distance between
    the text area and the page footer (note, that this is not the same like
    \Length{footskip}).
  \item[\Option{foreground} --] print the layer only in the foreground, but not
    in the background. This makes a foreground-only layer in opposite to the
    default of layers which are both, background and foreground layers. The
    option doesn't expect any value. By the default the attribute is not set.
  \item[\Option{head} --] composing option, that sets \Option{hoffset},
    \Option{voffset}, \Option{width}, \Option{height}, and \Option{align} to
    horizontally span the text area and vertically span the page head defined
    by usual\LaTeX{} length \Length{headheight}.
  \item[\Option{headsep} --] composing option, that sets \Option{hoffset},
    \Option{voffset}, \Option{width}, \Option{height}, and \Option{align} to
    horizontally span the text area and vertically span the distance between
    the page head and the text area.
  \item[\OptionValue{height}{\PName{length}} --] the height of the
    layer. Note, that \PName{length} may either a \LaTeX{} length, declared
    using \Macro{newlength}, or a \TeX{} length, declared using
    \Macro{newdimen} or \Macro{newskip}, a length value like 10\,pt, or a
    dimensional expression using +, -, /, *, (, and ). For more information
    about valid dimensional expression see \cite[section~3.5]{manual:eTeX}.
  \item[\OptionValue{hoffset}{\PName{length}} --] the offset of the layer
    (depending on \Option{align} either left edge of the layer, middle of the
    layer or right edge of the layer) from the left edge of the paper. See
    \Option{height} for more information about valid content of
    \PName{length}.
  \item[\Option{innermargin} --] composing option, that sets \Option{hoffset},
    \Option{voffset}, \Option{width}, \Option{height}, and \Option{align} to
    horizontally span the distance between the right edge of text area and the
    right edge of the paper on even pages or the distance between the left
    edge of the paper and the left edge of the text area on odd pages and
    vertically span the whole paper from the top edge to the bottom edge.
  \item[\Option{leftmargin} --] composing option, that sets \Option{hoffset},
    \Option{voffset}, \Option{width}, \Option{height}, and \Option{align} to
    horizontally span the distance between the left edge of the paper and the
    left edge of the text area and vertically span the whole paper from the
    top edge to the bottom edge.
  \item[\Option{nonfloatpage} --] don't print the layer on float pages, but on
    other pages only. The option doesn't expect any value. By the default the
    attribute is not set.
  \item[\Option{oddpage} --] print the layer on odd pages only, but not on even
    pages. The option doesn't expect any value. By the default the attribute
    is not set.
  \item[\Option{oneside} --] print the layer in single-side mode only, but not
    in two-side mode. The option doesn't expect any value. By the default the
    attribute is not set.
  \item[\Option{outermargin} --] composing option, that sets \Option{hoffset},
    \Option{voffset}, \Option{width}, \Option{height}, and \Option{align} to
    horizontally span the distance between the left edge of the paper and the
    left edge of the text area on even pages or the distance between the right
    edge of the text area and the right edge of the paper on odd pages and
    vertically span the whole paper from the top edge to the bottom edge.
  \item[\Option{page} --] composing option, that sets \Option{hoffset},
    \Option{voffset}, \Option{width}, \Option{height}, and \Option{align} to
    horizontally and vertically span the whole paper from the left edge to the
    right edge and the top edge to the bottom edge.
  \item[\Option{rightmargin} --] composing option, that sets \Option{hoffset},
    \Option{voffset}, \Option{width}, \Option{height}, and \Option{align} to
    horizontally span the distance between the right edge of text area and the
    right edge of the paper and vertically span the whole paper from the top
    edge to the bottom edge.
  \item[\Option{textarea} --] composing option, that sets \Option{hoffset},
    \Option{voffset}, \Option{width}, \Option{height}, and \Option{align} to
    horizontally and vertically span the whole text area from the left edge to
    the right edge and the top edge to the bottom edge.
  \item[\Option{topmargin} --] composing option, that sets \Option{hoffset},
    \Option{voffset}, \Option{width}, \Option{height}, and \Option{align} to
    horizontally span the whole page from the left edge to the right edge and
    vertically span the distance between the top edge of the paper and the
    page head.
  \item[\Option{twoside} --] print the layer in two-side mode only, but not in
    single-side mode. The option doesn't expect any value. By the default the
    attribute is not set.
  \item[\OptionValue{voffset}{\PName{length}} --] the offset of the layer
    (depending on \Option{align} either top edge of the layer, middle of the
    layer or bottom edge of the layer) from the top edge of the paper. See
    \Option{height} for more information about valid content of
    \PName{length}.
  \item[\OptionValue{width}{\PName{length}} --] the width of the layer. See
    \Option{height} for more information about valid content of
    \PName{length}.
  \end{description}
\end{center}

The difference between \Macro{DeclareLayer} and \Macro{DeclareNewLayer} is,
that using \Macro{DeclareNewLayer} would result in an error, if a layer with
the same \PName{layer name} already exists. So you may prevent yourself using
the same \PName{layer name} twice by mistake.

The difference between \Macro{DeclareLayer} and \Macro{ProvideLayer} is, that
using \Macro{ProvideLayer} would be simply ignored, if a layer with the same
\PName{layer name} already exists. So it is something like: \emph{declare the
  layer only, if is hasn't been declared already.}

The difference between \Macro{DeclareLayer} and \Macro{RedeclareLayer} is,
that using \Macro{RedeclareLayer} would result in an error, if a layer with
the same \PName{layer name} doesn't exist already. So it may not be used to
define a new layer.

The difference between \Macro{RedeclareLayer} and \Macro{ModifyLayer} is, that
\Macro{RedeclareLayer} resets the layer to the default, before declaring it
new. \Macro{ModifyLayer} doesn't reset it, so only the attributes, set by the
\PName{option list} will be changed.
%
%\iffalse^^A meta-comment
\EndIndex{Cmd}{ModifyLayer}%
\EndIndex{Cmd}{RedeclareLayer}%
\EndIndex{Cmd}{ProvideLayer}%
\EndIndex{Cmd}{DeclareNewLayer}%
\EndIndex{Cmd}{DeclareLayer}%
%\fi^^A meta-comment

%\iffalse^^A meta-comment
\begin{Declaration}
%\fi^^A meta-comment
% \DescribeMacro{\IfLayerExists}
% The command
  \Macro{IfLayerExists}%^^A
  \Parameter{string}\Parameter{then-code}\Parameter{else-code}
%\iffalse^^A meta-comment
\end{Declaration}
\BeginIndex{Cmd}{IfLayerExists}%
This command
%\fi^^A meta-comment
may be used to execute code depending on whether or not a layer has been
defined already. If the layer exists \PName{then-code} will be executed,
otherwise \PName{else-code}. Note, that the command cannot really test whether
a layer exists. It uses a heuristic, that will never be false negative, but
may be false positive. Nevertheless, if it is false positive something went
wrong, either an incompatible package has been used or the user made something
he shouldn't do.
%\iffalse^^A meta-comment
\EndIndex{Cmd}{IfLayerExists}
%\fi^^A meta-comment

%\iffalse^^A meta-comment
\begin{Declaration}
%\fi^^A meta-comment
% \DescribeMacro{\DestroyLayer}
% The command
  \Macro{DestroyLayer}%^^A
  \Parameter{layer name}
%\iffalse^^A meta-comment
\end{Declaration}
\BeginIndex{Cmd}{DestroyLayer}%
This command
%\fi^^A meta-comment
sets all macros corresponding with the layer with given \PName{layer name} to
\Macro{relax}, if a layer with that name exists. After this the layer may not
be used any longer. But it doesn't matter, if the layer is still part of the
layer list of a page style, because such destroyed layers will be
ignored. Nevertheless destroyed layers may be defined new using
\Macro{DeclareNewLayer} or \Macro{ProvideLayer}, but couldn't be changed using
\Macro{RedeclareLayer} or \Macro{ModifyLayer} any longer. The command is
intended to be used inside \Macro{scrlayerOnAutoRemoveInterface} to remove
layers, that have been defined by an interface using removable macros of that
interface.
%\iffalse^^A meta-comment
\EndIndex{Cmd}{DestroyLayer}
%\fi^^A meta-comment

%\iffalse^^A meta-comment
\begin{Declaration}
%\fi^^A meta-comment
% The command
% \DescribeMacro{\layercontentsmeasure}
% \DescribeOption{draft}
  \Macro{layercontentsmeasure}%
%\iffalse^^A meta-comment
  \\\KOption{draft}{\PName{simple switch}}%
\end{Declaration}
\BeginIndex{Option}{draft~=\PName{simple switch}}
\BeginIndex{Cmd}{layercontentsmeasure}%
The command \Macro{layercontentsmeasure}
%\fi^^A meta-comment
is internally used, if option \Option{draft} has been set, so visualise
the layers. The visualisation will be done with a centimetre ruler at the top
and left edge of the layer and an inch ruler at the bottom and right edge of
the layer. The rulers will be drawn behind the content of the layer. If you
would you, could also use it as content of a layer.
%\iffalse^^A meta-comment
\EndIndex{Cmd}{layercontentsmeasure}
\EndIndex{Option}{draft~=\PName{simple switch}}
%\fi^^A meta-comment


\section{Declaration and Management of Page Styles}
\label{sec:scrlayer.pagestyles}

Until now we know layers, but we don't know how to use them. The
perhaps astonishing answer is: with page styles. In \LaTeX{}, page
styles usually define heads and foots of odd and even pages.

The head and foot of odd pages will be printed on pages with odd
page number in two-side mode or on all pages in single-side mode. This is
something like the layer attributes \Option{oddpage} and \Option{evenpage}.

The page head will be printed before the main contents of a page. The page
footer will be printed after the main contents of a page. So this is something
like the layer attributes \Option{background} and \Option{foreground}.

So it's obvious to declare page styles to be a list of layers. But instead of
having only four attributes \Option{oddpage}, \Option{evenpage},
\Option{background}, and \Option{foreground} all the attributes of layers
shown in \autoref{sec:scrlayer.layers} may be used.

The outcome of this is, that one kind of page styles \Package{scrlayer}
provides are layer page styles. A layer page style consists of layers and
several \emph{hooks}. For description of layers see
\autoref{sec:scrlayer.layers}.  The \emph{hooks} are points in the expansion
or execution of page styles and you may add additional code, that will be
expanded there.

Another kind of page styles \Package{scrlayer} provides are alias page
style. An alias page style simply consists of one other page style. In
other words, the name of an alias page style is only an alias name of
another page style, the aliased or original page style. Because of
this, the manipulation of an alias page style results in the
manipulation of the original page style. If the original page style is
an alias page style too, the manipulation will result in the
manipulation of the aliased page style of that original page style and
so on until a real page style will be manipulated. You may not only
alias layer page styles made with \Package{scrlayer}, but all kind of
page styles.


% \DescribeMacro{\currentpagestyle}
%\iffalse^^A meta-comment
\begin{Declaration}
  \Macro{currentpagestyle}
\end{Declaration}
\BeginIndex{Cmd}{currentpagestyle}%
%\fi^^A meta-comment
Package scrlayer patches \Macro{pagestyle} to set \Macro{currentpagestyle} to
the currently active page style. Note, that \Macro{thispagestyle} does not
change \Macro{currentpagestyle}. But if you use \Macro{thispagestyle} the
result of \Macro{currentpagestyle} may be changed while execution of the
\LaTeX{} output routine. This may be relevant only, if
\Macro{currentpagestyle} has been used protected until execution of the output
routine. 

Note, that the layer page styles described later in this section, won't need
the patch of \Macro{pagestyle} to set \Macro{currentpagestyle}. The patch has
been made for usage with other page styles. Note also, that
\Macro{currentpagestyle} is empty before the first \Macro{pagestyle} after
loading \Package{scrlayer}. So if you define an end user page style interface,
it may be useful to use an implicit \Macro{pagestyle} to set the current page
style to a default page style.
%\iffalse^^A meta-comment
\EndIndex{Cmd}{currentpagestyle}
%\fi^^A meta-comment

%\iffalse^^A meta-comment
\begin{Declaration}
%\fi^^A meta-comment
% \DescribeMacro{\BeforeSelectAnyPageStyle}
% \DescribeMacro{\AfterSelectAnyPageStyle}
% The command
  \Macro{BeforeSelectAnyPageStyle}\Parameter{code}%
%\iffalse^^A meta-comment
  \\\Macro{AfterSelectAnyPageStyle}\Parameter{code}%^^A
\end{Declaration}
\BeginIndex{Cmd}{BeforeSelectAnyPageStyle}%
\BeginIndex{Cmd}{AfterSelectAnyPageStyle}%
The command \Macro{BeforeSelectAnyPageStyle}
%\fi^^A meta-comment
adds \PName{code} to hook, that will be executed inside of \Macro{pagestyle}
just before the page style will be selected. You may use \texttt{\#1} as a
placeholder for the argument of \Macro{pagestyle}.

The command \Macro{AfterSelectAnyPageStyle}%^^A
% \iffalse^^A meta-comment
\Parameter{code}%^^A
% \fi^^A meta-comment
\ is similar, but the \PName{code} will be executed just after the page style
has been selected and after \Macro{currentpagestyle} has been set to the name
of real page style.

Note, that \PName{code} of both commands will be executed only, if a page
style will be selected using \Macro{pagestyle}, but not, e.\,g., if a page
style will be selected using \Macro{thispagestyle}. Note also, that you cannot
remove \PName{code} from the hook after adding it. But the \PName{code} will
be added locally, so you may use a group to limit the scope of
\PName{code}.%^^A
%\iffalse^^A meta-comment
\EndIndex{Cmd}{AfterSelectAnyPageStyle}
\EndIndex{Cmd}{BeforeSelectAnyPageStyle}
%\fi^^A meta-comment

%\iffalse^^A meta-comment
\begin{Declaration}
%\fi^^A meta-comment
% \DescribeMacro{\DeclarePageStyleAlias}
% \DescribeMacro{\DeclareNewPageStyleAlias}
% \DescribeMacro{\ProvidePageStyleAlias}
% \DescribeMacro{\RedeclarePageStyleAlias}
% The command
  \Macro{DeclarePageStyleAlias}%^^A
  \Parameter{alias page style name}\Parameter{original page style name}
%\iffalse^^A meta-comment
  \\\Macro{DeclareNewPageStyleAlias}%
  \Parameter{alias page style name}\Parameter{original page style name}
  \\\Macro{ProvidePageStyleAlias}%
  \Parameter{alias page style name}\Parameter{original page style name}
  \\\Macro{RedeclarePageStyleAlias}%
  \Parameter{alias page style name}\Parameter{original page style name}
\end{Declaration}
\BeginIndex{Cmd}{DeclarePageStyleAlias}%
\BeginIndex{Cmd}{DeclareNewPageStyleAlias}%
\BeginIndex{Cmd}{ProvidePageStyleAlias}%
\BeginIndex{Cmd}{RedeclarePageStyleAlias}%
These Commands
%\fi^^A meta-comment
may be used to define a page style with name \PName{alias page style name},
that is simply an alias for already existing page style with name
\PName{original page style name}. If there's already a page style \PName{alias
  page style name} it will be destroyed before creating the alias using
\Macro{DeclarePageStyleAlias} or \Macro{RedeclarePageStyleAlias}.

\Macro{DeclareNewPageStyleAlias} will throw an error message, if a page style
\PName{alias page style name} has already been defined before. It doesn't
matter if the already defined page style is a layer page style, an alias page
style or another page style.

\Macro{ProvidePageStyleAlias} will define the alias only, if a page style
\PName{alias page style name} hasn't been defined before. If a page style
\PName{alias page style name} already exists nothing will be done.

\Macro{RedeclarePageStyleAlias} expects, that a page style \PName{alias page
  style name} already exists. In this case it will destroy it and define the
alias newly. In the other case you'll get an error.
%\iffalse^^A meta-comment
\EndIndex{Cmd}{RedeclarePageStyleAlias}%
\EndIndex{Cmd}{ProvidePageStyleAlias}%
\EndIndex{Cmd}{DeclareNewPageStyleAlias}%
\EndIndex{Cmd}{DeclarePageStyleAlias}
%\fi^^A meta-comment


%\iffalse^^A meta-comment
\begin{Declaration}
%\fi^^A meta-comment
% \DescribeMacro{\DestroyPageStyleAlias}
% The command
  \Macro{DestroyPageStyleAlias}\Parameter{page style name}%
%\iffalse^^A meta-comment
\end{Declaration}
\BeginIndex{Cmd}{DestroyPageStyleAlias}%
This command
%\fi^^A meta-comment
makes the page style with given \PName{page style name} \LaTeX-undefined, if
it is an alias for another page style. After this, the page style may be
defined newly with, e.g., \Macro{DeclareNewAliasPageStyle} or
\Macro{ProvideAliasPageStyle}. The command is intended to be used inside of
\Macro{scrlayerOnAutoRemoveInterface} to remove page styles, that have been
declared by an interface and uses removable macros of that interface.
%\iffalse^^A meta-comment
\EndIndex{Cmd}{DestroyPageStyleAlias}
%\fi^^A meta-comment


%\iffalse^^A meta-comment
\begin{Declaration}
%\fi^^A meta-comment
% \DescribeMacro{\GetRealPageStyle}
% The command
  \Macro{GetRealPageStyle}\Parameter{page style name}%
%\iffalse^^A meta-comment
\end{Declaration}
\BeginIndex{Cmd}{GetRealPageStyle}%
The command
%\fi^^A meta-comment
will result in the (recursive) real page name of the page style, if 
the page style with given name \PName{page style name} is an alias of
another page style. In all other cases, even if there's no alias and no page
style named \PName{page style name}, the result would be simply \PName{page
  style name}. The command is fully expandable and may be used, e.g., in the
second argument of \Macro{edef}.
%\iffalse^^A meta-comment
\EndIndex{Cmd}{GetRealPageStyle}
%\fi^^A meta-comment


%\iffalse^^A meta-comment
\begin{Declaration}
%\fi^^A meta-comment
% \DescribeMacro{\DeclarePageStyleByLayers}
% \DescribeMacro{\DeclareNewPageStyleByLayers}
% \DescribeMacro{\ProvidePageStyleByLayers}
% \DescribeMacro{\RedeclarePageStyleByLayers}
% The command
  \Macro{DeclarePageStyleByLayers}%^^A
  \OParameter{option list}\Parameter{page style name}\Parameter{layer list}%
%\iffalse^^A meta-comment
  \\\Macro{DeclareNewPageStyleByLayers}%^^A
  \OParameter{option list}\Parameter{page style name}\Parameter{layer list}%
  \\\Macro{ProvidePageStyleByLayers}%^^A
  \OParameter{option list}\Parameter{page style name}\Parameter{layer list}%
  \\\Macro{RedeclarePageStyleByLayers}%^^A
  \OParameter{option list}\Parameter{page style name}\Parameter{layer list}%
\end{Declaration}
\BeginIndex{Cmd}{DeclarePageStyleByLayers}%
\BeginIndex{Cmd}{DeclareNewPageStyleByLayers}%
\BeginIndex{Cmd}{ProvidePageStyleByLayers}%
\BeginIndex{Cmd}{RedeclarePageStyleByLayers}%
These commands
%\fi^^A meta-comment
declares a page style with \PName{page style name}. The page style will
consist of the layers given in \PName{layer list}, a comma separated list of
layer names. Note, that the \PName{page style name} and the layer names at the
\PName{layer list} must be fully expandable and should expand to
letters. Several other characters will be tolerated, but nevertheless, they
aren't recommended.

The \PName{option list} is a comma separated list of
\OptionValue{\PName{key}}{\PName{value}} options. These options may be used to
set additional features. Currently they are used to set the code, that should
be expanded or executed at several \emph{hooks}. See the introduction to this
section for more general information about \emph{hooks}. See
\autoref{tab:scrlayer.pagestyle.hooks} for more information about the hooks
and their purpose.

\begin{center}
  \parbox{\textwidth}{%
  \captionaboveof{table}{The \emph{hook} options for page styles (in order of
    execution)}\nobreak\vskip4\baselineskip}\vskip-5\baselineskip
  \label{tab:scrlayer.pagestyle.hooks}
  \begin{description}
  \item[\texttt{\KOption{onselect}\PName{code}}:] Execute \PName{code}
    whenever the page style will be selected using, e.g.,
    \Macro{pagestyle}. Note, that \Macro{thispagestyle} doesn't select the
    page style immediately, but asynchronously inside \LaTeX's output routine.
  \item[\texttt{\KOption{oninit}\PName{code}}:] Execute \PName{code} whenever
    the output of the layers of a page style will be initialised. Note, that
    this will be done twice for every page: once for background layers and
    once for foreground layers.
  \item[\texttt{\KOption{ononeside}\PName{code}}:] Execute \PName{code}
    whenever the output of the layers of a page style in single-side mode will
    initialised.  Note, that this will be done twice for every page: once for
    background layers and once for foreground layers.
  \item[\texttt{\KOption{ontwoside}\PName{code}}:] Execute \PName{code}
    whenever the output of the layers of a page style in two-side mode will
    initialised.  Note, that this will be done twice for every page: once for
    background layers and once for foreground layers.
  \item[\texttt{\KOption{onoddpage}\PName{code}}:] Execute \PName{code}
    whenever the output of the layers of a page style on an odd page will
    initialised. Note, that this will be done twice for every page: once for
    background layers and once for foreground layers. Note also, that in
    single-side mode all pages are odd pages, not only pages with odd page
    numbers.
  \item[\texttt{\KOption{onevenpage}\PName{code}}:] Execute \PName{code}
    whenever the output of the layers of a page style on an even page will
    initialised. Note, that this will be done twice for every page: once for
    background layers and once for foreground layers. Note also, that there
    aren't even pages in single-side mode, but all pages are odd pages, not
    only pages with odd page numbers.
  \item[\texttt{\KOption{onfloatpage}\PName{code}}:] Execute \PName{code}
    whenever the output of the layers of a page style on a float page will
    initialised. Note, that this will be done twice for every page: once for
    background layers and once for foreground layers. Note also, that float
    pages are only those pages with p-placed floating objects.
  \item[\texttt{\KOption{onnonfloatpage}\PName{code}}:] Execute \PName{code}
    whenever the output of the layers of a page style on a non-float page will
    initialised. Note, that this will be done twice for every page: once for
    background layers and once for foreground layers. Note also, that
    non-float pages are all pages, that aren't float-pages. Those pages may
    have t-placed, h-placed, b-placed, or no floating objects.
  \item[\texttt{\KOption{onbackground}\PName{code}}:] Execute \PName{code}
    whenever the output of the layers of a page style in the background of a
    page will initialised. Note, that this will be done once for every page.
  \item[\texttt{\KOption{onforeground}\PName{code}}:] Execute \PName{code}
    whenever the output of the layers of a page style in the foreground of a
    page will initialised. Note, that this will be done once for every page.
  \end{description}
\end{center}

The difference of \Macro{DeclarePageStyleByLayers} and
\Macro{DeclareNewPageStyleByLayers} is, that \Macro{DeclareNewPageStyleByLayers}
will result in an error, if a page style with name \PName{page style name}
already exists. Note, that declaring a page style, that is an alias of another
page style (see \Macro{DeclareAliasPageStyle} prior in this section), will not
re-declare the page style itself, but it's real page style (see
\Macro{GetRealPageStyle} prior in this section).

The difference of \Macro{DeclarePageStyleByLayers} and
\Macro{ProvidePageStyleByLayers} is, that \Macro{ProvidePageStyleByLayers}
will simply do nothing, if there's already a page style with name \PName{page
  style name}. In difference to \Macro{DeclareNewPageStyleByLayers} it won't
raise an error in this case.

The difference of \Macro{DeclarePageStyleByLayers} and
\Macro{RedeclarePageStyleByLayers} is, that \Macro{RedeclarePageStyleByLayers}
may be used only, if the real page style of \PName{page style name} already
exists. Otherwise an error would occur.
%\iffalse^^A meta-comment
\EndIndex{Cmd}{RedeclarePageStyleByLayers}%
\EndIndex{Cmd}{ProvidePageStyleByLayers}%
\EndIndex{Cmd}{DeclareNewPageStyleByLayers}%
\EndIndex{Cmd}{DeclarePageStyleByLayers}%
%\fi^^A meta-comment


%\iffalse^^A meta-comment
\begin{Declaration}
  \Pagestyle{@everystyle@}\\
  \Pagestyle{empty}
\end{Declaration}
\BeginIndex{Pagestyle}{@everysel@}%
\BeginIndex{Pagestyle}{empty}%
%\fi^^A meta-comment
There are two somehow special, default layer page styles. The first one is
\Pagestyle{@everystyle@}. This page style shouldn't be used normally, but the
layers of this page style will be used by all the other layer page styles. So
adding a layer to this page style would be similar to adding this layer to all
other layer page styles even the empty one. There's one difference: Layer
referencing commands of the page style interface like
\Macro{ForEachLayerOfPageStyle}, \Macro{AddLayerToPageStyleBeforeLayer}, or
\Macro{AddLayerToPageStyleAfterLayer} ignore the layers of
\Pagestyle{@everystyle@} if they are used for another layer page style.

The other somehow special page style is \Pagestyle{empty}. Normally page style
\Pagestyle{empty} is defined by the \LaTeX{} kernel, to be a page style
without page head or page foot. Package{scrlayer} re-defines it to be a layer
page style without any layer. Nevertheless you may use it like every other
layer page style too. The main advantage above the \LaTeX{} kernel's empty
page style is, that it also executes the layers of special layer page style
\Pagestyle{@everysel@}.
%\iffalse^^A meta-comment
\EndIndex{Pagestyle}{empty}%
\EndIndex{Pagestyle}{@everysel@}%
%\fi^^A meta-comment


% \iffalse^^A meta-comment
\begin{Declaration}
% \fi^^A meta-comment
% \DescribeOption{onpsselect}%
% \DescribeOption{onpsinit}%
% \DeleteShortVerb{\|}%
% \DescribeOption{onps(one|two)side}%
% \DescribeOption{onps(odd|even)page}%
% \DescribeOption{onps(float|nonfloat)page}%
% \DescribeOption{onps(back|fore)ground}%
% \MakeShortVerb{\|}%
% \iffalse^^A meta-comment
  \KOption{onpsselect}\PValue{code}\\
  \KOption{onpsinit}\PValue{code}\\
  \KOption{onpsoneside}\PValue{code}\\
  \KOption{onpstwoside}\PValue{code}\\
  \KOption{onpsoddpage}\PValue{code}\\
  \KOption{onpsevenpage}\PValue{code}\\
  \KOption{onpsfloatpage}\PValue{code}\\
  \KOption{onpsnonfloatpage}\PValue{code}\\
  \KOption{onpsbackground}\PValue{code}\\
  \KOption{onpsforeground}\PValue{code}
\end{Declaration}
\BeginIndex{Option}{onpsselect}%
\BeginIndex{Option}{onpsinit}%
\BeginIndex{Option}{onpsoneside}%
\BeginIndex{Option}{onpstwoside}%
\BeginIndex{Option}{onpsoddpage}%
\BeginIndex{Option}{onpsevenpage}%
\BeginIndex{Option}{onpsfloatpage}%
\BeginIndex{Option}{onpsnonfloatpage}%
\BeginIndex{Option}{onpsbackground}%
\BeginIndex{Option}{onpsforeground}%
% \fi^^A meta-comment
There's also a \KOMAScript{} option for each of those \texttt{hooks}. The
names of the \KOMAScript{} options are similar to the names of the page style
options, but with ``\texttt{ps}'' inserted behind ``\texttt{on}''. The value of
the \KOMAScript{} options are the initial defaults of the corresponding
\texttt{hooks}. This default will be extended by every usage of the page style
options at the \PName{option list}. You may remove the default, using
\Macro{ModifyLayerPageStyleOptions} described later in this section.
% \iffalse^^A meta-comment
\EndIndex{Option}{onpsforeground}%
\EndIndex{Option}{onpsbackground}%
\EndIndex{Option}{onpsnonfloatpage}%
\EndIndex{Option}{onpsfloatpage}%
\EndIndex{Option}{onpsevenpage}%
\EndIndex{Option}{onpsoddpage}%
\EndIndex{Option}{onpstwoside}%
\EndIndex{Option}{onpsoneside}%
\EndIndex{Option}{onpsinit}%
\EndIndex{Option}{onpsselect}%
% \fi^^A meta-comment


%\iffalse^^A meta-comment
\begin{Declaration}
  \KOption{deactivatepagestylelayers}\PName{simple switch}\\
%\fi^^A meta-comment
% \DescribeMacro{\ForEachLayerOfPageStyle}
% The command
  \Macro{ForEachLayerOfPageStyle}%^^A
  \Parameter{page style name}\Parameter{code}
%\iffalse^^A meta-comment
\end{Declaration}
\BeginIndex{Cmd}{ForEachLayerOfPageStyle}%
This command
%\fi^^A meta-comment
may be used to process \PName{code} for every layer, that is a member of the
layers list of a page style with given \PName{page style name}. Inside of
\PName{code} the place holder \PValue{\#1} may be used for the name of the
current layer.
%\iffalse^^A meta-comment
\begin{Example}
%\fi^^A meta-comment
% \par
If you want to output the names of all layers of page style
\PValue{scrheadings}, you may us:
\begin{lstcode}
  \let\commaatlist\empty
  \ForEachLayerOfPageStyle{scrheadings}{%
    \commaatlist#1\gdef\commaatlist{, }}
\end{lstcode}
%\iffalse^^A meta-comment
\end{Example}
%\fi^^A meta-comment
\KOMAScript{} option \Option{deactivatepagestylelayers} may be used to
deactivate all layers within \Macro{ForEachLayerOfPageStyle}. If the options
has been switched on, \Macro{ForEachLayerOfPageStyle} will not longer process
\PName{code} for any layer. Several other commands of \Package{scrlayer} also
uses \Macro{ForEachLayerOfPageStyle} internally. So these also won't process
any layer. You may use this options, e.g., to hide all layers.

Please note, that \PName{code} will be executed inside a group!
% \iffalse^^A meta-comment
\EndIndex{Cmd}{ForEachLayerOfPageStyle}
%\fi^^A meta-comment


%\iffalse^^A meta-comment
\begin{Declaration}
%\fi^^A meta-comment
% \DescribeMacro{\AddLayersToPageStyle}
% \DescribeMacro{\AddLayersAtBeginOfPageStyle}
% \DescribeMacro{\AddLayersAtEndOfageStyle}
% \DescribeMacro{\RemoveLayersFromPageStyle}
% The command
  \Macro{AddLayersToPageStyle}%^^A
  \Parameter{page style name}\Parameter{layer list}%
%\iffalse^^A meta-comment
  \\\Macro{AddLayersAtBeginOfPageStyle}%^^A
  \Parameter{page style name}\Parameter{layer list}%
  \\\Macro{AddLayersAtEndOfPageStyle}%^^A
  \Parameter{page style name}\Parameter{layer list}%
  \\\Macro{RemoveLayersFromPageStyle}%^^A
  \Parameter{page style name}\Parameter{layer list}%
\end{Declaration}
\BeginIndex{Cmd}{AddLayersToPageStyle}%
\BeginIndex{Cmd}{AddLayersAtBeginOfPageStyle}%
\BeginIndex{Cmd}{AddLayersAtEndOfPageStyle}%
\BeginIndex{Cmd}{RemoveLayersFromPageStyle}%
The first command
%\fi^^A meta-comment
adds all layers of the comma separated list of layers \PName{layer list} at
the end of the layer list of layer page style \PName{page style
  name}. \Macro{AddLayersAtEndOfPageStyle} is an alias for the same. If you
want to add the new layers at the begin of the layer list of a layer page
style you may use \Macro{AddLayersAtBeginOfPageStyle}. Note, that the layers
will be added in the order of the \PName{layer list}. The first layer at
\PName{layer list} will be added first, the second layer will be added second
and so on. So with \Macro{AddLayersAtBeginOfPageStyle} the last layer at
\PName{layer list} will become the new first layer of the layer list of layer
page style \PName{page style name}.

Command \Macro{RemoveLayersFromPageStyle} may be used to remove layers from
the layer list of layer page style \PName{page style name} instead of adding
them. Note, that layers, that are part of \PName{layer list} but not part of
the page style's layer list, will be ignored.

Adding or removing layers from a page style, that is not a layer page style or
an alias of a layer page style would be an error and result in an error
message.%
%\iffalse^^A meta-comment
\EndIndex{Cmd}{RemoveLayersFromPageStyle}%
\EndIndex{Cmd}{AddLayersAtEndOfPageStyle}%
\EndIndex{Cmd}{AddLayersAtBeginOfPageStyle}%
\EndIndex{Cmd}{AddLayersToPageStyle}
%\fi^^A meta-comment


%\iffalse^^A meta-comment
\begin{Declaration}
%\fi^^A meta-comment
% \DescribeMacro{\AddLayersToPageStyleBeforeLayer}
% The commands
  \Macro{AddLayersToPageStyleBeforeLayer}%^^A
  \Parameter{page style name}\Parameter{layer list}%^^A
  \Parameter{reference layer name}
% and
  \\\Macro{AddLayersToPageStyleAfterLayer}%^^A
  \Parameter{page style name}\Parameter{layer list}%^^A
  \Parameter{reference layer name}
%\iffalse^^A meta-comment
\end{Declaration}
\BeginIndex{Cmd}{AddLayersToPageStyleBeforeLayer}%
\BeginIndex{Cmd}{AddLayersToPageStyleAfterLayer}%
These commands
%\fi^^A meta-comment
are similar to the commands described before, but they do not add the layers
at the begin or end of the layer list of a layer page style, but just before
or after a reference layer at the layer list of a layer page style. Note, that
in this case the order of the \PName{layer list} will be same in the layer
list of \PName{page style name} after adding. If the reference layer named
\PName{reference layer name} is not part of the layer list of the layer page
style, nothing happens.
%\iffalse^^A meta-comment
\EndIndex{Cmd}{AddLayersToPageStyleAfterLayer}
\EndIndex{Cmd}{AddLayersToPageStyleBeforeLayer}
%\fi^^A meta-comment


% \DescribeMacro{\UnifyLayersAtPageStyle}
%\iffalse^^A meta-comment
\begin{Declaration}
  \Macro{UnifyLayersAtPageStyle}\Parameter{page style name}
\end{Declaration}
\BeginIndex{Cmd}{UnifyLayersAtPageStyle}%
%\fi^^A meta-comment
With the commands described before in this section you may not only add
different layers to a page style, but even add the same layer several times to
a page style. In most cases it doesn't make sense to have one layer several
times at the layer list of a layer page style. So you may use
\Macro{UnifyLayersAtPageStyle}%^^A
%\Parameter{page style name}^^A
\ to remove all dupes of layers from the layer list of a layer page
style. Note that the order of layers may change! So if you want a special
order, you should remove all layers and add the layers in the order you want
instead of using \Macro{UnifyLayersAtPageStyle}. 
%\iffalse^^A meta-comment
\EndIndex{Cmd}{UnifyLayersAtPageStyle}
%\fi^^A meta-comment


%\iffalse^^A meta-comment
\begin{Declaration}
%\fi^^A meta-comment
% \DescribeMacro{\ModifyLayerPageStyleOptions}
% \DescribeMacro{\AddToLayerPageStyleOptions}
% The command
  \Macro{ModifyLayerPageStyleOptions}%^^A
  \Parameter{page style name}\Parameter{option list}
%\iffalse^^A meta-comment
  \\\Macro{AddToLayerPageStyleOptions}%^^A
  \Parameter{page style name}\Parameter{option list}
\end{Declaration}
\BeginIndex{Cmd}{ModifyLayerPageStyleOptions}%
\BeginIndex{Cmd}{AddToLayerPageStyleOptions}%
Command \Macro{ModifyLayerPageStyleOptions}
%\fi^^A meta-comment
may be used to modify the page style options of a layer page style. Only
options at the comma separated \PName{option list} will be set to the new
values given in \PName{option list} if the new value is not empty. Options,
that are not at \PName{option list}, will stay unchanged. If you want to set
an option to \emph{do nothing} you may use value \Macro{relax}. Note, that
setting an option to a new value using \Macro{ModifyLayerPageStyleOptions}
will remove the previous value including the global default value.

\Macro{AddToLayerPageStyleOptions} differs from
\Macro{ModifyLayerPageStyleOptions} in that point. It will not overwrite the
previous values, but adds\,---\,or more precisely: concatenates\,---\, the new
values to the previous values of the options at \PName{option list}.
%\iffalse^^A meta-comment
\EndIndex{Cmd}{AddToLayerPageStyleOptions}
\EndIndex{Cmd}{ModifyLayerPageStyleOptions}
%\fi^^A meta-comment


%\iffalse^^A meta-comment
\begin{Declaration}
%\fi^^A meta-comment
% \DescribeMacro{\IfLayerPageStyleExists}
% \DescribeMacro{\IfRealLayerPageStyleExists}
% The command
  \Macro{IfLayerPageStyleExists}%^^A
  \Parameter{page style name}\Parameter{then code}\Parameter{else code}%
%\iffalse^^A meta-comment
  \\\Macro{IfRealLayerPageStyleExists}%^^A
  \Parameter{page style name}\Parameter{then code}\Parameter{else code}%
\end{Declaration}
\BeginIndex{Cmd}{IfLayerPageStyleExists}%
\BeginIndex{Cmd}{IfRealLayerPageStyleExists}%
Command \Macro{IfLayerPageStyleExists}
%\fi^^A meta-comment
tests, whether or not the real page style of \PName{page style name} is a
layer page style. If the test is true, \PName{then code} will be executed. If
\PName{page style name} is neither a layer page style, nor an alias of a layer
page style, nor an alias of an alias of \dots\ a layer page style, \PName{else
  code} will be executed. Internally this command is often used to throw an
error message if you use one of the layer page style commands with an
\PName{page style name} that doesn't correspond with a layer page style.

Command \Macro{IfRealLayerPageStyleExists} is similar, but \PName{then code}
will only be executed, if \PName{page style name} itself is the name of a
layer page style. So \PName{else code} will even be executed, if \PName{page
  style name} is an alias name of a layer page style or the alias name of an
alias name of \dots\ a layer page style.
%\iffalse^^A meta-comment
\EndIndex{Cmd}{IfRealLayerPageStyleExists}
\EndIndex{Cmd}{IfLayerPageStyleExists}
%\fi^^A meta-comment


%\iffalse^^A meta-comment
\begin{Declaration}
%\fi^^A meta-comment
% \DescribeMacro{\IfLayerAtPageStyle}
% \DescribeMacro{\IfSomeLayersAtPageStyle}
% \DescribeMacro{\IfLayersAtPageStyle}
% The command
  \Macro{IfLayerAtPageStyle}%
  \Parameter{page style name}\Parameter{layer name}%^^A
  \Parameter{then code}\Parameter{else code}%
%\iffalse^^A meta-comment
  \\\Macro{IfSomeLayerAtPageStyle}%
  \Parameter{page style name}\Parameter{layer list}%^^A
  \Parameter{then code}\Parameter{else code}%
  \\\Macro{IfLayerAtPageStyle}%
  \Parameter{page style name}\Parameter{layer list}%^^A
  \Parameter{then code}\Parameter{else code}%
\end{Declaration}
\BeginIndex{Cmd}{IfLayerAtPageStyle}%
\BeginIndex{Cmd}{IfSomeLayersAtPageStyle}%
\BeginIndex{Cmd}{IfLayersAtPageStyle}%
Command \PName{IfLayerAtPageStyle}
%\fi^^A meta-comment
may be used to test, whether or not a layer named \PName{layer name} is a
member of the layer list of a given page style. If the test is true, the
\PName{then code} will be executed. If the layer is not a member of the layer
list of \PName{page style name}, the \PName{else code} will be executed.

Commands \Macro{IfSomeLayerAtPageStyle} and \Macro{IfLayersAtPageStyle} do not
only test one layer but several layers at a given, comma separated
\PName{layer list}. \Macro{IfSomeLayerAtPageStyle} will execute the
\PName{then code} if \emph{at least one} of the layers at \PName{layer list}
is a member of the layer list of \PName{page style name}. In difference
\Macro{IfLayersAtPageStyle} executes the \PName{then code} only, if \emph{all}
of the layers at \PName{layer list} are members of the layer list of
\PName{page style name}.
%\iffalse^^A meta-comment
\EndIndex{Cmd}{IfLayersAtPageStyle}
\EndIndex{Cmd}{IfSomeLayersAtPageStyle}
\EndIndex{Cmd}{IfLayerAtPageStyle}
%\fi^^A meta-comment


%\iffalse^^A meta-comment
\begin{Declaration}
%\fi^^A meta-comment
% \DescribeMacro{\DestroyRealLayerPageStyle}
% The command
  \Macro{DestroyRealLayerPageStyle}\Parameter{page style name}
%\iffalse^^A meta-comment
\end{Declaration}
\BeginIndex{Cmd}{DestroyRealLayerPageStyle}%
Command \Macro{DestroyRealLayerPageStyle}
%\fi^^A meta-comment
makes the page style named \PName{page style name} undefined, if and only if
it is a layer page style. Nothing will be happen if it is an alias name of a
layer page style, if it is another page style, or if it isn't a page style. If
\PName{page style name} is the name of the current page style the current page
style will become a kind of empty page style. If the special page
style\,---\,this may be set using \Macro{thispagestyle}\,---\,is \PName{page
  style name}, this will be simply reset.

Note, that the layers of the page style won't be destroyed automatically. If
you want to destroy the layers too, you may use
\begin{lstcode}
  \ForEachLayerOfPageStyle{...}{\DestroyLayer{#1}}
\end{lstcode}
\emph{before} destroying the layer page style.

The command is intended to be used inside the auto-remove code of an interface
See following \ref{sec:scrlayer.enduserinterfaces} for more information about
auto-remove code.
%\iffalse^^A meta-comment
\EndIndex{Cmd}{DestroyRealLayerPageStyle}
%\fi^^A meta-comment


\section{End User Interfaces}
\label{sec:scrlayer.enduserinterfaces}

Package \Package{scrlayer} provides an interface to define and manage
(concurrent) end user interfaces. Maybe future releases of \KOMAScript{} will
provide parts of this by package \Package{scrbase}, but currently package
\Package{scrlayer} provides its own interface definition commands. 

This section only describes the interface commands for defining end user
interfaces. This is not of interest for end users, but only for authors of end
user interfaces. End users will find information about the end user interfaces
in the sections about the particular end user interface, e.g.,
\autoref{sec:scrlayer.scrpage}.

%\iffalse^^A meta-comment
\begin{Declaration}
%\fi^^A meta-comment
% \DescribeMacro{\scrlayerInitInterface}
% The command
  \Macro{scrlayerInitInterface}\OParameter{interface name}
%\iffalse^^A meta-comment
\end{Declaration}
\BeginIndex{Cmd}{scrlayerInitInterface}%
Command \Macro{scrlayerInitInterface}
%\fi^^A meta-comment
registers a new interface. The \PName{interface name} must be unique. If you
try to initialise an already initialised interface an error will occur. This
command is obligatory and mandatory for interfaces. It should be the first
interface command and therefore has been described first. If the optional
argument is omitted, \PValue{\Macro{@currname}.\Macro{@currext}} will be
used instead. For classes and packages this will be the file name of the class
or package while loading the class or package. But you may use any sequence of
characters with category letter or other.
%\iffalse^^A meta-comment
\EndIndex{Cmd}{scrlayerInitInterface}
%\fi^^A meta-comment


%\iffalse^^A meta-comment
\begin{Declaration}
  \KOption{forceoverwrite}\PName{simple switch}\\
  \KOption{autoremoveinterfaces}\PName{simple switch}\\
%\fi^^A meta-comment
% \DescribeMacro{\scrlayerAddToInterface}
% \DescribeMacro{\scrlayerAddCsToInterface}
%\iffalse^^A meta-comment
  \Macro{scrlayerAddToInterface}%
  \OParameter{interface name}\Parameter{command}\Parameter{code}\\
  \Macro{scrlayerAddCsToInterface}%
  \OParameter{interface name}\Parameter{command sequence}\Parameter{code}
\end{Declaration}
\BeginIndex{Option}{forceoverwrite}%
\BeginIndex{Option}{autoremoveinterfaces}%
\BeginIndex{Cmd}{scrlayerAddToInterface}%
\BeginIndex{Cmd}{scrlayerAddCsToInterface}%
%\fi^^A meta-comment
One of the special features of end user interfaces is, that they should
register all interface dependent commands (also known as \emph{macros}). You
may do this using \Macro{scrlayerAddToInterface}%^^A
%\OParameter{interface name}\Parameter{command}\Parameter{code}%^^A
. If your interface generates macros not only at load time but also at run
time or if the interface name shouldn't be the class's or package's name, you
have to use the optional argument to add the command to a dedicated
interface. An error will occur, if the interface hasn't been initialised
before.

The first mandatory argument is the \PName{command}\footnote{The
  \PName{command} consists in the backslash followed by a \PName{command
    sequence} consisting in characters with category code letter or one other
  character, or \PName{command} consists in one active character (without
  backslash).}, that should be added to the interface. If the command can be
added to the interface, it will be added to the interface, will be set to
\Macro{relax} and \PName{code} will be executed. You can use, e.g.,
\Macro{newcommand}\PName{command} inside of \PName{code} to define
\PName{command}.

But when can a command be defined? If a command is undefined or \Macro{relax}
it can be defined. If a command has already been defined and registered for
another interface \emph{and} if \KOMAScript{} option
\Option{autoremoveinterface} has been switched on, the other interface will be
removed automatically and the new command will be set to \Macro{relax} and
will be registered for the given interface. If a command
has already been defined but isn't part of another interface \emph{and} if
\KOMAScript{} option \Option{forceoverwrite} has been switched on, the command
will be set to \Macro{relax} and will be registered for the given interface.

Command \Macro{scrlayerAddCsToInterface} is similar to
\Macro{scrlayerAddToInterface} but doesn't expect a command as first,
mandatory argument, but a command sequence\footnote{A command sequence may
  consist of any characters with category code letter or other.}.
%\iffalse^^A meta-comment
\EndIndex{Cmd}{scrlayerAddCsToInterface}%
\EndIndex{Cmd}{scrlayerAddToInterface}
\EndIndex{Option}{autoremoveinterfaces}%
\EndIndex{Option}{forceoverwrite}%
%\fi^^A meta-comment


%\iffalse^^A meta-comment
\begin{Declaration}
%\fi^^A meta-comment
% \DescribeMacro{\scrlayerOnAutoRemoveInterface}
% The command
  \Macro{scrlayerOnAutoRemoveInterface}%^^A
  \OParameter{interface name}\Parameter{code}
%\iffalse^^A meta-comment
\end{Declaration}
\BeginIndex{Cmd}{scrlayerOnAutoRemoveInterface}%
Command \Macro{scrlayerOnAutoRemoveInterface}
%\fi^^A meta-comment
registers \PName{code} to be executed, if the interface will be automatically
removed (see \Option{autoremoveinterfaces} prior in this section). This may be
used, e.g., to automatically destroy layers or page styles (see
\Macro{DestroyLayer}, \Macro{DestroyAliasPageStyle}, and
\Macro{DestroyRealLayerPageStyle}).
%\iffalse^^A meta-comment
\EndIndex{Cmd}{scrlayerOnAutoRemoveInterface}
%\fi^^A meta-comment


%\iffalse
%</dtx|doc>
%\fi
%
% \StopEventually{}
%
%
% \section{Implementation of \Package{scrlayer}}
%
% This section if for developers only.
% Users may continue at \autoref{sec:scrlayer.scrpage} at
% page~\pageref{sec:scrlayer.scrpage}.
%
% \iffalse
%<*package>
%<*identify>
% \fi
%
%\iffalse^^A meta-comment
%</identify>
%</package>
%<*package|interface>
%\fi^^A meta-comment
%
% \subsection{Initialising some Values before the Options}
%
% \iffalse^^A meta-comment
%<*init>
% \fi^^A meta-comment
%
% Initialisation before all options.
%
% While there are \KOMAScript{} options, we need \Package{scrkbase} to declare
% them, but the interfaces also needs \Package{scrlayer} which already
% includes \Package{scrkbase}.
%    \begin{macrocode}
%<package>\RequirePackage{scrkbase}[2013/03/05]
%<interface>\RequirePackage{scrlayer}
%    \end{macrocode}
%
%
% \begin{macro}{\scrlayer@AtEndOfPackage}
% Initial \Macro{AtEndOfPackage}, but after end of package
% \Macro{@firstofone}.
%    \begin{macrocode}
\scr@ifundefinedorrelax{scrlayer@AtEndOfPackage}{%
  \AtEndOfPackage{\let\scrlayer@AtEndOfPackage\@firstofone}%
}{%
  \ifx\scrlayer@AtEndOfPackage\@firstofone
    \AtEndOfPackage{\let\scrlayer@AtEndOfPackage\@firstofone}%
  \fi
}
\let\scrlayer@AtEndOfPackage\AtEndOfPackage
%    \end{macrocode}
% \end{macro}^^A \sls@AtEndOfPackage
%
% \begin{macro}{\scrlayer@testunexpectedarg}
% We'll have several \KOMAScript{} options, that didn't expect an
% value. So we use this general helper to test the value and report an error
% if it is not empty (or \Macro{relax}).
%    \begin{macrocode}
%<*package>
\newcommand*{\scrlayer@testunexpectedarg}[2]{%
  \ifx\relax#2\relax\else
    \PackageError{scrlayer}{unexpected value to `#1'}{%
      Option `#1' doesn't expect any value.\MessageBreak
      If you'll continue, the value `#2' will be ignored.%
    }%
  \fi
}
%</package>
%    \end{macrocode}
% \end{macro}^^A \scrlayer@testunexpectedarg
%
% \begin{macro}{\if@chapter}
% We need this later. But it is something general. So we initialise it as
% early as possible.
%    \begin{macrocode}
%<*package>
\scr@ifundefinedorrelax{if@chapter}{%
  \newif\if@chapter
  \scr@ifundefinedorrelax{chapter}{\@chapterfalse}{\@chaptertrue}%
}{}
%    \end{macrocode}
% \end{macro}^^A \if@chapter
%
% \begin{macro}{\if@mainmatter}
% Some classes define \Macro{frontmatter} or \Macro{mainmatter}, but do not
% define \Macro{if@mainmatter}. But we nee some information about the matter,
% so in that case, we add it.
%    \begin{macrocode}
\scr@ifundefinedorrelax{if@mainmatter}{%
  \scr@ifundefinedorrelax{mainmatter}{%
    \newif\if@mainmatter\@mainmattertrue
  }{%
    \PackageWarningNoLine{scrlayer}{%
      \string\mainmatter\space defined without
      \string\if@mainmatter!\MessageBreak
      Note, that several packages need
      \string\if@mainmatter\space\MessageBreak
      to detect whether or no the main matter has been\MessageBreak
      entered.  So does scrlayer. Because of this\MessageBreak
      it will extend \string\mainmatter, now%
    }%
    \newif\if@mainmatter\@mainmattertrue
    \expandafter\def\expandafter\mainmatter\expandafter{%
      \expandafter\@mainmattertrue\mainmatter}%
    \scr@ifundefinedorrelax{frontmatter}{}{%
      \expandafter\def\expandafter\frontmatter\expandafter{%
        \expandafter\@mainmatterfalse\frontmatter}
    }%
    \scr@ifundefinedorrelax{backmatter}{}{%
      \expandafter\def\expandafter\backmatter{%
        \expandafter\@mainmatterfalse\backmattter}%
    }%
  }%
}{}
%</package>
%    \end{macrocode}
% \end{macro}^^A \if@mainmatter
%
% \iffalse^^A meta-comment
%</init>
% \fi^^A meta-comment
%
%
% \subsection{Process Options}
%
% \iffalse^^A meta-comment
%<*body>
% \fi^^A meta-comment
%
% The very first thing at  the body is processing the options:
%    \begin{macrocode}
\KOMAProcessOptions\relax
%    \end{macrocode}
%
% \subsection{Body Initialisation}
%
% Currently not needed.
%
% \iffalse
%</body>
% \fi
%
%
% \subsection{Extended Running Heads}
%
% Package \Package{scrpage2} changes and extends the running head mechanisms
% of \LaTeX{} and the classes. Most of this are basic features an therefore
% done already by \Package{scrlayer}. But not the deprecated options.
%
% \begin{option}{markcase}
% \begin{description}
% \item[\texttt{=\meta{setting}}] one of: \texttt{upper}, \texttt{lower},
% \texttt{used}, or \texttt{ignoreuppercase}.
% \end{description}\noindent
% The two options \Option{markuppercase} and \Option{markusedcase} become
% deprecated and are replace be the single option \Option{markcase}. Note,
% that interface \Package{scrlayer-scrpage} has to delay this option to
% overload case setting of option \Option{pagestyleset}.
%    \begin{macrocode}
%<*options>
\KOMA@key{markcase}{%
%<interface&scrpage>\scrlayer@AtEndOfPackage{%
  \begingroup
    \KOMA@set@ncmdkey{markcase}{reserved@a}{%
      {upper}{0},{lower}{1},{used}{2},%
      {ignoreuppercase}{3},{nouppercase}{3},%
      {ignoreupper}{3},{noupper}{3}%
    }{#1}%
    \ifx\FamilyKeyState\FamilyKeyStateProcessed
      \aftergroup\FamilyKeyStateProcessed
      \ifnum \reserved@a>\m@ne
        \aftergroup\let\aftergroup\MakeMarkcase
        \ifcase \reserved@a
          \aftergroup\MakeUppercase
          \aftergroup\scrlayer@forceignoreuppercasefalse
        \or
          \aftergroup\MakeLowercase
          \aftergroup\scrlayer@forceignoreuppercasefalse
        \or
          \aftergroup\@firstofone
          \aftergroup\scrlayer@forceignoreuppercasefalse
        \else
          \aftergroup\scrlayer@ignoreuppercase
          \aftergroup\scrlayer@forceignoreuppercasetrue
        \fi
      \fi
    \else
      \aftergroup\FamilyKeyStateUnknownValue
    \fi
  \endgroup
%<interface&scrpage>}%
}
%<interface>\scrlayer@AddCsToInterface{KV@KOMA.\@currname.\@currext @markcase}
%    \end{macrocode}
% \begin{macro}{\MakeMarkcase}
% We use this instead of, e.g., \Macro{MakeUppercase} for every layer! So the
% name seams to be wrong, but it is common, so we use it here.
%    \begin{macrocode}
%<*package>
\providecommand*{\MakeMarkcase}[1]{#1}
%    \end{macrocode}
% \begin{macro}{\scrlayer@ignoreuppercase}
% We span a group and set \Macro{uppercase} and \Macro{MakeUppercase} to
% \Macro{@firstofone}.
%    \begin{macrocode}
\DeclareRobustCommand*{\scrlayer@ignoreuppercase}[1]{%
  \begingroup
    \let\uppercase\@firstofone
    \let\MakeUppercase\@firstofone
    \expandafter\let\csname MakeUppercase \endcsname\@firstofone
    #1%
  \endgroup
}
%    \end{macrocode}
% This is almost enough, but standard classes still would show upper-case
% letters at table of contents, list of figures, list of tables, index and
% bibliography. So we need an additional workaround.
% \begin{macro}{\ifscrlayer@forceignoreuppercase}
%    \begin{macrocode}
\newif\ifscrlayer@forceignoreuppercase
%</package>
%</options>
%    \end{macrocode}
% \end{macro}^^A \ifscrlayer@forceignoreuppercase
% \end{macro}^^A \scrlayer@ignoreuppercase
% \end{macro}^^A \MakeMarkcase
% \end{option}^^A markcase
%
%
% \begin{macro}{\headmark}
% Inside a page style, this macro is either \Macro{rightmark} or
% \Macro{leftmark}. Outside its \LaTeX-undefined and therefore it's not an
% interface command, but has to be undefined:
%    \begin{macrocode}
%<*package&body>
\@ifundefined{headmark}{}{%
  \PackageWarningNoLine{scrlayer}{%
    \string\headmark\space detected!\MessageBreak
    \string\headmark\space will either be set to
    \string\rightmark\MessageBreak
    or \string\leftmark inside of page styles.\MessageBreak
    This means, that \string\headmark\space will be overwritten\MessageBreak
    at every page layer usage!\MessageBreak
    Nevertheless it will stay unchanged outside\MessageBreak
    of page layers.\MessageBreak
    I hope, this won't break your document%
  }%
}
%</package&body>
%    \end{macrocode}
% \end{macro}^^A \headmark
%
% \begin{macro}{\pagemark}
% The page number together with its font setting. It's robust and will never
% be part of the interface.
%    \begin{macrocode}
%<*package&body>
\@ifundefined{pagemark}{%
  \DeclareRobustCommand\pagemark{{\pnumfont{\thepage}}}%
}{}%
%    \end{macrocode}
% \begin{macro}{\pnumfont}
% \begin{macro}{\scr@fnt@pagenumber}
% The low-level page number font command. It is deprecated to redefine or use
% this and it may already be defined. These commands will not become part of
% the interface!
%    \begin{macrocode}
\@ifundefined{pnumfont}{%
  \newcommand{\pnumfont}{\normalfont}%
}{}
\@ifundefined{scr@fnt@pagenumber}{%
  \newcommand{\scr@fnt@pagenumber}{\pnumfont}%
}{}
%</package&body>
%    \end{macrocode}
% \end{macro}^^A \scr@fnt@pagenumber
% \end{macro}^^A \pnumfont
% \end{macro}^^A \pagemark
%
% \begin{macro}{\partmarkformat}
% \begin{macro}{\chaptermarkformat}
% \begin{macro}{\sectionmarkformat}
% \begin{macro}{\GenericMarkFormat}
% All the \Macro{\dots markformat} macros of \KOMAScript{} are also
% supported by \Package{scrlayer} and it uses them actively. The generic
% definition has been moved from \Macro{@seccntmarkformat} to
% \Macro{GenericMarkFormat}. This is one more difference to
% \Package{scrpage2}. The defaults are compatible to the standard
% classes. These commands will not become part of the interface and other
% interfaces should redefine them only, if they are not already defined.
%    \begin{macrocode}
%<*package&body>
\providecommand*{\partmarkformat}{\partname\ \thepart. \ }%
\if@chapter
  \providecommand*{\@chapapp}{\chaptername}%
  \providecommand*{\chaptermarkformat}{\@chapapp\ \thechapter. \ }%
  \providecommand*{\sectionmarkformat}{\thesection. \ }%
\else
  \providecommand*{\sectionmarkformat}{\GenericMarkFormat{section}}%
\fi
\scr@ifundefinedorrelax{@seccntmarkformat}{%
  \providecommand*{\GenericMarkFormat}{\@seccntformat}%
}{%
  \providecommand*{\GenericMarkFormat}[1]{\@seccntmarkformat{#1}}%
}
%</package&body>
%    \end{macrocode}
% Note, that the other \Macro{\dots markformat} will be defined by
% \Macro{scrlayer@level@init}.
% \end{macro}^^A \GenericMarkFormat
% \end{macro}^^A \sectionmarkformat
% \end{macro}^^A \chaptermarkformat
% \end{macro}^^A \partmarkformat
%
% \begin{macro}{\@mkleft}
% \begin{macro}{\@mkright}
% \begin{macro}{\@mkdouble}
% These are new in \Package{scrlayer}. They may be updated, whenever
% \Macro{@mkboth} will be updated. Otherwise they get a working default
% definition. These commands will not become part of the interface and other
% interfaces should redefine them only, if they are not already defined.
%    \begin{macrocode}
%<*package&body>
\providecommand*{\@mkleft}{%
  \begingroup
    \ifx\@mkboth\markboth \aftergroup\markleft
    \else 
      \ifx\@mkboth\@gobbletwo \aftergroup\@gobble
      \else \def\@gobbletwo##1##2{}%
        \ifx \@mkboth\@gobbletwo \aftergroup\@gobble
        \else
          \PackageWarning{scrlayer}{%
            package incompatibility detected!\MessageBreak
            \string\@mkboth it neither \string\markboth nor any\MessageBreak
            kind of two arguments gobbling,\MessageBreak
            e.g., \string\@gobbletwo.\MessageBreak
            So I don't known, what to do\MessageBreak
            with \string\@mkleft.\MessageBreak
            Nevertheless, \string\markleft\space will be\MessageBreak
            used%
          }%
          \aftergroup\markleft
        \fi
      \fi
    \fi
  \endgroup
}%
\providecommand*{\@mkright}{%
  \begingroup
    \ifx\@mkboth\markboth \aftergroup\markright
    \else 
      \ifx\@mkboth\@gobbletwo \aftergroup\@gobble
      \else \def\@gobbletwo##1##2{}%
        \ifx \@mkboth\@gobbletwo \aftergroup\@gobble
        \else
          \PackageWarning{scrlayer}{%
            package incompatibility detected!\MessageBreak
            \string\@mkboth it neither \string\markboth nor any\MessageBreak
            kind of two arguments gobbling,\MessageBreak
            e.g., \string\@gobbletwo.\MessageBreak
            So I don't known, what to do\MessageBreak
            with \string\@mkright.\MessageBreak
            Nevertheless, \string\markright\space will be\MessageBreak
            used%
          }%
          \aftergroup\markright
        \fi
      \fi
    \fi
  \endgroup
}%
\providecommand*{\@mkdouble}[1]{%
  \@mkboth{#1}{#1}%
}
%</package&body>
%    \end{macrocode}
% \end{macro}^^A \@mkdouble
% \end{macro}^^A \@mkright
% \end{macro}^^A \@mkleft
%
% \begin{macro}{\markleft}
% \begin{macro}{\@markleft}
% \LaTeX{} itself provides \Macro{markboth} and \Macro{markright} but not
% \Macro{markleft}. So we add it.
%    \begin{macrocode}
%<*package&body>
\providecommand*{\markleft}[1]{%
  \begingroup
    \let\label\relax \let\index\relax \let\glossary\relax
    \expandafter\@markleft\@themark {#1}%
    \@temptokena \expandafter{\@themark}%
    \mark{\the\@temptokena}%
  \endgroup
  \if@nobreak\ifvmode\nobreak\fi\fi
}
\providecommand{\@markleft}[3]{%
  \@temptokena {#2}%
  \unrestored@protected@xdef\@themark{{#3}{\the\@temptokena}}%
}
%</package&body>
%    \end{macrocode}
% \end{macro}^^A \@markleft
% \end{macro}^^A \markleft
%
%
% \begin{option}{autooneside}
% \begin{macro}{\ifscrlayer@autooneside}
% Decide whether or not use the optional argument of \Macro{automark} in
% single-side layout.
%    \begin{macrocode}
%<*options>
\KOMA@ifkey{autooneside}{scrlayer@autooneside}\scrlayer@autoonesidetrue
%<interface>\scrlayer@AddCsToInterface{KV@KOMA.\@currname.\@currext @autooneside}
%</options>
%    \end{macrocode}
% \end{macro}^^A \ifscrlayer@autooneside
% \end{option}^^A autooneside
%
%
% \begin{option}{automark}
% \begin{option}{manualmark}
% Maybe we will extend these options later. Currently they do almost the
% same they do at \Package{scrpage2}. The difference is, that single-side or
% two-side doesn't matter here (but it does inside of the definitions of the
% marks itself).
% ToDo: Maybe \Option{manualmark} should become deprecated and
% \Option{automark} should have simple values or a new option, that also
% handles \Option{autooneside}?
%    \begin{macrocode}
%<*options>
\KOMA@key{automark}[]{%
  \scrlayer@testunexpectedarg{automark}{#1}%
  \scrlayer@AtEndOfPackage{%
    \if@chapter
      \automark[section]{chapter}%
    \else
      \automark[subsection]{section}%
    \fi
  }%
  \FamilyKeyStateProcessed
}
%<*interface>
\scrlayer@AddCsToInterface{KV@KOMA.\@currname.\@currext @automark}
\scrlayer@AddCsToInterface{KV@KOMA.\@currname.\@currext @automark@default}
%</interface>
\KOMA@key{manualmark}[]{%
  \scrlayer@testunexpectedarg{manualmark}{#1}%
  \scrlayer@AtEndOfPackage{\manualmark}%
  \FamilyKeyStateProcessed
}
%<*interface>
\scrlayer@AddCsToInterface{KV@KOMA.\@currname.\@currext @manualmark}
\scrlayer@AddCsToInterface{KV@KOMA.\@currname.\@currext @manualmark@default}
%</interface>
%</options>
%    \end{macrocode}
% \end{option}^^A manualmark
% \end{option}^^A automark
%
% \begin{macro}{\manualmark}
% Switch to manual marks. This resets \Macro{@mkleft}, \Macro{@mkright},
% \Macro{@mkdouble}, \Macro{@mkboth} and the \Macro{\dots mark} of all known
% levels.
%    \begin{macrocode}
%<*package&body>
\newcommand*{\manualmark}{%
  \begingroup
    \def\@elt##1{%
      \aftergroup\let\expandafter\aftergroup\csname ##1mark\endcsname
      \aftergroup\@gobble
    }%
    \scrlayer@level@list
  \endgroup
  \let\@mkleft\@gobble
  \let\@mkright\@gobble
  \let\@mkdouble\@gobble
  \let\@mkboth\@gobbletwo
}
%</package&body>
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\automark}
% \begin{macro}{\@automark}
% This is the brain knot of the game! I'll try to explain, what I'm doing:
% First of all the new starred version of \Macro{automark} doesn't reset the
% mark commands. So it works cumulatively. This may be useful e.g. to have
% chapter marks as long as no section marks have been made etc.
%    \begin{macrocode}
%<*package&body>
\newcommand*{\automark}{%
  \@ifstar{\@automark}{\manualmark\@automark}%
}
\newcommand*{\@automark}[2][]{%
  \ifstr{#2}{}{%
    \ifstr{#1}{}{%
%    \end{macrocode}
% \Macro{automark[]{}} or \Macro{automark{}} has been used. This will activate
% the low level mark commands, but doesn't change the high level commands. It
% may be useful or may not, the user should know what he does:
%    \begin{macrocode}
      \automark@basics
    }{%
%    \end{macrocode}
% \Macro{automark[\dots]{}} has been used. This will activate the higher level
% mark commands and also set up the right mark
%    \begin{macrocode}
      \automark@basics
      \automark@righthigh{#1}%
    }%
  }{%
    \ifstr{#1}{}{%
%    \end{macrocode}
% \Macro{automark[]{\dots}} or \Macro{automark{\dots}} has been used. This
% will activate the low level mark commands and also set up either the left or
% both marks.
%    \begin{macrocode}
      \automark@basics
      \automark@leftlow{#2}%
    }{%
%    \end{macrocode}
% \Macro{automark[\dots]{\dots}} has been used. This will activate the low
% level mark commands and also both high level marks.
%    \begin{macrocode}
      \automark@basics
      \automark@both{#1}{#2}%
    }%
  }%
}
%    \end{macrocode}
% \begin{macro}{\automark@basics}
% Activate all low level \Macro{@mk\dots} commands:
%    \begin{macrocode}
\newcommand*{\automark@basics}{%
  \let\@mkleft\markleft
  \let\@mkright\markright
  \let\@mkboth\markboth
  \def\@mkdouble##1{\@mkboth{##1}{##1}}%
}
%    \end{macrocode}
% \end{macro}^^A \automark@basics
% \begin{macro}{\automark@righthigh}
% Set up the right mark of a higher level, but in single-side layout only if
% \Option{autooneside} hasn't been used. Note, that with this definition no
% special handling for \KOMAScript's \Macro{addchap} and \Macro{addsec} is
% needed.
%    \begin{macrocode}
\newcommand*{\automark@righthigh}[1]{%
  \ifscrlayer@level@prepared{#1}{%
    \expandafter\def\csname #1mark\endcsname##1{%
      \begingroup
        \@tempswafalse
        \if@twoside\@tempswatrue
        \else\ifscrlayer@autooneside\else\@tempswatrue\fi\fi
      \expandafter\endgroup
      \if@tempswa
        \@mkright{%
          \MakeMarkcase{%
            \ifnum \c@secnumdepth<\numexpr \csname #1level\endcsname +0\relax
            \else\if@mainmatter \csname #1markformat\endcsname\fi\fi
            ##1%
          }%
        }%
      \fi
    }%
  }{}%
}
%    \end{macrocode}
% \end{macro}^^A \automark@righthigh
% \begin{macro}{\automark@leftlow}
% Set up the left mark of a low level, but in single-side layout the right
% mark has to be used.
%    \begin{macrocode}
\newcommand*{\automark@leftlow}[1]{%
  \ifscrlayer@level@prepared{#1}{%
    \expandafter\def\csname #1mark\endcsname ##1{%
      \if@twoside
%    \end{macrocode}
% In two-side mode the left high mark has also to clear the right low
% mark. This would be unwanted, if the left mark is a low mark and the right
% mark is a high mark. But we cannot detect this if no right mark level has
% been given. So we simply use:
%    \begin{macrocode}
        \expandafter\@mkboth
      \else
%    \end{macrocode}
% In single-side mode there's no left high mark without a right low mark. So
% instead of only a left high mark, we set up both marks.
%    \begin{macrocode}
        \expandafter\@mkdouble
      \fi
      {%
        \MakeMarkcase{%
          \ifnum \c@secnumdepth<\numexpr \csname #1level\endcsname +0\relax
          \else\if@mainmatter \csname #1markformat\endcsname\fi\fi
          ##1%
        }%
      }\@empty
    }%
  }{}%
}
%    \end{macrocode}
% \end{macro}^^A \automark@leftlow
% \begin{macro}{\automark@both}
% Set up both marks, but in single-side layout depending on
% \Option{autooneside}.
%    \begin{macrocode}
\newcommand*{\automark@both}[2]{%
  \ifscrlayer@level@prepared{#1}{%
    \ifscrlayer@level@prepared{#2}{%
      \ifnum \numexpr \csname #1level\endcsname +0\relax
           > \numexpr \csname #2level\endcsname +0\relax
%    \end{macrocode}
% Level of left mark is greater than level of right mark. e.g., section >
% chapter. This is unusual. Nevertheless we'll handle it.
%    \begin{macrocode}
          \automark@leftlow{#2}%
          \automark@righthigh{#1}%
      \else \ifnum \numexpr \csname #1level\endcsname +0\relax
                 = \numexpr \csname #2level\endcsname +0\relax
%    \end{macrocode}
% Level of left mark is equal to level of right mark. This is
% nice and very easy to handle.
%    \begin{macrocode}
          \expandafter\def\csname #2mark\endcsname##1{%
            \@mkdouble{%
              \MakeMarkcase{%
                \ifnum \c@secnumdepth<\numexpr 
                  \csname #2level\endcsname +0\relax
                \else
                  \if@mainmatter \csname #2markformat\endcsname\fi
                \fi
                ##1%
              }%
            }%
          }%
        \else
%    \end{macrocode}
% Level of left mark is less than level of right mark. This is
% usual.
%    \begin{macrocode}
          \expandafter\def\csname #1mark\endcsname##1{%
            \begingroup
              \@tempswafalse
              \if@twoside\@tempswatrue
              \else\ifscrlayer@autooneside\else\@tempswatrue\fi\fi
            \expandafter\endgroup
            \if@tempswa
              \@mkleft{%
                \MakeMarkcase{%
                  \ifnum \c@secnumdepth
                       < \numexpr\csname #1level\endcsname +0\relax
                  \else
                    \if@mainmatter \csname #1markformat\endcsname\fi
                  \fi
                  ##1%
                }%
              }%
            \fi
          }%
          \expandafter\def\csname #2mark\endcsname##1{%
            \@mkboth{}{%
              \MakeMarkcase{%
                \ifnum \c@secnumdepth
                     < \numexpr \csname #2level\endcsname +0\relax
                \else\if@mainmatter \csname #2markformat\endcsname\fi\fi
                ##1%
              }%
            }%
          }%
        \fi
      \fi
    }{}%
  }{}%
}
%    \end{macrocode}
% \begin{macro}{\ifscrlayer@level@prepared}
% Test, whether or not this level has been prepared.
%    \begin{macrocode}
\newcommand*{\ifscrlayer@level@prepared}[1]{%
  \typeout{1: \detokenize{#1}}%
  \scr@ifundefinedorrelax{#1level}{%
    \PackageError{scrlayer}{numbering depth of `#1' unknown}{%
      Someone told me to use a section mark for level `#1',\MessageBreak
      but the numbering depth hasn't been declared before. You may solve this
      using\MessageBreak
      \string\DeclareSectionNumberDepth{#1}{NUMBER}.%
    }%
    \@secondoftwo
  }{%
    \@firstoftwo
  }%
}
%</package&body>
%    \end{macrocode}
% \end{macro}^^A \ifscrlayer@level@prepared
% \end{macro}^^A \automark@both
% \end{macro}^^A \@automark
% \end{macro}^^A \automark
%
% \begin{macro}{\DeclareSectionNumberDepth}
%   \begin{description}
%   \item[\Parameter{string}:] the name of the section level, e.g.,
%     part, chapter, section etc. (must be fully
%     expandable and expand to a string).
%   \item[\Parameter{numeric expression}:] the section number depth of the
%   level, e.g., -1 for part, 0 for chapter etc.
%   \end{description}
% Note that levels part, chapter, section, subsection, sub\dots subsection,
% paragraph, subparagraph, sub\dots subparagraph, minisec, subminisec,
% sub\dots subminisec will be recognised either at load time or at
% \Macro{begin}\PParameter{document} automatically if they have the usual
% levels.
%    \begin{macrocode}
%<*package&body>
\newcommand*{\DeclareSectionNumberDepth}[2]{%
  \expandafter\edef\csname #1level\endcsname{\the\numexpr #2\relax}%
  \@ifundefined{#1mark}{%
    \expandafter\let\csname #1mark\endcsname\@gobble
  }{}%
  \@ifundefined{#1markformat}{%
    \@namedef{#1markformat}{\GenericMarkFormat{#1}}%
  }{}%
  \begingroup
    \@tempswatrue
    \def\@elt##1{\ifstr{#1}{##1}{\@tempswafalse}{}}%
    \scrlayer@level@list
    \if@tempswa
      \aftergroup\@firstofone
    \else
      \aftergroup\@gobble
    \fi
  \endgroup
  {%
    \l@addto@macro\scrlayer@level@list{\@elt{#1}}%
  }%
}
%    \end{macrocode}
% \begin{macro}{\scrlayer@level@list}
% \begin{macro}{\scrlayer@level@init}
% Stores all the existing levels.
%    \begin{macrocode}
\newcommand*{\scrlayer@level@list}{}
%    \end{macrocode}
% Usually all levels are known on loading this package, but if a package
% defines additional levels later we'll do an additional test at
% \Macro{begin}\PParameter{document}. But we do not redo the part and the
% chapter test.
%    \begin{macrocode}
\scr@ifundefinedorrelax{part}{}{%
  \DeclareSectionNumberDepth{part}{-1}%
}
\if@chapter
  \DeclareSectionNumberDepth{chapter}{0}%
\fi
\newcommand*{\scrlayer@level@init}{%
  \@tempcnta=1
  \def\reserved@b##1{%
    \@tempswatrue
    \def\reserved@a{##1}%
    \@whilesw \if@tempswa \fi {%
      \scr@ifundefinedorrelax{\reserved@a}{%
        \@tempswafalse
      }{%
        \@ifundefined{\reserved@a level}{%
          \expandafter\DeclareSectionNumberDepth
          \expandafter{\reserved@a}{\@tempcnta}%
        }{}%
        \advance \@tempcnta by \@ne
        \edef\reserved@a{sub\reserved@a}%
      }%
    }%
  }%
  \reserved@b{section}%
  \reserved@b{paragraph}%
  \reserved@b{minisec}%
}
\scrlayer@level@init
\AtBeginDocument{%
  \scrlayer@level@init
}
%</package&body>
%    \end{macrocode}
% \end{macro}^^A \scrlayer@level@init
% \end{macro}^^A \scrlayer@level@list
% \end{macro}^^A DeclareSectionNumberDepth
%
%
% \subsection{Providing Layers}
%
% A layer is a virtual sheet of paper stacked behind or above the real sheet
% of paper. All the virtual and real sheets of one page may been seen
% simultanous, but material o one sheet may overlap material on sheets below.
% Layers provided by \Package{scrlayer} will not be stacked below or above
% real sheets unless they are used by a page style.
%
% While we use \meta{key}\texttt{=}\meta{value} arguments for several of the
% layer commands we define a new family with a new member:
%    \begin{macrocode}
%<*package&body>
\DefineFamily{KOMAarg}
\DefineFamilyMember[.definelayer]{KOMAarg}
%</package&body>
%    \end{macrocode}
%
% \begin{macro}{\DeclareLayer}
%   \begin{description}
%   \item[\OParameter{option list}:] a comma separated list of
%     \texttt{\meta{key}=\meta{value}} pairs.
%   \item[\Parameter{string}:] the name of the layer (must be fully expandable
%     and expand to a string only).
%   \end{description}
% Layers are the basic elements of page styles. A layer has a name and several
% attributes. The attributes may be set as comma separated list at the first,
% optional argument of \cs{DeclareLayer}. The name must be set by the second,
% mandatory argument.
% \begin{macro}{\def@scr@l@pos}
% And a second helper macro to easily define $x, y, w, h$ of a layer.
%    \begin{macrocode}
%<*package&body>
\newcommand*{\def@scr@l@pos}[4]{%
  \@namedef{scr@l@\scr@current@layer @x}{#1}%
  \@namedef{scr@l@\scr@current@layer @y}{#2}%
  \@namedef{scr@l@\scr@current@layer @w}{#3}%
  \@namedef{scr@l@\scr@current@layer @h}{#4}%
}
%    \end{macrocode}
% \end{macro}^^A \def@scr@l@pos
%
% There are basic attributes and compounding attributes. The basic attributes
% are:
% \begin{description}
% \item[\texttt{hoffset=\meta{dimension expression}}:] offset from the left
%   edge of the paper.
%    \begin{macrocode}
\DefineFamilyKey[.definelayer]{KOMAarg}{hoffset}{%
  \@namedef{scr@l@\scr@current@layer @x}{\dimexpr #1\relax}%
  \FamilyKeyStateProcessed
}
%    \end{macrocode}
% \item[\texttt{voffset=\meta{dimension expression}}:] offset from the top
%   edge of the paper.
%    \begin{macrocode}
\DefineFamilyKey[.definelayer]{KOMAarg}{voffset}{%
  \@namedef{scr@l@\scr@current@layer @y}{\dimexpr #1\relax}%
  \FamilyKeyStateProcessed
}
%    \end{macrocode}
% \item[\texttt{width=\meta{dimension expression}}:] width of the layer.
%    \begin{macrocode}
\DefineFamilyKey[.definelayer]{KOMAarg}{width}{%
  \@namedef{scr@l@\scr@current@layer @w}{\dimexpr #1\relax}%
  \FamilyKeyStateProcessed
}
%    \end{macrocode}
% \item[\texttt{height=\meta{dimension expression}}:] height of the layer.
%    \begin{macrocode}
\DefineFamilyKey[.definelayer]{KOMAarg}{height}{%
  \@namedef{scr@l@\scr@current@layer @h}{\dimexpr #1\relax}%
  \FamilyKeyStateProcessed
}
%    \end{macrocode}
% \item[\texttt{align=\meta{specification}}:] horizontal and vertical
%   alignment of the layer. The \meta{specification} will interpreted
%   character by character with the following valid characters:
%   \begin{itemize}
%   \item[l] -- align the layer with its left edge to the given horizontal
%     offset. This means, that the layer's width will span right from the
%     given horizontal offset.
%   \item[r] -- align the layer with its right edge to the given horizontal
%     offset. This means, that the layer's width will span left from the given
%     horizontal offset.
%   \item[c] -- align the layer centered to the given horizontal and vertical
%     offset. This means, that the given offsets are at the middle of the
%     layer width and total height.
%   \item[t] -- align the layer with its top edge to the given vertical
%     offset. This means that the layer's contents will span below the given
%     vertical offset.
%   \item[b] -- align the layer with its bottom edge to the given vertical
%     offset. This means, that the layer's contents will span above the given
%     vertical offset.
%   \end{itemize}
%    \begin{macrocode}
\DefineFamilyKey[.definelayer]{KOMAarg}{align}{%
  \@namedef{scr@l@\scr@current@layer @align}{#1}%
  \FamilyKeyStateProcessed
}
%    \end{macrocode}
% \item[\texttt{contents=\meta{output}}:] whatever should be printed by the
%   layer.
%    \begin{macrocode}
\DefineFamilyKey[.definelayer]{KOMAarg}{contents}{%
  \@namedef{scr@l@\scr@current@layer @contents}{#1}%
  \FamilyKeyStateProcessed
}
%    \end{macrocode}
% \item[\texttt{background}:] restrict the layer to the page
%   background. This means, that the main contents of the page may overprint
%   the contents of the layer. Note, that this attribute has no value!
%    \begin{macrocode}
\DefineFamilyKey[.definelayer]{KOMAarg}{background}[\relax]{%
  \FamilyKeyStateProcessed
  \scrlayer@testunexpectedarg{background}{#1}%
  \csname @scr@l@\scr@current@layer @backgroundtrue\endcsname
  \csname @scr@l@\scr@current@layer @foregroundfalse\endcsname
}
%    \end{macrocode}
% \item[\texttt{foreground}:] restrict the layer to the page
%   foreground. This means, that the layer's contents may overprint the main
%   contents of the page. Note, that this attribute has no value!
%    \begin{macrocode}
\DefineFamilyKey[.definelayer]{KOMAarg}{foreground}[\relax]{%
  \FamilyKeyStateProcessed
  \scrlayer@testunexpectedarg{foreground}{#1}%
  \csname @scr@l@\scr@current@layer @backgroundfalse\endcsname
  \csname @scr@l@\scr@current@layer @foregroundtrue\endcsname
}
%    \end{macrocode}
% \item[\texttt{oddpage}:] restrict the layer to odd pages only. At
%   two-sided layout only pages with odd page numbers are odd pages. At
%   single-sided layout all pages are odd pages. Note, that this attribute has
%   no value!
%    \begin{macrocode}
\DefineFamilyKey[.definelayer]{KOMAarg}{oddpage}[\relax]{%
  \FamilyKeyStateProcessed
  \scrlayer@testunexpectedarg{oddpage}{#1}%
  \csname @scr@l@\scr@current@layer @oddtrue\endcsname
  \csname @scr@l@\scr@current@layer @evenfalse\endcsname
}
%    \end{macrocode}
% \item[\texttt{evenpage}:] restrict the layer to even pages only. At
%   two-sided layout only pages with even page numbers are even pages. At
%   single-sided layout there aren't even pages. Note, that this attribute has
%   no value!
%    \begin{macrocode}
\DefineFamilyKey[.definelayer]{KOMAarg}{evenpage}[\relax]{%
  \FamilyKeyStateProcessed
  \scrlayer@testunexpectedarg{evenpage}{#1}%
  \csname @scr@l@\scr@current@layer @oddfalse\endcsname
  \csname @scr@l@\scr@current@layer @eventrue\endcsname
}
%    \end{macrocode}
% \item[\Option{floatpage}:] restrict the layer to float pages.
%    \begin{macrocode}
\DefineFamilyKey[.definelayer]{KOMAarg}{floatpage}[\relax]{%
  \FamilyKeyStateProcessed
  \scrlayer@testunexpectedarg{floatpage}{#1}%
  \csname @scr@l@\scr@current@layer @nonfloatpagefalse\endcsname
  \csname @scr@l@\scr@current@layer @floatpagetrue\endcsname
}
%    \end{macrocode}
% \item[\Option{nonfloatpage}:] restrict the layer to pages, which aren't
%   float pages.
%    \begin{macrocode}
\DefineFamilyKey[.definelayer]{KOMAarg}{nonfloatpage}[\relax]{%
  \FamilyKeyStateProcessed
  \scrlayer@testunexpectedarg{twoside}{#1}%
  \csname @scr@l@\scr@current@layer @nonfloatpagetrue\endcsname
  \csname @scr@l@\scr@current@layer @floatpagefalse\endcsname
}
%    \end{macrocode}
% \item[\Option{oneside}:] restrict the layer to pages on single-sided
%   layouts.
%    \begin{macrocode}
\DefineFamilyKey[.definelayer]{KOMAarg}{oneside}[\relax]{%
  \FamilyKeyStateProcessed
  \scrlayer@testunexpectedarg{oneside}{#1}%
  \csname @scr@l@\scr@current@layer @twosidefalse\endcsname
  \csname @scr@l@\scr@current@layer @onesidetrue\endcsname
}
%    \end{macrocode}
% \item[\Option{twoside}:] restrict the layer to pages on two-sided
%   layouts.
%    \begin{macrocode}
\DefineFamilyKey[.definelayer]{KOMAarg}{twoside}[\relax]{%
  \FamilyKeyStateProcessed
  \scrlayer@testunexpectedarg{twoside}{#1}%
  \csname @scr@l@\scr@current@layer @twosidetrue\endcsname
  \csname @scr@l@\scr@current@layer @onesidefalse\endcsname
}
%    \end{macrocode}
% \end{description}
%
% Compounding attributes are attributes, that set up several basic attributes
% with a single compounding attribute:
% \begin{description}
% \item[\texttt{page}:] set up \texttt{hoffset}, \texttt{voffset},
%   \texttt{width}, and \texttt{height} to values spanning the whole
%   page aligned by the default alignment \texttt{tl}. Note, that this
%   attribute has no value!
%    \begin{macrocode}
\DefineFamilyKey[.definelayer]{KOMAarg}{page}[\relax]{%
  \FamilyKeyStateProcessed
  \scrlayer@testunexpectedarg{page}{#1}%
  \def@scr@l@pos{\z@}{\z@}{\paperwidth}{\paperheight}%
  \@namedef{scr@l@\scr@current@layer @align}{tl}%
}
%    \end{macrocode}
% \item[\texttt{topmargin}:] set up \texttt{hoffset}, \texttt{voffset},
%   \texttt{width}, and \texttt{height} to values vertically spanning the top
%   margin of the page and horizontally spanning the whole page aligned by the
%   default alignment \texttt{tl}. Note, that this attribute has no value!
%    \begin{macrocode}
\DefineFamilyKey[.definelayer]{KOMAarg}{topmargin}[\relax]{%
  \FamilyKeyStateProcessed
  \scrlayer@testunexpectedarg{topmargin}{#1}%
  \def@scr@l@pos{\z@}{\z@}{\paperwidth}{\dimexpr \topmargin+1in\relax}%
  \@namedef{scr@l@\scr@current@layer @align}{tl}%
}
%    \end{macrocode}
% \item[\texttt{head}:] set up \texttt{hoffset}, \texttt{voffset},
%   \texttt{width}, and \texttt{height} to values vertically spanning the page
%   head and horizontally spanning the text area aligned by usual head
%   alignment \texttt{bl}. Note, that this attribute has no value!
%    \begin{macrocode}
\DefineFamilyKey[.definelayer]{KOMAarg}{head}[\relax]{%
  \FamilyKeyStateProcessed
  \scrlayer@testunexpectedarg{head}{#1}%
  \def@scr@l@pos{%
    \dimexpr
      \if@twoside\ifodd\value{page}\oddsidemargin\else\evensidemargin\fi
      \else\oddsidemargin\fi
      +1in
    \relax
  }{%
    \dimexpr \topmargin+1in+\headheight\relax
  }{\textwidth}{\headheight}%
  \@namedef{scr@l@\scr@current@layer @align}{bl}%
}
%    \end{macrocode}
% \item[\texttt{headsep}:] set up \texttt{hoffset}, \texttt{voffset},
%   \texttt{width}, and \texttt{height} to values vertically spanning the area
%     between page head and text area and horizontally spanning the text area
%     aligned by the default alignment \texttt{t}. Note, that this attribute
%     has no value!
%    \begin{macrocode}
\DefineFamilyKey[.definelayer]{KOMAarg}{headsep}[\relax]{%
  \FamilyKeyStateProcessed
  \scrlayer@testunexpectedarg{head}{#1}%
  \def@scr@l@pos{%
    \dimexpr
      \if@twoside\ifodd\value{page}\oddsidemargin\else\evensidemargin\fi
      \else\oddsidemargin\fi
      +1in
    \relax
  }{%
    \dimexpr \topmargin+1in+\headheight\relax
  }{\textwidth}{\headsep}%
  \@namedef{scr@l@\scr@current@layer @align}{tl}%
}
%    \end{macrocode}
% \item[\texttt{textarea}:] set up \texttt{hoffset}, \texttt{voffset},
%   \texttt{width}, and \texttt{height} to values spanning the text area of
%   the page aligned by the default alignment \texttt{t}. Note, that this
%   attribute has no value!
%    \begin{macrocode}
\DefineFamilyKey[.definelayer]{KOMAarg}{textarea}[\relax]{%
  \FamilyKeyStateProcessed
  \scrlayer@testunexpectedarg{textarea}{#1}%
  \def@scr@l@pos{%
    \dimexpr
      \if@twoside\ifodd\value{page}\oddsidemargin\else\evensidemargin\fi
      \else\oddsidemargin\fi
      +1in
    \relax
  }{%
    \dimexpr \topmargin+1in+\headheight+\headsep\relax
  }{\textwidth}{\textheight}%
  \@namedef{scr@l@\scr@current@layer @align}{tl}%
}
%    \end{macrocode}
% \item[\texttt{foot}:] set up \texttt{hoffset}, \texttt{voffset},
%   \texttt{width}, and \texttt{height} to values vertically spanning the page
%   footer and horizontally spanning the text area aligned by the usual footer
%   alignment \texttt{t}. Note, that this attribute has no value!
%    \begin{macrocode}
\DefineFamilyKey[.definelayer]{KOMAarg}{foot}[\relax]{%
  \FamilyKeyStateProcessed
  \scrlayer@testunexpectedarg{foot}{#1}%
  \def@scr@l@pos{%
    \dimexpr
      \if@twoside\ifodd\value{page}\oddsidemargin\else\evensidemargin\fi
      \else\oddsidemargin\fi
      +1in
    \relax
  }{%
    \dimexpr \topmargin+1in+\headheight+\headsep+\textheight
    +\footskip+\dp\strutbox-\footheight\relax
  }{\textwidth}{\footheight}%
  \@namedef{scr@l@\scr@current@layer @align}{tl}%
}
%    \end{macrocode}
% \item[\texttt{footskip}:] set up \texttt{hoffset}, \texttt{voffset},
%   \texttt{width}, and \texttt{height} to values vertically spanning the
%   distance from the text area to the page
%   footer and horizontally spanning the text area aligned by the usual footer
%   alignment \texttt{t}. Note, that this attribute has no value!
%    \begin{macrocode}
\DefineFamilyKey[.definelayer]{KOMAarg}{footskip}[\relax]{%
  \FamilyKeyStateProcessed
  \scrlayer@testunexpectedarg{foot}{#1}%
  \def@scr@l@pos{%
    \dimexpr
      \if@twoside\ifodd\value{page}\oddsidemargin\else\evensidemargin\fi
      \else\oddsidemargin\fi
      +1in
    \relax
  }{%
    \dimexpr \topmargin+1in+\headheight+\headsep+\textheight\relax
  }{\textwidth}{\dimexpr\footskip+\dp\strutbox-\footheight\relax}%
  \@namedef{scr@l@\scr@current@layer @align}{tl}%
}
%    \end{macrocode}
% \item[\texttt{bottommargin}:] set up \texttt{hoffset}, \texttt{voffset},
%   \texttt{width}, and \texttt{height} to values vertically spanning the
%   page's bottom margin below the footer and horizontally spanning the page
%   by the default alignment \texttt{t}. Note, that this attribute has no
%   value!
%    \begin{macrocode}
\DefineFamilyKey[.definelayer]{KOMAarg}{bottommargin}[\relax]{%
  \FamilyKeyStateProcessed
  \scrlayer@testunexpectedarg{bottommargin}{#1}%
  \def@scr@l@pos{\z@}{%
    \dimexpr \topmargin+1in+\headheight+\headsep
            +\textheight
            +\footskip+\dp\strutbox\relax
  }{\paperwidth}{\dimexpr\paperheight-\layeryoffset\relax}%
  \@namedef{scr@l@\scr@current@layer @align}{tl}%
}
%    \end{macrocode}
% \item[\texttt{leftmargin}:] set up \texttt{hoffset}, \texttt{voffset},
%   \texttt{width}, and \texttt{height} to values vertically spanning the page
%   and horizontally spanning the left margin of the page by the default
%   alignment \texttt{t}. Note, that this attribute has no value!
%    \begin{macrocode}
\DefineFamilyKey[.definelayer]{KOMAarg}{leftmargin}[\relax]{%
  \FamilyKeyStateProcessed
  \scrlayer@testunexpectedarg{leftmargin}{#1}%
  \def@scr@l@pos{\z@}{\z@}{%
    \dimexpr
      \if@twoside\ifodd\value{page}\oddsidemargin\else\evensidemargin\fi
      \else\oddsidemargin\fi
      +1in
    \relax
  }{\paperheight}%
  \@namedef{scr@l@\scr@current@layer @align}{tl}%
}
%    \end{macrocode}
% \item[\texttt{rightmargin}:] set up \texttt{hoffset}, \texttt{voffset},
%   \texttt{width}, and \texttt{height} to values vertically spanning the page
%   and horizontally spanning the right margin of the page by the default
%   alignment \texttt{t}. Note, that this attribute has no value!
%    \begin{macrocode}
\DefineFamilyKey[.definelayer]{KOMAarg}{rightmargin}[\relax]{%
  \FamilyKeyStateProcessed
  \scrlayer@testunexpectedarg{rightmargin}{#1}%
  \def@scr@l@pos{\paperwidth}{\z@}{%
    \dimexpr \paperwidth-1in-\textwidth
      -\if@twoside\ifodd\value{page}\oddsidemargin\else\evensidemargin\fi
       \else\oddsidemargin\fi\relax
  }{\paperheight}%
  \@namedef{scr@l@\scr@current@layer @align}{tr}%
}
%    \end{macrocode}
% \item[\texttt{innermargin}:] set up \texttt{hoffset}, \texttt{voffset},
%   \texttt{width}, and \texttt{height} to values vertically spanning the page
%   and horizontally spanning the right margin of even pages and the left
%   margin of odd pages by the default alignment \texttt{t}. See attributes
%   \texttt{oddpage} and \texttt{evenpage} for more information about odd and
%   even pages. Note, that this attribute has no value!
%    \begin{macrocode}
\DefineFamilyKey[.definelayer]{KOMAarg}{innermargin}[\relax]{%
  \FamilyKeyStateProcessed
  \scrlayer@testunexpectedarg{innermargin}{#1}%
  \def@scr@l@pos{%
    \if@twoside
      \ifodd\value{page} \z@
      \else \dimexpr \evensidemargin+1in+\textwidth\relax
      \fi
    \else \z@\fi
  }{\z@}{%
    \dimexpr
      \if@twoside\ifodd\value{page} \oddsidemargin+1in
        \else \paperwidth-\layerxoffset\fi
      \else \oddsidemargin+1in\fi
    \relax
  }{\paperheight}%
  \@namedef{scr@l@\scr@current@layer @align}{tl}%
}
%    \end{macrocode}
% \item[\texttt{outermargin}:] set up \texttt{hoffset}, \texttt{voffset},
%   \texttt{width}, and \texttt{height} to values vertically spanning the page
%   and horizontally spanning the left margin of even pages and the right
%   margin of odd pages by the default alignment \texttt{t}. See attributes
%   \texttt{oddpage} and \texttt{evenpage} for more information about odd and
%   even pages. Note, that this attribute has no value!
%    \begin{macrocode}
\DefineFamilyKey[.definelayer]{KOMAarg}{outermargin}[\relax]{%
  \FamilyKeyStateProcessed
  \scrlayer@testunexpectedarg{outermargin}{#1}%
  \def@scr@l@pos{%
    \dimexpr
      \if@twoside\ifodd\value{page} \oddsidemargin+1in+\textwidth
        \else \z@\fi
      \else \oddsidemargin+1in+\textwidth\fi
    \relax
  }{\z@}{%
    \dimexpr
      \if@twoside\ifodd\value{page}\paperwidth-\layerxoffset
        \else \evensidemargin+1in\fi
      \else \paperwidth-\layerxoffset\fi
    \relax
  }{\paperheight}%
  \@namedef{scr@l@\scr@current@layer @align}{tl}%
}
%    \end{macrocode}
% \item[\texttt{area=\{\meta{hoffset}\}\{\meta{voffset}\}^^A
%                    \{\meta{width}\}\{\meta{height}\}}:] set up
%   \texttt{hoffset}, \texttt{voffset}, \texttt{width}, and \texttt{height} to
%   the given values.
%    \begin{macrocode}
\DefineFamilyKey[.definelayer]{KOMAarg}{area}{%
  \def@scr@l@pos#1
  \FamilyKeyStateProcessed
}
%    \end{macrocode}
% \item[\texttt{clone=\meta{layer}}:] set up the new layer by the settings
%   of the given \meta{layer}.
%   \begin{macrocode}
\DefineFamilyKey[.definelayer]{KOMAarg}{clone}{%
  \scr@ifundefinedorrelax{scr@l@#1@x}{%
    \FamilyKeyStateUnknownValue
    \PackageError{scrlayer}{layer `#1' undefined}{%
      You can clone only already defined layers.\MessageBreak
      If you'll continue, `clone=#1' will be ignored.%
    }%
  }{%
    \FamilyKeyStateProcessed
    \scrlayer@clone@attribute{\scr@current@layer}{#1}{x}%
    \scrlayer@clone@attribute{\scr@current@layer}{#1}{y}%
    \scrlayer@clone@attribute{\scr@current@layer}{#1}{w}%
    \scrlayer@clone@attribute{\scr@current@layer}{#1}{h}%
    \scrlayer@clone@attribute{\scr@current@layer}{#1}{align}%
    \scrlayer@clone@attribute{\scr@current@layer}{#1}{contents}%
    \scrlayer@clone@switch{\scr@current@layer}{#1}{background}%
    \scrlayer@clone@switch{\scr@current@layer}{#1}{foreground}%
    \scrlayer@clone@switch{\scr@current@layer}{#1}{odd}%
    \scrlayer@clone@switch{\scr@current@layer}{#1}{even}%
    \scrlayer@clone@switch{\scr@current@layer}{#1}{oneside}%
    \scrlayer@clone@switch{\scr@current@layer}{#1}{twoside}%
    \scrlayer@clone@switch{\scr@current@layer}{#1}{floatpage}%
    \scrlayer@clone@switch{\scr@current@layer}{#1}{nonfloatpage}%
  }%
}
%    \end{macrocode}
% \begin{macro}{\scrlayer@clone@attribute}
% \begin{macro}{\scrlayer@clone@switch}
% Two helpers used to at option \texttt{clone} to clone either a macro-based
% attribute or a if-based attribute.
%    \begin{macrocode}
\newcommand*{\scrlayer@clone@attribute}[3]{%
  \expandafter\let\csname scr@l@#1@#3\expandafter\endcsname
                  \csname scr@l@#2@#3\expandafter\endcsname
}
\newcommand*{\scrlayer@clone@switch}[3]{%
  \expandafter\let\csname if@scr@l@#1@#3\expandafter\endcsname
                  \csname if@scr@l@#2@#3\expandafter\endcsname
}
%    \end{macrocode}
% \end{macro}^^A \scrlayer@clone@switch
% \end{macro}^^A \scrlayer@clone@attribute
% \end{description}
%
%    \begin{macrocode}
\newcommand*{\DeclareLayer}[2][]{%
  \def\scr@current@layer{#2}%
  \@namedef{scr@l@#2@x}{\z@}%
  \@namedef{scr@l@#2@y}{\z@}%
  \@namedef{scr@l@#2@w}{\paperwidth}%
  \@namedef{scr@l@#2@h}{\paperheight}%
  \@namedef{scr@l@#2@align}{tl}%
  \@namedef{scr@l@#2@contents}{}%
  \expandafter\newif\csname if@scr@l@#2@background\endcsname
  \csname @scr@l@#2@backgroundtrue\endcsname
  \expandafter\newif\csname if@scr@l@#2@foreground\endcsname
  \csname @scr@l@#2@foregroundtrue\endcsname
  \expandafter\newif\csname if@scr@l@#2@odd\endcsname
  \csname @scr@l@#2@oddtrue\endcsname
  \expandafter\newif\csname if@scr@l@#2@even\endcsname
  \csname @scr@l@#2@eventrue\endcsname
  \expandafter\newif\csname if@scr@l@#2@oneside\endcsname
  \csname @scr@l@#2@onesidetrue\endcsname
  \expandafter\newif\csname if@scr@l@#2@twoside\endcsname
  \csname @scr@l@#2@twosidetrue\endcsname
  \expandafter\newif\csname if@scr@l@#2@floatpage\endcsname
  \csname @scr@l@#2@floatpagetrue\endcsname
  \expandafter\newif\csname if@scr@l@#2@nonfloatpage\endcsname
  \csname @scr@l@#2@nonfloatpagetrue\endcsname
  \FamilyExecuteOptions[.definelayer]{KOMAarg}{#1}%
}
%    \end{macrocode}
% \begin{macro}{\scr@current@layer}
% Helper to hold the current layer and only valid in non recursive calls of
% \Macro{DeclareLayer}.
%    \begin{macrocode}
\newcommand*{\scr@current@layer}{}
%</package&body>
%    \end{macrocode}
% \end{macro}^^A \scr@current@layer
% \end{macro}^^A \DeclareLayer
%
% \begin{macro}{\IfLayerExists}
% \begin{description}
% \item[\Parameter{string}:] the name of the layer (must be fully expandable
%   and expand to a string only).
% \item[\Parameter{then code}:] will be executed, if the layer exists.
% \item[\Parameter{else code}:] will be executed, if the layer doesn't exist.
% \end{description}
% Note, that we don't known really whether or not a layer exists, but have a
% heuristic.
%    \begin{macrocode}
%<*package&body>
\newcommand*{\IfLayerExists}[1]{%
  \scr@ifundefinedorrelax{scr@l@#1@x}{%
    \expandafter\@secondoftwo
  }{%
    \expandafter\@firstoftwo
  }%
}
%</package&body>
%    \end{macrocode}
% \end{macro}%^^A \IfLayerExists
%
% \begin{macro}{\DeclareNewLayer}
% \begin{macro}{\ProvideLayer}
% \begin{macro}{\RedeclareLayer}
% \begin{macro}{\ModifyLayer}
% There are also two commands for declaration of layers, that haven't been
% declared before, with or without error message for already declared layers,
% and two commands for changing already declared layers, first one beginning
% again from scratch, second one for only setting up attributes, that should
% be changed.
%    \begin{macrocode}
%<*package&body>
\newcommand*{\DeclareNewLayer}[2][]{%
  \IfLayerExists{#2}{%
    \PackageError{scrlayer}{layer `#2' already defined}{%
      You may declare only layer, that haven't been declared previously
      using\MessageBreak
      \string\DeclareNewLayer. See also the alternatives
      \string\RedeclareLayer,\MessageBreak
      \string\ModifyLayer\space and \string\ProvideLayer.\MessageBreak
      If you'll continue, declaration will be ignored.}%
  }{\DeclareLayer[{#1}]{#2}}%
}
\newcommand*{\ProvideLayer}[2][]{%
  \IfLayerExists{#2}{%
%<*trace>
    \PackageInfo{scrlayer}{\string\ProvideLayer{#2} ignored,\MessageBreak
      because of already defined layer}%
%</trace>
  }{\DeclareNewLayer[{#1}]{#2}}%
}
\newcommand*{\RedeclareLayer}[2][]{%
  \IfLayerExists{#2}{}{%
    \PackageError{scrlayer}{layer `#2' not yet defined}{%
      You may declare only already declared layers using
      \string\RedeclareLayer.\MessageBreak
      See also the alternatives
      \string\DeclareLayer and \string\ProvideLayer.\MessageBreak
      Nevertheless, if you'll continue, declaration will be done.}%
  }%
  \DeclareLayer[{#1}]{#2}%
}
\newcommand*{\ModifyLayer}[2][]{%
  \IfLayerExists{#2}{%
    \FamilyExecuteOptions[.definelayer]{KOMAarg}{#1}%
  }{%
    \PackageError{scrlayer}{layer `#2' not yet defined}{%
      You may modify only already declared layers using
      \string\ModifyLayer.\MessageBreak
      See also the alternatives
      \string\DeclareLayer and \string\ProvideLayer.\MessageBreak
      Nevertheless, if you'll continue, declaration will be done.}%
    \DeclareLayer[{#1}]{#2}%
  }%
}
%</package&body>
%    \end{macrocode}
% \end{macro}^^A \ModifyLayer
% \end{macro}^^A \RedeclareLayer
% \end{macro}^^A \ProvideLayer
% \end{macro}^^A \DeclareNewLayer
%
%
% \begin{macro}{\DestroyLayer}
%   \begin{description}
%   \item[\Parameter{string}:] the name of the layer, that should be
%     destroyed
%   \end{description}
% Note: Nothing will be done to remove the layer from a page style, but this
% shouldn't matter, because layers with, e.g.,
% \Macro{if@scr@l@\dots@nonfloatpage}=\Macro{relax} and
% \Macro{if@scr@l@\dots@floatpage}=\Macro{relax} won't be output ever. This
% command may and should be used by interfaces via
% \Macro{scrlayerOnAutoRemoveInterface} to remove the generated
% layers. Therefore it only destroys existing layers and doesn't care for not
% existing.
%    \begin{macrocode}
%<*package&body>
\newcommand*{\DestroyLayer}[1]{%
  \IfLayerExists{#1}{%
    \expandafter\let\csname scr@l@#1@x\endcsname\relax
    \expandafter\let\csname scr@l@#1@y\endcsname\relax
    \expandafter\let\csname scr@l@#1@w\endcsname\relax
    \expandafter\let\csname scr@l@#1@h\endcsname\relax
    \expandafter\let\csname scr@l@#1@align\endcsname\relax
    \expandafter\let\csname scr@l@#1@contents\endcsname\relax
    \expandafter\let\csname if@scr@l@#1@background\endcsname\relax
    \expandafter\let\csname @scr@l@#1@backgroundfalse\endcsname\relax
    \expandafter\let\csname @scr@l@#1@backgroundtrue\endcsname\relax
    \expandafter\let\csname if@scr@l@#1@foreground\endcsname\relax
    \expandafter\let\csname @scr@l@#1@foregroundfalse\endcsname\relax
    \expandafter\let\csname @scr@l@#1@foregroundtrue\endcsname\relax
    \expandafter\let\csname if@scr@l@#1@odd\endcsname\relax
    \expandafter\let\csname @scr@l@#1@oddfalse\endcsname\relax
    \expandafter\let\csname @scr@l@#1@oddtrue\endcsname\relax
    \expandafter\let\csname if@scr@l@#1@even\endcsname\relax
    \expandafter\let\csname @scr@l@#1@evenfalse\endcsname\relax
    \expandafter\let\csname @scr@l@#1@eventrue\endcsname\relax
    \expandafter\let\csname if@scr@l@#1@oneside\endcsname\relax
    \expandafter\let\csname @scr@l@#1@onesidefalse\endcsname\relax
    \expandafter\let\csname @scr@l@#1@onesidetrue\endcsname\relax
    \expandafter\let\csname if@scr@l@#1@twoside\endcsname\relax
    \expandafter\let\csname @scr@l@#1@twosidefalse\endcsname\relax
    \expandafter\let\csname @scr@l@#1@twosidetrue\endcsname\relax
    \expandafter\let\csname if@scr@l@#1@floatpage\endcsname\relax
    \expandafter\let\csname @scr@l@#1@floatpagefalse\endcsname\relax
    \expandafter\let\csname @scr@l@#1@floatpagetrue\endcsname\relax
    \expandafter\let\csname if@scr@l@#1@nonfloatpage\endcsname\relax
    \expandafter\let\csname @scr@l@#1@nonfloatpagefalse\endcsname\relax
    \expandafter\let\csname @scr@l@#1@nonfloatpagetrue\endcsname\relax
  }{%
%<*trace>    
    \PackageInfo{scrlayer}{\string\DestroyLayer{#1} ignored,\MessageBreak
      because that layer doesn't exist\MessageBreak
      (any longer)%
    }%
%</trace>
  }%
}
%</package&body>
%    \end{macrocode}
% \end{macro}^^A \DestroyLayer
%
%
% \begin{macro}{\layercontentsmeasure}
% This may used by used as the only value of the layer option
% \texttt{contents} to show measure lines around the layer. The left and the
% top measure line will be in centimeter, the right and the bottom measure
% line in inch. With option \texttt{draft=true} this also be used
% automatically and additionally for every layer of a page style.
%    \begin{macrocode}
%<*package&body>
\newcommand*{\layercontentsmeasure}{%
  \smash{\begin{picture}(0,0)
               (0,\if t\scr@l@valign -\ht\strutbox
                  \else
                    \if b\scr@l@valign -\dimexpr\layerheight-\dp\strutbox\relax
                    \else -.5\dimexpr \layerheight+\ht\strutbox-\dp\strutbox\relax
                    \fi
                  \fi\@gobble)
%    \end{macrocode}
% 1st horizontal cm
%    \begin{macrocode}
    \put(0,0){\line(1,0){\layerwidth\@gobble}}%
    \@tempcnta=\numexpr \dimexpr\layerwidth + .5mm\relax/\dimexpr 1mm\relax\relax
    \multiput(0,0)(1mm\@gobble,0){\@tempcnta}{%
      \line(0,-1){1mm\@gobble}%
    }%
    \@tempcnta=\numexpr \dimexpr\layerwidth + 2.5mm\relax/\dimexpr 5mm\relax\relax
    \multiput(0,0)(5mm\@gobble,0){\@tempcnta}{%
      \line(0,-1){2mm\@gobble}%
    }%
    \@tempcnta=\numexpr \dimexpr\layerwidth + .5cm\relax/\dimexpr 1cm\relax\relax
    \multiput(0,0)(10mm\@gobble,0){\@tempcnta}{%
      \put(0,0){\line(0,-1){3mm\@gobble}}%
      \put(0,-3.5mm\@gobble){%
        \makebox(0,0)[ct]{\the\numexpr\@tempcnta-\@multicnt\relax}}%
    }%
%    \end{macrocode}
% 2nd horizontal in:
%    \begin{macrocode}
    \put(0,-\layerheight\@gobble){\line(1,0){\layerwidth\@gobble}}%
    \@tempcnta=\numexpr \dimexpr\layerwidth + .05in\relax/\dimexpr .1in\relax\relax
    \multiput(0,-\layerheight\@gobble)(.1in\@gobble,0){\@tempcnta}{%
      \line(0,1){1mm\@gobble}%
    }%
    \@tempcnta=\numexpr \dimexpr\layerwidth + .25in\relax/\dimexpr .5in\relax\relax
    \multiput(0,-\layerheight\@gobble)(.5in\@gobble,0){\@tempcnta}{%
      \line(0,1){2mm\@gobble}%
    }%
    \@tempcnta=\numexpr \dimexpr\layerwidth + .5in\relax/\dimexpr 1in\relax\relax
    \multiput(0,-\layerheight\@gobble)(1in\@gobble,0){\@tempcnta}{%
      \put(0,0){\line(0,1){3mm\@gobble}}%
      \put(0,3.5mm\@gobble){%
        \makebox(0,0)[cb]{\the\numexpr\@tempcnta-\@multicnt\relax}}%
    }%
%    \end{macrocode}
% 3rd vertical cm:
%    \begin{macrocode}
    \put(0,0){\line(0,-1){\layerheight\@gobble}}%
    \@tempcnta\numexpr \dimexpr\layerheight + .5mm\relax/\dimexpr 1mm\relax\relax
    \multiput(0,0)(0,-1mm\@gobble){\@tempcnta}{%
      \line(1,0){1mm\@gobble}%
    }%
    \@tempcnta\numexpr \dimexpr\layerheight + 2.5mm\relax/\dimexpr 5mm\relax\relax
    \multiput(0,0)(0,-5mm\@gobble){\@tempcnta}{%
      \line(1,0){2mm\@gobble}%
    }%
    \@tempcnta\numexpr \dimexpr\layerheight + .5cm\relax/\dimexpr 1cm\relax\relax
    \multiput(0,0)(0,-1cm\@gobble){\@tempcnta}{%
      \put(0,0){\line(1,0){3mm\@gobble}}%
      \put(3.5mm\@gobble,0){%
        \makebox(0,0)[cl]{\the\numexpr\@tempcnta-\@multicnt\relax}}%
    }%
%    \end{macrocode}
% 4th vertical in:
%    \begin{macrocode}
    \put(\layerwidth\@gobble,0){\line(0,-1){\layerheight\@gobble}}%
    \@tempcnta\numexpr \dimexpr\layerheight + .05in\relax/\dimexpr .1in\relax\relax
    \multiput(\layerwidth\@gobble,0)(0,-.1in\@gobble){\@tempcnta}{%
      \line(-1,0){1mm\@gobble}%
    }%
    \@tempcnta\numexpr \dimexpr\layerheight + .25in\relax/\dimexpr .5in\relax\relax
    \multiput(\layerwidth\@gobble,0)(0,-.5in\@gobble){\@tempcnta}{%
      \line(-1,0){2mm\@gobble}%
    }%
    \@tempcnta\numexpr \dimexpr\layerheight + .5in\relax/\dimexpr 1in\relax\relax
    \multiput(\layerwidth\@gobble,0)(0,-1in\@gobble){\@tempcnta}{%
      \put(0,0){\line(-1,0){3mm\@gobble}}%
      \put(-3.5mm\@gobble,0){%
        \makebox(0,0)[cr]{\the\numexpr\@tempcnta-\@multicnt\relax}}%
    }%
  \end{picture}}%
}
%</package&body>
%    \end{macrocode}
% \end{macro}^^A \layercontentsmeasure
%
%
% \subsection{Providing Page Styles}
%
% Page styles in \LaTeX{} consist of the elements:
% \begin{itemize}
% \item a header for odd pages,
% \item a header for even pages,
% \item a footer for odd pages,
% \item a footer for even pages,
% \end{itemize}
% and some optional additional commands, that will be expanded, whenever the
% page style will be activated. Note, that header and footer for even pages
% will be used only at two-sided mode. At one-sided mode the header and footer
% for odd pages will be used for all pages.
%
% With package \Package{scrlayer} layers will be linked to package styles and
% expanded at the four elements above. Background layers will expand only
% at the headers. Foreground layers will expand only at the
% footers. Layers, that haven't been restricted to background or foreground,
% will expand at both, page headers and page footers.
%
% Similar to the expansion of background and foreground layers, odd page
% layers will only expand in the headers or footers of odd pages and even page
% layers will only expand in the headers or footers of even pages. Layers,
% that haven't been restricted to odd or even pages, will expand in the
% headers or footers of odd pages and also in the headers or footers of even
% pages.
%
% One step more: Single-side layers will only expand in the headers or footers
% of pages in single-side layouts and two-side layers only in the headers or
% footers of pages in two-side layout.
%
% One more step: float page layers will only expand in the headers or footers
% of pages, that consists of page floats only, while non-float page layers
% will only expand in the headers of footers of pages, that doesn't have page
% floats.
%
% \begin{length}{\footheight}
% For the header \LaTeX{} already defines a length \Length{headheight} to be
% the maximum height of the header. But for footer it only defines the
% distance of the baseline of the footer from the last baseline of the text
% area. \Package{scrlayer} changes this and also defines a new length
% \Length{footheight}. This length will be initialised with magic value
% -12345\,sp. But if it is still that magic value at
% \Macro{begin}\PParameter{document} it will be reset to the value of
% \Length{baselineskip}.
%    \begin{macrocode}
%<*package&init>
\@ifundefined{footheight}{%
  \newlength{\footheight}%
  \setlength{\footheight}{-12345sp}%
}{%
%<*trace>
  \PackageInfo{scrlayer}{Using already defined \string\footheight\MessageBreak
    hoping, that this is a length and\MessageBreak
    not only a macro}%
%</trace>
}
\AtBeginDocument{%
  \ifdim\footheight=-12345sp
%<*trace>    
    \PackageInfo{scrlayer}{Setting magic \string\footheight\space to
      \string\baselineskip\space while\MessageBreak
      \string\begin{document}}%
%</trace>
    \setlength{\footheight}{\baselineskip}
  \fi
}
%</package&init>
%    \end{macrocode}
% \end{length}^^A \footheight
%
%
% Several of the following commands use \meta{key}=\meta{value} arguments. So
% we define a family with a new member:
%    \begin{macrocode}
%<*package&body>
\DefineFamily{KOMAarg}
\DefineFamilyMember[.definelayerpagestyle]{KOMAarg}
%</package&body>
%    \end{macrocode}
%
% \begin{macro}{\DeclarePageStyleByLayers}
%   \begin{description}
%   \item[\OParameter{option list}:] comma separated list of named page
%     style options (see below).
%   \item[\Parameter{string}:] the name of the page style to be declared (must
%     be expandable and result in a string).
%   \item[\Parameter{string list}:] comma separated list of layer names (must
%     be expandable and result in strings); first in the list will be added
%     first.
%   \end{description}
% Page styles may be declared using this command. It has one optional and
% two mandatory arguments. The first mandatory one is the name of the page
% style and the second one is a list of layers to be used for this page
% style. The page style itself will expand all background layers for odd
% pages in \cs{@oddhead}, all background layers for even pages on
% \cs{@evenhead}, all foreground layers for odd pages in \cs{@oddfoot}, and
% all foreground layers for even pages in \cs{@evenfoot}. This may be
% restricted by additional attributes, e.g., \Option{oneside} and
% \Option{twoside}.
%
% The optional argument may be used to define hooks. There are six named
% optional arguments to set up six hooks. And there are also \KOMAScript{}
% options for these, to define global pre-definitions. Note, that you may
% remove the global pre-definitions by emptying the local hooks. The local
% argument are named similar, but without ``\texttt{ps}'' after
% ``\texttt{on}''.
% \begin{option}{onpsselect}
% \begin{macro}{\@ps@initialhook}
% \begin{description}
% \item[\texttt{=\meta{code}}:] executes \meta{code} whenever the
%   page style will be selected, e.g. using \Macro{pagestyle} or
%   \Macro{thispagestyle} or the low level command defining the page
%   style itself.
% \end{description}
%    \begin{macrocode}
%<*options>
\KOMA@key{onpsselect}{%
  \l@addto@macro{\@ps@initialhook}{#1}%
  \FamilyKeyStateProcessed
}
%<*interface>
\scrlayer@AddCsToInterface{KV@KOMA.\@currname.\@currext @onpsselect}
\scrlayer@AddCsToInterface{KV@KOMA.\@currname.\@currext @onpsselect@default}
%</interface>
%<package>\newcommand*{\@ps@initialhook}{}
%</options>
%<*package&body>
\DefineFamilyKey[.definelayerpagestyle]{KOMAarg}{onselect}{%
  \expandafter\l@addto@macro
  \csname @ps@\scrlayer@current@pagestyle @initialhook\endcsname
  {#1}%
  \FamilyKeyStateProcessed
}
%</package&body>
%    \end{macrocode}
% \end{macro}^^A \@ps@initialhook
% \end{option}^^A onpsselect
% \begin{option}{onpsinit}
% \begin{macro}{\@ps@hook}
% \begin{description}
% \item[\texttt{=\meta{code}}:] executes \meta{code} whenever the
%   output of a layer stack is initialised. Note, that \meta{code} must not
%   result in any page output. Otherwise the output of the layer stack will be
%   broken!
% \end{description}
%    \begin{macrocode}
%<*options>
\KOMA@key{onpsinit}{%
  \l@addto@macro{\@ps@hook}{#1}%
  \FamilyKeyStateProcessed
}
%<*interface>
\scrlayer@AddCsToInterface{KV@KOMA.\@currname.\@currext @onpsinit}
\scrlayer@AddCsToInterface{KV@KOMA.\@currname.\@currext @onpsinit@default}
%</interface>
%<package>\newcommand*{\@ps@hook}{}
%</options>
%<*package&body>
\DefineFamilyKey[.definelayerpagestyle]{KOMAarg}{oninit}{%
  \expandafter\l@addto@macro
  \csname @ps@\scrlayer@current@pagestyle @hook\endcsname
  {#1}%
  \FamilyKeyStateProcessed
}
%</package&body>
%    \end{macrocode}
% \end{macro}^^A \@ps@hook
% \end{option}^^A onpsinit
% \begin{option}{onpsoneside}
% \begin{macro}{\@ps@onesidehook}
% \begin{description}
% \item[\Option{=\meta{code}}:] executes \meta{code} after
%   \Option{oninit}'s \meta{code} whenever the output of a layer stack of a
%   page in single-side layout is initialised. Note, that \meta{code} must not
%   result in any page output. Otherwise the output of the layer stack will be
%   broken!
% \end{description}
%    \begin{macrocode}
%<*options>
\KOMA@key{onpsoneside}{%
  \l@addto@macro{\@ps@onesidehook}{#1}%
  \FamilyKeyStateProcessed
}
%<*interface>
\scrlayer@AddCsToInterface{KV@KOMA.\@currname.\@currext @onpsoneside}
\scrlayer@AddCsToInterface{KV@KOMA.\@currname.\@currext @onpsoneside@default}
%</interface>
%<package>\newcommand*{\@ps@onesidehook}{}
%</options>
%<*package&body>
\DefineFamilyKey[.definelayerpagestyle]{KOMAarg}{ononeside}{%
  \expandafter\l@addto@macro
  \csname @ps@\scrlayer@current@pagestyle @onesidehook\endcsname
  {#1}%
  \FamilyKeyStateProcessed
}
%</package&body>
%    \end{macrocode}
% \end{macro}^^A \@ps@onesidehook
% \end{option}^^A onpsoneside
% \begin{option}{onpstwoside}
% \begin{macro}{\@ps@twosidehook}
% \begin{description}
% \item[\Option{=\meta{code}}:] executes \meta{code} after
%   \Option{oninit}'s \meta{code} whenever the output of a layer stack of a
%   page in two-side layout is initialised. Note, that \meta{code} must not
%   result in any page output. Otherwise the output of the layer stack will be
%   broken!
% \end{description}
%    \begin{macrocode}
%<*options>
\KOMA@key{onpstwoside}{%
  \l@addto@macro{\@ps@twosidehook}{#1}%
  \FamilyKeyStateProcessed
}
%<*interface>
\scrlayer@AddCsToInterface{KV@KOMA.\@currname.\@currext @onpstwoside}
\scrlayer@AddCsToInterface{KV@KOMA.\@currname.\@currext @onpstwoside@default}
%</interface>
%<package>\newcommand*{\@ps@twosidehook}{}
%</options>
%<*package&body>
\DefineFamilyKey[.definelayerpagestyle]{KOMAarg}{ontwoside}{%
  \expandafter\l@addto@macro
  \csname @ps@\scrlayer@current@pagestyle @twosidehook\endcsname
  {#1}%
  \FamilyKeyStateProcessed
}
%</package&body>
%    \end{macrocode}
% \end{macro}^^A \@ps@twosidehook
% \end{option}^^A onpstwoside
% \begin{option}{onpsoddpage}
% \begin{macro}{\@ps@oddpagehook}
% \begin{description}
% \item[\texttt{=\meta{code}}:] executes \meta{code} after
%   \Option{ononeside}'s or \Option{ontwoside}'s \meta{code} whenever the
%   output of a layer stack of an odd page is initialised. Note, that
%   \meta{code} must not result in any page output. Otherwise the output of
%   the layer stack will be broken!
% \end{description}
%    \begin{macrocode}
%<*options>
\KOMA@key{onpsoddpage}{%
  \l@addto@macro{\@ps@oddpagehook}{#1}%
  \FamilyKeyStateProcessed
}
%<*interface>
\scrlayer@AddCsToInterface{KV@KOMA.\@currname.\@currext @onpsoddpage}
\scrlayer@AddCsToInterface{KV@KOMA.\@currname.\@currext @onpsoddpage@default}
%</interface>
%<package>\newcommand*{\@ps@oddpagehook}{}
%</options>
%<*package&body>
\DefineFamilyKey[.definelayerpagestyle]{KOMAarg}{onoddpage}{%
  \expandafter\l@addto@macro
  \csname @ps@\scrlayer@current@pagestyle @oddpagehook\endcsname
  {#1}%
  \FamilyKeyStateProcessed
}
%</package&body>
%    \end{macrocode}
% \end{macro}^^A \@ps@oddpagehook
% \end{option}^^A onpsoddpage
% \begin{option}{onpsevenpage}
% \begin{macro}{\@ps@evenpagehook}
% \begin{description}
% \item[\texttt{=\meta{code}}:] executes \meta{code} after
%   \Option{ononeside}'s or \Option{ontwoside}'s \meta{code} whenever the
%   output of a layer stack of an even page is initialised. Note, that
%   \meta{code} must not result in any page output. Otherwise the output of
%   the layer stack will be broken!
% \end{description}
%    \begin{macrocode}
%<*options>
\KOMA@key{onpsevenpage}{%
  \l@addto@macro{\@ps@evenpagehook}{#1}%
  \FamilyKeyStateProcessed
}
%<*interface>
\scrlayer@AddCsToInterface{KV@KOMA.\@currname.\@currext @onpsevenpage}
\scrlayer@AddCsToInterface{KV@KOMA.\@currname.\@currext @onpsevenpage@default}
%</interface>
%<package>\newcommand*{\@ps@evenpagehook}{}
%</options>
%<*package&body>
\DefineFamilyKey[.definelayerpagestyle]{KOMAarg}{onevenpage}{%
  \expandafter\l@addto@macro
  \csname @ps@\scrlayer@current@pagestyle @evenpagehook\endcsname
  {#1}%
  \FamilyKeyStateProcessed
}
%</package&body>
%    \end{macrocode}
% \end{macro}^^A \@ps@evenpagehook
% \end{option}^^A onpsevenpage
% \begin{option}{onpsfloatpage}
% \begin{macro}{\@ps@floatpagehook}
% \begin{description}
% \item[\Option{=\meta{code}}:] executes \meta{code} after
%   \Option{onoddpage}'s or \Option{onevenpage}'s \meta{code} whenever a float
%   column has been made (usually those pages are float pages).
% \end{description}
%    \begin{macrocode}
%<*options>
\KOMA@key{onpsfloatpage}{%
  \l@addto@macro{\@ps@floatpagehook}{#1}%
  \FamilyKeyStateProcessed
}
%<*interface>
\scrlayer@AddCsToInterface{KV@KOMA.\@currname.\@currext @onpsfloatpage}
\scrlayer@AddCsToInterface{KV@KOMA.\@currname.\@currext @onpsfloatpage@default}
%</interface>
%<package>\newcommand*{\@ps@floatpagehook}{}
%</options>
%<*package&body>
\DefineFamilyKey[.definelayerpagestyle]{KOMAarg}{onfloatpage}{%
  \expandafter\l@addto@macro
  \csname @ps@\scrlayer@current@pagestyle @floatpagehook\endcsname
  {#1}%
  \FamilyKeyStateProcessed
}
%</package&body>
%    \end{macrocode}
% \end{macro}^^A \@ps@floatpagehook
% \end{option}^^A onpsfloatpage
% \begin{option}{onpsnonfloatpage}
% \begin{macro}{\@ps@nonfloatpagehook}
% \begin{description}
% \item[\Option{=\meta{code}}:] executes \meta{code} after
%   \Option{onoddpage}'s or \Option{onevenpage}'s \meta{code} whenever no
%   float column has been made (usually those pages aren't float pages).
% \end{description}
%    \begin{macrocode}
%<*options>
\KOMA@key{onpsnonfloatpage}{%
  \l@addto@macro{\@ps@nonfloatpagehook}{#1}%
  \FamilyKeyStateProcessed
}
%<*interface>
\scrlayer@AddCsToInterface{KV@KOMA.\@currname.\@currext @onpsnonfloatpage}
\scrlayer@AddCsToInterface{%
  KV@KOMA.\@currname.\@currext @onpsnonfloatpage@default}
%</interface>
%<package>\newcommand*{\@ps@nonfloatpagehook}{}
%</options>
%<*package&body>
\DefineFamilyKey[.definelayerpagestyle]{KOMAarg}{onnonfloatpage}{%
  \expandafter\l@addto@macro
  \csname @ps@\scrlayer@current@pagestyle @nonfloatpagehook\endcsname
  {#1}%
  \FamilyKeyStateProcessed
}
%</package&body>
%    \end{macrocode}
% \end{macro}^^A \@ps@nonfloatpagehook
% \end{option}^^A onpsnonfloatpage
% \begin{option}{onpsbackground}
% \begin{macro}{\@ps@backgroundhook}
% \begin{description}
% \item[\texttt{=\meta{code}}:] executes \meta{code} after
%   \Option{onfloatpage}'s or \Option{onnonfloatpage}'s \meta{code} whenever
%   the output of a background layer stack is initialised. Note, that
%   \meta{code} must not result in any page output. Otherwise the output of
%   the layer stack will be broken!
% \end{description}
%    \begin{macrocode}
%<*options>
\KOMA@key{onpsbackground}{%
  \l@addto@macro{\@ps@backgroundhook}{#1}%
  \FamilyKeyStateProcessed
}
%<*interface>
\scrlayer@AddCsToInterface{KV@KOMA.\@currname.\@currext @onpsbackground}
\scrlayer@AddCsToInterface{%
  KV@KOMA.\@currname.\@currext @onpsbackground@default}
%</interface>
%<package>\newcommand*{\@ps@backgroundhook}{}
%</options>
%<*package&body>
\DefineFamilyKey[.definelayerpagestyle]{KOMAarg}{onbackground}{%
  \expandafter\l@addto@macro
  \csname @ps@\scrlayer@current@pagestyle @backgroundhook\endcsname
  {#1}%
  \FamilyKeyStateProcessed
}
%</package&body>
%    \end{macrocode}
% \end{macro}^^A \@ps@backgroundhook
% \end{option}^^A onbackground
% \begin{option}{onpsforeground}
% \begin{macro}{\@ps@foregroundhook}
% \begin{description}
% \item[\texttt{=\meta{code}}:] executes \meta{code} after
%   \Option{onfloatpage}'s or \Option{onnonfloatpage}'s \meta{code} whenever
%   the output of a foreground layer stack is initialised. Note, that
%   \meta{code} must not result in any page output. Otherwise the output of
%   the layer stack will be broken!
% \end{description}
%    \begin{macrocode}
%<*options>
\KOMA@key{onpsforeground}{%
  \l@addto@macro{\@ps@foregroundhook}{#1}%
  \FamilyKeyStateProcessed
}
%<*interface>
\scrlayer@AddCsToInterface{KV@KOMA.\@currname.\@currext @onpsforeground}
\scrlayer@AddCsToInterface{%
  KV@KOMA.\@currname.\@currext @onpsforeground@default}
%</interface>
%<package>\newcommand*{\@ps@foregroundhook}{}
%</options>
%<*package&body>
\DefineFamilyKey[.definelayerpagestyle]{KOMAarg}{onforeground}{%
  \expandafter\l@addto@macro
  \csname @ps@\scrlayer@current@pagestyle @foregroundhook\endcsname
  {#1}%
  \FamilyKeyStateProcessed
}
%</package&body>
%    \end{macrocode}
% \end{macro}^^A \@psforegroundhook
% \end{option}^^A onpsforeground
%    \begin{macrocode}
%<*package&body>
\newcommand*{\DeclarePageStyleByLayers}[3][]{%
  \edef\scrlayer@current@pagestyle{\GetRealPageStyle{#2}}%
  \expandafter\scrlayer@declare@ps@by@layers\expandafter{%
    \scrlayer@current@pagestyle
  }{#1}{#3}%
}
%    \end{macrocode}
% \begin{macro}{\scrlayer@declare@ps@by@layers}
% Needed, because of page style aliases. Same arguments like
% \cs{DeclarePageStyleByLayers} but, \#1 is the name of the page style, \#2 is
% the list of options and \#3 is still the list of layers.
%    \begin{macrocode}
\newcommand*{\scrlayer@declare@ps@by@layers}[3]{%
  \@namedef{@ps@#1@initialhook}{\@ps@initialhook}%
  \@namedef{@ps@#1@hook}{\@ps@hook}%
  \@namedef{@ps@#1@backgroundhook}{\@ps@backgroundhook}%
  \@namedef{@ps@#1@foregroundhook}{\@ps@foregroundhook}%
  \@namedef{@ps@#1@oddpagehook}{\@ps@oddpagehook}%
  \@namedef{@ps@#1@evenpagehook}{\@ps@evenpagehook}%
  \@namedef{@ps@#1@onesidehook}{\@ps@onesidehook}%
  \@namedef{@ps@#1@twosidehook}{\@ps@twosidehook}%
  \@namedef{@ps@#1@floatpagehook}{\@ps@floatpagehook}%
  \@namedef{@ps@#1@nonfloatpagehook}{\@ps@nonfloatpagehook}%
  \FamilyExecuteOptions[.definelayerpagestyle]{KOMAarg}{#2}%
  \@namedef{ps@#1}{%
    \renewcommand*{\currentpagestyle}{#1}%
    \@nameuse{@ps@@everystyle@@initialhook}%
    \@nameuse{@ps@#1@initialhook}%
    \renewcommand*{\currentpagestyle}{#1}%
    \renewcommand*{\@oddhead}{%
      \begingroup
        \let\headmark\rightmark
        \@nameuse{@ps@@everystyle@@hook}%
        \@nameuse{@ps@#1@hook}%
        \@nameuse{@ps@@everystyle@@\if@twoside two\else one\fi sidehook}%
        \@nameuse{@ps@#1@\if@twoside two\else one\fi sidehook}%
        \@nameuse{@ps@@everystyle@@oddpagehook}%
        \@nameuse{@ps@#1@oddpagehook}%
        \@nameuse{@ps@@everystyle@@\if@fcolmade\else non\fi floatpagehook}%
        \@nameuse{@ps@#1@\if@fcolmade\else non\fi floatpagehook}%
        \@nameuse{@ps@@everystyle@@backgroundhook}%
        \@nameuse{@ps@#1@backgroundhook}%
        \parbox[t][\headheight][t]{\linewidth}{%
          \vskip \dimexpr -\topmargin-1in
                          -\headheight
                          -\ht\strutbox\relax
          \hskip \dimexpr -\oddsidemargin-1in\relax
          \strut\makebox[\z@][l]{%
            \ForEachLayerOfPageStyle{@everystyle@}{%
              \scrlayer@do@page@style@element@layer{background}{odd}%
                                                   {########1}%
            }%
            \ForEachLayerOfPageStyle{#1}{%
              \scrlayer@do@page@style@element@layer{background}{odd}%
                                                   {########1}%
            }%
          }%
        }%
      \endgroup
    }%
    \renewcommand*{\@evenhead}{%
      \begingroup
        \let\headmark\leftmark
        \@nameuse{@ps@@everystyle@@hook}%
        \@nameuse{@ps@#1@hook}%
        \@nameuse{@ps@@everystyle@@twosidehook}%
        \@nameuse{@ps@#1@twosidehook}%
        \@nameuse{@ps@@everystyle@@evenpagehook}%
        \@nameuse{@ps@#1@evenpagehook}%
        \@nameuse{@ps@@everystyle@@\if@fcolmade\else non\fi floatpagehook}%
        \@nameuse{@ps@#1@\if@fcolmade\else non\fi floatpagehook}%
        \@nameuse{@ps@@everystyle@@backgroundhook}%
        \@nameuse{@ps@#1@backgroundhook}%
        \parbox[t][\headheight][t]{\linewidth}{%
          \vskip \dimexpr -\topmargin-1in
                          -\headheight
                          -\ht\strutbox\relax
          \hskip \dimexpr-\evensidemargin-1in\relax
          \strut\makebox[\z@][l]{%
            \ForEachLayerOfPageStyle{@everystyle@}{%
              \scrlayer@do@page@style@element@layer{background}{even}%
                                                   {########1}%
            }%
            \ForEachLayerOfPageStyle{#1}{%
              \scrlayer@do@page@style@element@layer{background}{even}%
                                                   {########1}%
            }%
          }%
        }%
      \endgroup
    }%
    \renewcommand*{\@oddfoot}{%
      \begingroup
        \let\headmark\rightmark
        \@nameuse{@ps@@everystyle@@hook}%
        \@nameuse{@ps@#1@hook}%
        \@nameuse{@ps@@everystyle@@\if@twoside two\else one\fi sidehook}%
        \@nameuse{@ps@#1@\if@twoside two\else one\fi sidehook}%
        \@nameuse{@ps@@everystyle@@oddpagehook}%
        \@nameuse{@ps@#1@oddpagehook}%
        \@nameuse{@ps@@everystyle@@\if@fcolmade\else non\fi floatpagehook}%
        \@nameuse{@ps@#1@\if@fcolmade\else non\fi floatpagehook}%
        \@nameuse{@ps@@everystyle@@foregroundhook}%
        \@nameuse{@ps@#1@foregroundhook}%
        \parbox[t][\headheight][t]{\linewidth}{%
          \vskip \dimexpr -\topmargin-1in
                          -\headheight
                          -\headsep
                          -\textheight
                          -\footskip
                          -\ht\strutbox\relax
          \hskip \dimexpr -\oddsidemargin-1in\relax
          \strut\makebox[\z@][l]{%
            \ForEachLayerOfPageStyle{@everystyle@}{%
              \scrlayer@do@page@style@element@layer{foreground}{odd}%
                                                   {########1}%
            }%
            \ForEachLayerOfPageStyle{#1}{%
              \scrlayer@do@page@style@element@layer{foreground}{odd}%
                                                   {########1}%
            }%
          }%
        }%
      \endgroup
    }%
    \renewcommand*{\@evenfoot}{%
      \begingroup
        \let\headmark\leftmark
        \@nameuse{@ps@@everystyle@@hook}%
        \@nameuse{@ps@#1@hook}%
        \@nameuse{@ps@@everystyle@@twosidehook}%
        \@nameuse{@ps@#1@twosidehook}%
        \@nameuse{@ps@@everystyle@@evenpagehook}%
        \@nameuse{@ps@#1@evenpagehook}%
        \@nameuse{@ps@@everystyle@@\if@fcolmade\else non\fi floatpagehook}%
        \@nameuse{@ps@#1@\if@fcolmade\else non\fi floatpagehook}%
        \@nameuse{@ps@@everystyle@@foregroundhook}%
        \@nameuse{@ps@#1@foregroundhook}%
        \parbox[t][\headheight][t]{\linewidth}{%
          \vskip \dimexpr -\topmargin-1in
                          -\headheight
                          -\headsep
                          -\textheight
                          -\footskip
                          -\ht\strutbox\relax
          \hskip \dimexpr-\evensidemargin-1in\relax
          \strut\makebox[\z@][l]{%
            \ForEachLayerOfPageStyle{@everystyle@}{%
              \scrlayer@do@page@style@element@layer{foreground}{even}%
                                                   {########1}%
            }%
            \ForEachLayerOfPageStyle{#1}{%
              \scrlayer@do@page@style@element@layer{foreground}{even}%
                                                   {########1}%
            }%
          }%
        }%
      \endgroup
    }%
  }%
  \@namedef{@ps@#1@layers}{}%
  \@for \reserved@a:=#3\do {%
    \ifstr\reserved@a\@empty{}{%
      \expandafter\@cons\csname @ps@#1@layers\endcsname{{\reserved@a}}%
    }%
  }%
}
%</package&body>
%    \end{macrocode}
% \end{macro}^^A \scrlayer@declare@ps@by@layers
%
% \begin{macro}{\ForEachLayerOfPageStyle}
%   \begin{description}
%   \item[\Parameter{string}:] a valid page style (must be fully expandable
%     and expand to the name of a existing page style); note, that currently
%     no exists test will be done.
%   \item[\Parameter{code}:] any macro definition body with usage of at most
%     one argument (\texttt{\#1}), that will be replaced by the layer's name
%   \end{description}
% Do the given \meta{code} for each layer of the page style
% \meta{string}. Note, that the expansion of \meta{code} will be done inside
% a group.
%    \begin{macrocode}
%<*package&body>
\newcommand*{\ForEachLayerOfPageStyle}[2]{%
  \begingroup
    \edef\reserved@a{\GetRealPageStyle{#1}}%
    \def\@elt##1{\ifscrlayer@deactivate@layers\else #2\fi}%
    \@nameuse{@ps@\reserved@a @layers}%
  \endgroup
}
%</package&body>
%    \end{macrocode}
% \begin{option}{deactivatepagestylelayers}
% \begin{macro}{\ifscrlayer@deactivate@layers}
%   \begin{description}
%   \item[\Parameter{simple switch}:] whether or not
%     \Macro{ForEachLayerOfPageStyle} should ignore the layers.
%   \end{description}
% This is a global \KOMAScript{} options.  Several other definitions and at
% least the usage of the page style will ignore the layers if
% \Macro{ForEachLayerOfPageStyle} ignores them. So this is something like:
% hide the layers. It may also be useful inside the code for the hooks
% described above, because hooks may used to deactivate the layers with this
% option too.
%    \begin{macrocode}
%<*options>
\KOMA@ifkey{deactivatepagestylelayers}{scrlayer@deactivate@layers}
%<*interface>
\scrlayer@AddCsToInterface{%
  KV@KOMA.\@currname.\@currext @deactivatepagestylelayers}
\scrlayer@AddCsToInterface{%
  KV@KOMA.\@currname.\@currext @deactivatepagestylelayers@default}
%</interface>
%</options>
%    \end{macrocode}
% \end{macro}^^A \ifscrlayer@deactivate@layers
% \end{option}^^A deactivatepagestylelayers
% \end{macro}^^A \ForEachLayerOfPageStyle
%
% \begin{macro}{\scrlayer@do@page@style@element@layer}
% Helper macro to show one layer. First argument is either ``background'' or
% ``foreground'', second argument is either ``odd'' or ``even'', and third
% argument is the name of the layer. Note, that in draft mode for every layer
% will be shown also a \cs{layercontentsmeasure}.
%    \begin{macrocode}
%<*package&body>
\newcommand*{\scrlayer@do@page@style@element@layer}[3]{%
  \begingroup
    \expandafter\ifx\csname if@scr@l@#3@\if@fcolmade\else non\fi floatpage%
                    \expandafter\endcsname\csname iftrue\endcsname
      \expandafter\ifx\csname if@scr@l@#3@\if@twoside two\else one\fi side%
                      \expandafter\endcsname\csname iftrue\endcsname
        \expandafter
        \ifx\csname if@scr@l@#3@#1\expandafter\endcsname
            \csname iftrue\endcsname
          \expandafter
          \ifx\csname if@scr@l@#3@#2\expandafter\endcsname
              \csname iftrue\endcsname
            \ifscrlayer@draft
              \scr@layerbox(\csname scr@l@#3@x\endcsname,%
                            \csname scr@l@#3@y\endcsname)%
                           (\csname scr@l@#3@w\endcsname,%
                            \csname scr@l@#3@h\endcsname)%
                           [\csname scr@l@#3@align\endcsname]%
                           {\layercontentsmeasure}%
            \fi
            \scr@layerbox(\csname scr@l@#3@x\endcsname,%
                          \csname scr@l@#3@y\endcsname)%
                         (\csname scr@l@#3@w\endcsname,%
                          \csname scr@l@#3@h\endcsname)%
                         [\csname scr@l@#3@align\endcsname]%
                         {\csname scr@l@#3@contents\endcsname}%
          \fi
        \fi
      \fi
    \fi
  \endgroup
}
%    \end{macrocode}
% \begin{macro}{\scr@layerbox}
% \begin{macro}{\scr@@layerbox}
% The layer box is used to output a layer in \cs{@oddhead}, \cs{@evenhead},
% \cs{@oddfoot}, or \cs{@evenfoot}. Is has two pairs of arguments: ($x,y$)
% and ($w,h$), where $x$ is the distance from left paper edge, $y$ is the
% distance from the topmost edge of paper, $w$ is the width of the box and $h$
% is the height of the box. The fifth argument is an optional vertical and
% horizontal alignment of the box. It may be a combination of the alignment
% characters described above. The sixth and last argument is the contents of
% the layer, to be placed into the last argument of the innermost
% \cs{parbox}.
%    \begin{macrocode}
\def\scr@layerbox(#1,#2)(#3,#4){%
  \@ifnextchar [%]
  {\scr@@layerbox(#1,#2)(#3,#4)}{\scr@@layerbox(#1,#2)(#3,#4)[]}%
}
\def\scr@@layerbox(#1,#2)(#3,#4)[#5]#6{%
  \begingroup
    \edef\layerxoffset{#1}%
    \edef\layeryoffset{#2}%
    \edef\layerwidth{#3}%
    \edef\layerheight{#4}%
    \def\scr@l@valign{t}%
    \def\scr@l@halign{l}%
    \edef\reserved@b{#5}%
    \expandafter\@tfor\expandafter\reserved@a\expandafter:\expandafter=%
    \reserved@b\do{%
      \if t\reserved@a
        \def\scr@l@valign{t}%
      \else
        \if c\reserved@a
          \def\scr@l@valign{c}%
          \def\scr@l@halign{c}%
        \else
          \if b\reserved@a
            \def\scr@l@valign{b}%
          \else
            \if l\reserved@a
              \def\scr@l@halign{l}%
            \else
              \if r\reserved@a
                \def\scr@l@halign{r}%
              \else
                \PackageWarning{scrlayer}{%
                  Unknown alignment `\reserved@a' ignored}%
              \fi
            \fi
          \fi
        \fi
      \fi
    }%
    \parbox[t][\z@][t]{\z@}{%
      \vskip\layeryoffset
      \if b\scr@l@valign\vskip-\layerheight\fi
      \if c\scr@l@valign\vskip-.5\dimexpr\layerheight\relax\fi
      \makebox[\z@][l]{%
        \hskip\layerxoffset
        \makebox[\z@][\scr@l@halign]{%
          \parbox[\scr@l@valign][\layerheight][\scr@l@valign]{\layerwidth}{%
            \vskip\z@\strut{%
              \ifscrlayer@forceignoreuppercase
                \expandafter\let\csname MakeUppercase \endcsname\@firstofone
                \let\MakeUppercase\@firstofone
                \let\uppercase\@firstofone
              \fi
              #6%
            }\strut\vskip\z@
          }%
        }%
      }%
    }%
  \endgroup
}
%</package&body>
%    \end{macrocode}
% \end{macro}^^A \scr@@layerbox
% \end{macro}^^A \scr@layerbox
% \begin{option}{draft}
% \begin{macro}{\ifscrlayer@draft}
%   \begin{description}
%   \item[\Parameter{simple switch}:] whether or not to use the draft mode,
%     that, i.e., activates visualisation of the layers.
%   \end{description}
% When option is set, every layer is shown twice: one time with it's own
% contents and one time with contents \Macro{layercontentsmeasure}.
%    \begin{macrocode}
%<*options>
\KOMA@ifkey{draft}{scrlayer@draft}
%<*interface>
\scrlayer@AddCsToInterface{KV@KOMA.\@currname.\@currext @draft}
\scrlayer@AddCsToInterface{KV@KOMA.\@currname.\@currext @draft@default}
%</interface>
%</options>
%    \end{macrocode}
% \end{macro}^^A \ifscrlayer@draft
% \end{option}^^A draft
% \end{macro}^^A \scrlayer@do@page@style@element@layer
% \end{macro}^^A \DeclarePageStyleByLayers
%
%
% \begin{macro}{\DeclareNewPageStyleByLayers}
% Arguments like \Macro{DeclarePageStyleByLayers}; results in error if the page
% style has been defined (or declared) already.
% \begin{macro}{\ProvidePageStyleByLayers}
% Arguments like \Macro{DeclarePageStyleByLayers}; doesn't define anything it
% the page style has been defined (or declared) already.
% \begin{macro}{\RedeclarePageStyleByLayers}
% Arguments like \Macro{DeclarePageStyleByLayers}; results in error if the page
% style hasn't been defined (or declared) already.
%    \begin{macrocode}
%<*package&body>
\newcommand*{\DeclareNewPageStyleByLayers}[2][]{%
  \@ifundefined{ps@#2}{}{%
    \PackageError{scrlayer}{%
      Page style `#2' already defined%
    }{%
      You may use \string\DeclareNewPageStyleByLayers\space to declare a new
      page style only\MessageBreak
      if that page style hasn't been declared or defined before.\MessageBreak
      You may use either \string\ProvidePageStyleByLayers\space to declare the
      page style only\MessageBreak
      if it hasn't been declared or defined before, or
      \string\RedeclarePageStyleByLayers\MessageBreak
      to overwrite the former
      declaration or definition of the page style%
      \@ifundefined{@ps@#2@layers}{}{,\MessageBreak
        or \string\AddLayersToPageStyle\space to add further layers to the
        already declared\MessageBreak
        page style, or \string\RemoveLayersFromPageStyle\space to remove
        layers from the\MessageBreak
        already declared page style}.\MessageBreak
      Nevertheless, if you'll continue, the page style will be
      overwritten\MessageBreak
      by the new declaration.%
    }%
  }%
  \DeclarePageStyleByLayers[{#1}]{#2}%
}
\newcommand*{\ProvidePageStyleByLayers}[3][]{%
  \@ifundefined{ps@#2}{%
    \DeclarePageStyleByLayers[{#1}]{#2}{#3}%
  }{%
%<*trace>
    \PackageInfo{scrlayer}{%
      \string\ProvidePageStyleByLayers{#2}{#3} ignored,\MessageBreak
      because page style `#2'\MessageBreak
      already exists%
    }%
%</trace>
  }%
}
\newcommand*{\RedeclarePageStyleByLayers}[2][]{%
  \@ifundefined{ps@#2}{%
    \PackageError{scrlayer}{%
      Page style `#2' not yet defined%
    }{%
      You may use \string\RedeclarePageStyleByLayers\space to declare a page
      style only\MessageBreak
      if that page style has already been declared or defined.\MessageBreak
      You may use either \string\DeclareNewPageStyleByLayers,
      \string\DeclarePageStyleByLayers,\MessageBreak
      or \string\ProvidePageStyleByLayers\space to declare that not yet
      defined page style.\MessageBreak
      Nevertheless, if you'll continue, the page style will be declared.%
    }%
  }{}%
  \DeclarePageStyleByLayers[{#1}]{#2}%
}
%</package&body>
%    \end{macrocode}
% \end{macro}^^A \RedeclarePageStyleByLayers
% \end{macro}^^A \ProvidePageStyleByLayers
% \end{macro}^^A \DeclareNewPageStyleByLayers
%
% We also declare page style \Pagestyle{@everystyle@} by default. You should
% not use this page style as an real page style (even not as the empty
% one). The layers of this page style will be used by every other layer page
% style. An we re-declare \Pagestyle{empty} to be a layer page style.
%    \begin{macrocode}
%<*package&final>
\DeclareNewPageStyleByLayers{@everystyle@}{}
\RedeclarePageStyleByLayers{empty}{}
%</package&final>
%    \end{macrocode}
%
% \begin{macro}{\AddLayersToPageStyle}
% \begin{macro}{\AddLayersAtBeginOfPageStyle}
% \begin{macro}{\AddLayersAtEndOfPageStyle}
% \begin{macro}{\RemoveLayersFromPageStyle}
%   \begin{description}
%   \item[\Parameter{string}:] the name of the page style to be modified (must
%     be expandable and result in a string).
%   \item[\Parameter{string list}:] comma separated list of layer names (must
%     be expandable and result in strings); first in the list will be added
%     first.
%   \end{description}
% Change the layer list of a given page style. The differences between the
% commands are:
% \begin{description}
% \item[\Macro{AddLayersToPageStyle}:] first in the \meta{string list} will
%   be added first at the end.
% \item[\Macro{AddLayersAtBeginOfPageStyle}:] first in the \meta{string list}
%   will be added first at the start.  Note, that this will result in changing
%   the order of the layers in \meta{string list}.
% \item[\Macro{AddLayerAtEndOfPageStyle}:] same like
%   \Macro{AddLayerToPageStyle}.
% \item[\Macro{RemoveLayersFromPageStyle}:] remove the layers from the page
%   style's layer list.
% \end{description}
%    \begin{macrocode}
%<*package&body>
\newcommand*{\AddLayersToPageStyle}[2]{%
  \edef\reserved@b{\GetRealPageStyle{#1}}%
  \IfLayerPageStyleExists{\reserved@b}{%
    \@for \reserved@a:=#2\do {%
      \ifstr\reserved@a\@empty{}{%
        \expandafter\@cons\csname @ps@\reserved@b @layers\endcsname
        {{\reserved@a}}%
      }%
    }%
  }{%
    \scrlayer@lpm@error{#1}{adding layers}%
  }%
}
\newcommand*{\AddLayersAtEndOfPageStyle}{%
  \AddLayersToPageStyle
}
\newcommand*{\AddLayersAtBeginOfPageStyle}[2]{%
  \begingroup
    \let\@cons\@snoc
    \AddLayersToPageStyle{#1}{#2}%
  \endgroup
}
%    \end{macrocode}
% \begin{macro}{\@snoc}
% \cs{@snoc} is a helper macro similar to \cs{@cons} from \LaTeX{} kernel, but
% it appends at the front instead of the end.
%    \begin{macrocode}
\newcommand*{\@snoc}[2]{%
  \begingroup\let\@elt\relax\xdef#1{\@elt #2#1}\endgroup
}
%    \end{macrocode}
% \end{macro}^^A \@snoc
%    \begin{macrocode}
\newcommand*{\RemoveLayersFromPageStyle}[2]{%
  \edef\reserved@b{\GetRealPageStyle{#1}}%
  \IfLayerPageStyleExists{#1}{%
    \@for \reserved@a:=#2\do {%
      \ifstr\reserved@a\@empty{}{%
        \expandafter\remove@layer@from@page@style\expandafter{\reserved@a}%
        {\reserved@b}%
      }%
    }%
  }{%
    \scrlayer@lpm@error{#1}{removing layers}%
  }%
}
%    \end{macrocode}
% \begin{macro}{\remove@layer@from@page@style}
% Helper macro to remove exactly one layer (arg 1) from a page style (arg 2).
%    \begin{macrocode}
\newcommand*{\remove@layer@from@page@style}[2]{%
  \begingroup
    \expandafter\let\expandafter\reserved@a\csname @ps@#2@layers\endcsname
    \@namedef{@ps@#2@layers}{}%
    \def\@elt##1{%
      \ifstr{#1}{##1}{}{%
        \expandafter\@cons\csname @ps@#2@layers\endcsname{{##1}}%
      }%
    }\reserved@a
  \endgroup
}
%    \end{macrocode}
% \end{macro}^^A \remoce@layer@from@page@style
% \begin{macro}{\scrlayer@lpm@error}
%   \begin{description}
%   \item[\Parameter{string}:] the name of the page style to be modified (must
%     be expandable and result in a string).
%   \item[\Parameter{string}:] the kind of modification, that isn't allowed
%     (must be expandable and result in a string).
%   \end{description}
% Show an error because of page style it either not a defined or not a layer
% page style.
%    \begin{macrocode}
\newcommand*{\scrlayer@lpm@error}[2]{%
  \PackageError{scrlayer}{`#1' is not a layer page style}{%
    \scr@ifundefinedorrelax{ps@#1}{%
      Page style `#1' is not defined,
    }{%
      Page style `#1' is not a layer page style,
    }%
    but #2\MessageBreak
    may be used only for layer page styles declared using\MessageBreak
    \string\DeclarePageStyleByLayers,
    \string\DeclareNewPageStyleByLayers,\MessageBreak
    of \string\ProvidePageStyleByLayers.\MessageBreak
    If you'll continue, your operation will be ignored.%
  }%
}
%</package&body>
%    \end{macrocode}
% \end{macro}^^A \scrlayer@lpm@error
% \end{macro}^^A \RemoveLayersFromPageStyle
% \end{macro}^^A \AddLayersAtEndOfPageStyle
% \end{macro}^^A \AddLayersAtBeginOfPageStyle
% \end{macro}^^A \AddLayersToPageStyle
%
% \begin{macro}{\AddLayersToPageStyleBeforeLayer}
% \begin{macro}{\AddLayersToPageStyleAfterLayer}
%   \begin{description}
%   \item[\Parameter{string}:] the name of the page style to be modified (must
%     be expandable and result in a string).
%   \item[\Parameter{string list}:] comma separated list of layer names (must
%     be expandable and result in strings); first in the list will be added
%     first.
%   \item[\Parameter{string}:] the name of the layer before
%     (\Macro{AddLayersToPageStyleBeforeLayer}) or after
%     (\Macro{AddLayersToPageStyleAfterLayer}) that the layers of the list
%     should be added.
%   \end{description}
% Note: If the layer from third argument is not part of the page style's layer
% list, the new layers won't be added anywhere.
%    \begin{macrocode}
%<*package&body>
\newcommand*{\AddLayersToPageStyleAfterLayer}[3]{%
  \edef\reserved@b{\GetRealPageStyle{#1}}%
  \IfLayerPageStyleExists{\reserved@b}{%
    \begingroup
      \expandafter\let\expandafter\reserved@a
      \csname @ps@\reserved@b @layers\endcsname
      \@namedef{@ps@\reserved@b @layers}{}%
      \def\@elt##1{%
        \ifstr{##1}\@empty{}{%
          \expandafter\@cons\csname @ps@\reserved@b @layers\endcsname{{##1}}%
          \ifstr{##1}{#3}{%
            \@for \reserved@a:=#2\do {%
              \ifstr\reserved@a\@empty{}{%
                \expandafter\@cons\csname @ps@\reserved@b @layers\endcsname
                {{\reserved@a}}%
              }%
            }%
          }{}%
        }%
      }%
      \reserved@a
    \endgroup
  }{%
    \scrlayer@lpm@error{#1}{adding layers}%
  }%
}
\newcommand*{\AddLayersToPageStyleBeforeLayer}[3]{%
  \edef\reserved@b{\GetRealPageStyle{#1}}%
  \IfLayerPageStyleExists{\reserved@b}{%
    \begingroup
      \expandafter\let\expandafter\reserved@a
      \csname @ps@\reserved@b @layers\endcsname
      \@namedef{@ps@\reserved@b @layers}{}%
      \def\@elt##1{%
        \ifstr{##1}\@empty{}{%
          \ifstr{##1}{#3}{%
            \@for \reserved@a:=#2\do {%
              \ifstr\reserved@a\@empty{}{%
                \expandafter\@cons\csname @ps@\reserved@b @layers\endcsname
                {{\reserved@a}}%
              }%
            }%
          }{}%
          \expandafter\@cons\csname @ps@#1@layers\endcsname{{##1}}%
        }%
      }%
      \reserved@a
    \endgroup
  }{%
    \scrlayer@lpm@error{#1}{adding layers}%
  }%
}
%</package&body>
%    \end{macrocode}
% \end{macro}^^A \AddLayersToPageStyleAfterLayer
% \end{macro}^^A \AddLayersToPageStyleBeforeLayer
%
%
% \begin{macro}{\UnifyLayersAtPageStyle}
%   \begin{description}
%   \item[\Parameter{string}:] the name of the page style to be unified (must
%     be expandable and result in a string).
%   \end{description}
% Remove doublets of layers from a page style.
%    \begin{macrocode}
%<*package&body>
\newcommand*{\UnifyLayersAtPageStyle}[1]{%
  \edef\reserved@b{\GetRealPageStyle{#1}}%
  \IfLayerPageStyleExists{\reserved@b}{%
    \expandafter\let\expandafter\reserved@a
    \csname @ps@\reserved@b @layers\endcsname
    \@namedef{@ps@\reserved@b @layers}{}%
    \begingroup
      \def\@elt##1{%
        \ifstr{##1}\@empty{}{%
          \remove@layer@from@page@style{##1}{\reserved@b}%
          \expandafter\@cons\csname @ps@\reserved@b @layers\endcsname{{##1}}%
        }%
      }%
      \reserved@a
    \endgroup
  }{%
    \scrlayer@lpm@error{#1}{unifying}%
  }%
}
%</package&body>
%    \end{macrocode}
% \end{macro}^^A \UnifyLayersAtPageStyle
%
% \begin{macro}{\ModifyLayerPageStyleOptions}
% \begin{macro}{\AddToLayerPageStyleOptions}
%   \begin{description}
%   \item[\Parameter{string}:] the name of the page style to be modified (must
%     be expandable and result in a string).
%   \item[\Parameter{option list}:] comma separated list of named page
%     style options.  You may use any of the options provided for
%     \Macro{DeclarePageStyle}.
%   \end{description}
% \Macro{ModifyLayerPageStyleOptions} replaces the options and only the
% options from the list by their new
% values. \Macro{AddToLayerPageStyleOptions} adds the new values to the
% already given.
%    \begin{macrocode}
%<*package&body>
\newcommand*{\ModifyLayerPageStyleOptions}[2]{%
  \edef\reserved@a{\GetRealPageStyle{#1}}%
  \IfLayerPageStyleExists{#1}{%
    \expandafter\scrlayer@modify@layer@ps@options\expandafter{%
      \reserved@a
    }{#2}%
  }{%
    \scrlayer@lpm@error{#1}{modifying}%
  }%
}
%    \end{macrocode}
% \begin{macro}{\scrlayer@modify@layer@ps@options}
% Helper needed because of alias page styles. Same parameters like
% \cs{ModifyLayerPageStyleOptions}
%    \begin{macrocode}
\newcommand*{\scrlayer@modify@layer@ps@options}[2]{%
  \begingroup
    \def\scrlayer@current@pagestyle{#1}%
    \@namedef{@ps@#1@initialhook}{}%
    \@namedef{@ps@#1@hook}{}%
    \@namedef{@ps@#1@backgroundhook}{}%
    \@namedef{@ps@#1@foregroundhook}{}%
    \@namedef{@ps@#1@oddpagehook}{}%
    \@namedef{@ps@#1@evenpagehook}{}%
    \@namedef{@ps@#1@onesidehook}{}%
    \@namedef{@ps@#1@twosidehook}{}%
    \@namedef{@ps@#1@floatpagehook}{}%
    \@namedef{@ps@#1@nonfloatpagehook}{}%
    \FamilyExecuteOptions[.definelayerpagestyle]{KOMAarg}{#2}%
    \def\reserved@a{\endgroup}%
    \def\@sls@##1{%
      \expandafter\let\expandafter\reserved@b\csname @ps@#1@##1hook\endcsname
      \ifx\reserved@b\@empty\else
        \l@addto@macro\reserved@a{\@namedef{@ps@#1@##1hook}}%
        \expandafter\l@addto@macro\expandafter\reserved@a\expandafter{%
          \expandafter{%
            \reserved@b
          }%
        }%
      \fi
    }%
    \@sls@{initial}%
    \@sls@{}%
    \@sls@{background}%
    \@sls@{foreground}%
    \@sls@{oddpage}%
    \@sls@{evenpage}%
    \@sls@{oneside}%
    \@sls@{twoside}%
    \@sls@{floatpage}%
    \@sls@{nonfloatpage}%
  \reserved@a
}
%    \end{macrocode}
% \end{macro}^^A \scrlayer@modify@layer@ps@options
%    \begin{macrocode}
\newcommand*{\AddToLayerPageStyleOptions}[2]{%
  \IfLayerPageStyleExists{#1}{%
    \def\scrlayer@current@pagestyle{#1}%
    \FamilyExecuteOptions[.definelayerpagestyle]{KOMAarg}{#2}%
  }{%
    \scrlayer@lpm@error{#1}{modifying}%
  }%
}        
%</package&body>
%    \end{macrocode}
% \end{macro}^^A \AddToLayerPageStyleOptions
% \end{macro}^^A \ModifyLayerPageStyleOptions
%
% \begin{macro}{\DeclarePageStyleAlias}
% \begin{macro}{\DeclareNewPageStyleAlias}
% \begin{macro}{\ProvidePageStyleAlias}
% \begin{macro}{\RedeclarePageStyleAlias}
%   \begin{description}
%   \item[\Parameter{string}:] The name of the page style to be declared
%     (must be expandable and result in a string).
%   \item[\Parameter{string}:] The name of the existing page style
%     (must be expandable and result in a string).
%   \end{description}
%    \begin{macrocode}
%<*package&body>
\newcommand*{\DeclarePageStyleAlias}[2]{%
  \edef\reserved@a{\GetRealPageStyle{#2}}%
  \scr@ifundefinedorrelax{ps@\reserved@a}{%
    \PackageError{scrlayer}{unknown real page style `#2'}{%
      You've tried to declare an alias for page style `#2',\MessageBreak
      but the real page style of `#2' is undefined.\MessageBreak
      You can define aliases, only if the real page style has been
      defined.\MessageBreak
      If you'll continue, the declaration will be ignored.%
    }%
    \DestroyRealLayerPageStyle{#1}%
    \DestroyLayerAlias{#1}%
  }{%
    \@namedef{@ps@#1@alias}{#2}%
    \@namedef{ps@#1}{\pagestyle{\@nameuse{@ps@#1@alias}}}%
  }%
}
\newcommand*{\DeclareNewPageStyleAlias}[1]{%
  \@ifundefined{ps@#1}{}{%
    \PackageError{scrlayer}{%
      Page style `#1' already defined%
    }{%
      You may use \string\DeclareNewPageStyleAlias\space to declare a new
      page style only\MessageBreak
      if that page style hasn't been declared or defined before.\MessageBreak
      You may use either \string\ProvidePageStyleAlias\space to declare the
      page style only\MessageBreak
      if it hasn't been declared or defined before, or
      \string\RedeclarePageStyleAlias\MessageBreak
      to overwrite the former declaration or definition of the page
      style\MessageBreak
      Nevertheless, if you'll continue, the page style will be
      overwritten\MessageBreak
      by the new alias.%
    }%
  }%
  \DeclarePageStyleAlias{#1}%
}
\newcommand*{\ProvidePageStyleAlias}[2]{%
  \@ifundefined{ps@#1}{%
    \DeclarePageStyleAlias{#1}{#2}%
  }{%
%<*trace>
    \PackageInfo{scrlayer}{%
      \string\ProvidePageStyleAlias{#1}{#2} ignored,\MessageBreak
      because page style `#1' already\MessageBreak
      exists%
    }%
%</trace>
  }%
}
\newcommand*{\RedeclarePageStyleAlias}[1]{%
  \@ifundefined{ps@#1}{%
    \PackageError{scrlayer}{%
      Page style `#1' not yet defined%
    }{%
      You may use \string\RedeclarePageStyleAlias\space to declare a page
      style only\MessageBreak
      if that page style has already been declared or defined.\MessageBreak
      You may use either \string\DeclareNewPageStyleAlias,
      \string\DeclarePageStyleAlias,\MessageBreak
      or \string\ProvidePageStyleAlias\space to declare that not yet
      defined page style.\MessageBreak
      Nevertheless, if you'll continue, the page style will be declared.%
    }%
  }{}%
  \DeclarePageStyleAlias{#1}%
}
%    \end{macrocode}
% \end{macro}^^A \RedeclarePageStyleAlias
% \end{macro}^^A \ProvidePageStyleAlias
% \end{macro}^^A \DeclareNewPageStyleAlias
% \end{macro}^^A \DeclarePageStyleAlias
%
% \begin{macro}{\DestroyPageStyleAlias}
%   \begin{description}
%   \item[\Parameter{string}:] the name of a page style (must be
%     expandable and result in a string).
%   \end{description}
%    \begin{macrocode}
\newcommand*{\DestroyPageStyleAlias}[1]{%
  \scr@ifundefinedorrelax{@ps@#1@alias}{}{%
    \expandafter\let\csname @ps@#1@alias\endcsname\relax
    \expandafter\let\csname ps@#1\endcsname\relax
  }%
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\GetRealPageStyle}
%   \begin{description}
%   \item[\Parameter{string}:] the name of a page style (must be
%     expandable and result in a string).
%   \end{description}
% Get the real name of the page style.
%    \begin{macrocode}
\newcommand*{\GetRealPageStyle}[1]{%
  \scr@ifundefinedorrelax{@ps@#1@alias}{#1}{%
    \expandafter\GetRealPageStyle\expandafter{%
      \expandafter\csname @ps@#1@alias\expandafter\endcsname\expandafter}%
  }%
}
%</package&body>
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\IfLayerPageStyleExists}
% \begin{macro}{\IfRealLayerPageStyleExists}
%   \begin{description}
%   \item[\Parameter{string}:] the name of the page style to be tested (must
%     be expandable and result in a string).
%   \item[\Parameter{code}:] whatever code should be expanded, if the test
%     result is true.
%   \item[\Parameter{code}:] whatever code should be expanded, if the test
%     result is false.
%   \end{description}
% Test, whether or not the page style is a declared layer page style.
%    \begin{macrocode}
%<*package&body>
\newcommand*{\IfLayerPageStyleExists}[1]{%
  \scr@ifundefinedorrelax{ps@#1}{%
    \expandafter\@secondoftwo
  }{%
    \scr@ifundefinedorrelax{@ps@#1@layers}{%
      \scr@ifundefinedorrelax{@ps@#1@alias}{%
        \expandafter\@secondoftwo
      }{%
        \expandafter\IfLayerPageStyleExists\expandafter{%
          \expandafter\csname @ps@#1@alias\expandafter\endcsname\expandafter}%
      }%
    }{%
      \expandafter\@firstoftwo
    }%
  }%
}
\newcommand*{\IfRealLayerPageStyleExists}[1]{%
  \scr@ifundefinedorrelax{ps@#1}{%
    \expandafter\@secondoftwo
  }{%
    \scr@ifundefinedorrelax{@ps@#1@layers}{%
      \expandafter\@secondoftwo
    }{%
      \expandafter\@firstoftwo
    }%
  }%
}
%</package&body>
%    \end{macrocode}
% \end{macro}^^A \IfRealLayerPageStyleExists
% \end{macro}^^A \IfLayerPageStyleExists
%
% \begin{macro}{\IfLayerAtPageStyle}
% \begin{macro}{\IfSomeLayersAtPageStyle}
% \begin{macro}{\IfLayersAtPageStyle}
%   \begin{description}
%   \item[\Parameter{string}:] the name of the page style to be tested (must
%     be expandable and result in a string).
%   \item[\Parameter{string}:] the name(s) of the layer(s) to be tested (must be
%     expandable and result in a string).
%   \item[\Parameter{code}:] whatever code should be expanded, if the test
%     result is true.
%   \item[\Parameter{code}:] whatever code should be expanded, if the test
%     result is false.
% \end{description}
% Tests:
% \begin{description}
% \item[\Macro{IfLayerAtPageStyle}:] Test, whether or not the page style has a
%   layer. The second argument is the name of one layer only!
% \item[\Macro{IfSomeLayersAtPageStyle}:] Test, whether or not the page style
%   has at least one layer of a list of layers. The second argument is a comma
%   separated list of layer names.
% \item[\Macro{IfLayersAtPageStyle}:] Test, whether or not the page style has
%   every layer of a list of layers. The second argument is a comma separated
%   list of layer names.
% \end{description}
% Note, that testing an page style, that is not a layer page style will result
% in an error and neither the third nor the fourth argument will be expanded.
% Note, that layers with empty name are only part of a layer page style
% without any layers.
%
% Note also, that with active \Option{deactivatepagestylelayers} layers are
% logically not longer part of the page styles.
%    \begin{macrocode}
%<*package&body>
\newcommand*{\IfLayerAtPageStyle}[2]{%
  \IfLayerPageStyleExists{#1}{%
    \begingroup
      \edef\reserved@a{\GetRealPageStyle{#1}}%
      \@tempswafalse
      \ifstr{#2}{}{%
        \expandafter\ifx\csname @ps@\reserved@a @layers\endcsname\@empty
          \@tempswatrue
        \fi
      }{%
        \expandafter\ForEachLayerOfPageStyle\expandafter{%
          \reserved@a}{\ifstr{##1}{#2}{\aftergroup\@tempswatrue}{}}%
      }%
      \if@tempswa \aftergroup\@firstoftwo \else \aftergroup\@secondoftwo \fi
    \expandafter\endgroup
  }{%
    \scrlayer@lpm@error{#1}{testing for layers}%
    \expandafter\@gobbletwo
  }%
}
\newcommand*{\IfSomeLayersAtPageStyle}[2]{%
  \IfLayerPageStyleExists{#1}{%
    \begingroup
      \@tempswafalse
      \@for \reserved@a:=#2\do {%
        \edef\reserved@a{\noexpand\IfLayerAtPageStyle{#1}{\reserved@a}}%
        \reserved@a{\@tempswatrue}{}%
      }%
      \if@tempswa \aftergroup\@firstoftwo \else \aftergroup\@secondoftwo \fi
    \expandafter\endgroup
  }{%
    \scrlayer@lpm@error{#1}{testing for layers}%
    \expandafter\@gobbletwo
  }%
}
\newcommand*{\IfLayersAtPageStyle}[2]{%
  \IfLayerPageStyleExists{#1}{%
    \begingroup
      \@tempswatrue
      \ifstr{#2}{}{%
        \edef\reserved@a{\GetRealPageStyle{#1}}%
        \expandafter\ifx\csname @scr@\reserved@a @layers\endcsname\@empty \else
          \@tempswafalse
        \fi
      }{%
        \@for \reserved@a:=#2\do {%
          \edef\reserved@a{\noexpand\IfLayerAtPageStyle{#1}{\reserved@a}}%
          \reserved@a{}{\@tempswafalse}%
        }%
      }%
      \if@tempswa \aftergroup\@firstoftwo \else \aftergroup\@secondoftwo \fi
    \expandafter\endgroup
  }{%
    \scrlayer@lpm@error{#1}{testing for layers}%
    \expandafter\@gobbletwo
  }%
}
%</package&body>
%    \end{macrocode}
% \end{macro}^^A \IfLayersAtPageStyle
% \end{macro}^^A \IfSomeLayersAtPageStyle
% \end{macro}^^A \IfLayerAtPageStyle
%
%
% \begin{macro}{\DestroyRealLayerPageStyle}
%   \begin{description}
%   \item[\Parameter{string}:] name of the layer page style to be destroyed.
%   \end{description}
% Destroys the given layer page style but not the layers! If the page style is
% the current page style, the empty page style an empty page style will be
% activated. If the special page style is valid an the destroyed one, this
% will be removed. This command may be used, e.g., at
% \Macro{scrlayerOnAutoRemoveInterface} after destroying the layers.
%    \begin{macrocode}
%<*package&body>
\newcommand*{\DestroyRealLayerPageStyle}[1]{%
  \IfRealLayerPageStyleExists{#1}{%
    \expandafter\let\csname @ps@#1@initialhook\endcsname\relax
    \expandafter\let\csname @ps@#1@hook\endcsname\relax
    \expandafter\let\csname @ps@#1@backgroundhook\endcsname\relax
    \expandafter\let\csname @ps@#1@foregroundhook\endcsname\relax
    \expandafter\let\csname @ps@#1@oddpagehook\endcsname\relax
    \expandafter\let\csname @ps@#1@evenpagehook\endcsname\relax
    \expandafter\let\csname @ps@#1@onesidehook\endcsname\relax
    \expandafter\let\csname @ps@#1@twosidehook\endcsname\relax
    \expandafter\let\csname @ps@#1@floatpagehook\endcsname\relax
    \expandafter\let\csname @ps@#1@nonfloatpagehook\endcsname\relax
    \expandafter\let\csname @ps@#1@layers\endcsname\relax
    \expandafter\let\csname ps@#1\endcsname\relax
    \ifstr{\currentpagestyle}{#1}{%
      \def\currentpagestyle{scrlayer@empty}%
      \let\@oddhead\@empty\let\@evenhead\@empty
      \let\@oddfoot\@empty\let\@evenfoot\@empty
    }{}%
    \if@specialpage
      \ifstr{\@specialstyle}{#1}{%
        \global\let\@specialstyle\relax
        \global\@specialpagefalse
      }{}%
    \fi
  }{%
%<*trace>
    \PackageInfo{scrlayer}{%
      \string\DestroyRealLayerPageStyle{#1} ignored,\MessageBreak
      because the layer page style isn't\MessageBreak
      defined (any longer)%
    }%
%</trace>
  }%
}
%</package&body>
%    \end{macrocode}
% \end{macro}^^A \DestroyRealLayerPageStyle
%
%
% \subsection{Kernel Patches}
%
% This package as so many others need to patch the \LaTeX{} kernel. This will
% be done, because we need information about the current active package style.
%
% \begin{macro}{\pagestyle}
% \begin{macro}{\currentpagestyle}
% We save the current page style. Note, that this doesn't work for special
% page styles\footnote{Special page styles are set by
% \Macro{thispagestyle}.} that hasn't been defined using
% \Package{scrlayer}. As long as \Macro{currentpagestyle} is empty, the
% current page style is unknown. And we add two hooks into page style
% selection: one before an one after the selection.
%    \begin{macrocode}
%<*package&body>
\newcommand*{\currentpagestyle}{}
\PackageInfo{scrlayer}{patching LaTeX kernel macro \string\pagestyle}
\def\reserved@a{\scrlayer@exec@before@pagestyle@hook{##1}}
\expandafter\expandafter\expandafter\renewcommand
\expandafter\expandafter\expandafter*%
\expandafter\expandafter\expandafter\pagestyle
\expandafter\expandafter\expandafter[%
\expandafter\expandafter\expandafter1%
\expandafter\expandafter\expandafter]%
\expandafter\expandafter\expandafter{%
  \expandafter\reserved@a
  \pagestyle{#1}%
  \edef\currentpagestyle{\GetRealPageStyle{#1}}%
  \scrlayer@exec@after@pagestyle@hook{#1}%
}
\AtBeginDocument{%
  \begingroup
    \let\scrlayer@exec@before@pagestyle@hook\@gobble
    \let\scrlayer@exec@after@pagestyle@hook\@gobble
    \def\ps@test{}%
    \pagestyle{test}%
    \ifstr{\currentpagestyle}{test}{}{%
      \PackageError{scrlayer}{package incompatibility detected}{%
        Another package redefines \string\pagestyle\space incompatible with
        scrlayer.\MessageBreak
        This disables setting of \string\currentpagestyle\space and may
        be serious.\MessageBreak
        Maybe you could prevent this loading package scrlayer
        later.\MessageBreak
        If not you should either not use scrlayer or not the other
        package,\MessageBreak
        that redefines \string\pagestyle.%
      }%
    }%
  \endgroup
}
%</package&body>
%    \end{macrocode}
% \end{macro}^^A \currentpagestyle
%
% \begin{macro}{\BeforeSelectAnyPageStyle}
% \begin{macro}{\scrlayer@exec@before@pagestyle@hook}
% \begin{macro}{\AfterSelectAnyPageStyle}
% \begin{macro}{\scrlayer@exec@after@pagestyle@hook}
% We have two macros to locally add code to be executed whenever a page style
% changes using \Macro{pagestyle}. The first one executes the code before the
% page style will be changed, the second one after the page style has been
% changed. Note, that you may use \#1 as a placeholder of the argument of
% \Macro{pagestyle}.
%    \begin{macrocode}
%<*package&body>
\newcommand*{\BeforeSelectAnyPageStyle}[1]{%
  \expandafter\renewcommand\expandafter*%
  \expandafter\scrlayer@exec@before@pagestyle@hook
  \expandafter[\expandafter1\expandafter]\expandafter{%
    \scrlayer@exec@before@pagestyle@hook{##1}#1}%
}
\newcommand*{\scrlayer@exec@before@pagestyle@hook}[1]{}
\newcommand*{\AfterSelectAnyPageStyle}[1]{%
  \expandafter\renewcommand\expandafter*%
  \expandafter\scrlayer@exec@after@pagestyle@hook
  \expandafter[\expandafter1\expandafter]\expandafter{%
    \scrlayer@exec@after@pagestyle@hook{##1}#1}%
}
\newcommand*{\scrlayer@exec@after@pagestyle@hook}[1]{}
%</package&body>
%    \end{macrocode}
% \end{macro}^^A \scrlayer@exec@after@pagestyle@hook
% \end{macro}^^A \AfterSelectAnyPageStyle
% \end{macro}^^A \scrlayer@exec@before@pagestyle@hook
% \end{macro}^^A \BeforeSelectAnyPageStyle
% \end{macro}^^A \pagestyle
%
%
% \subsection{Declaration of End User Interfaces}
%
% The package also supports an interface for loading end user interfaces.
% Maybe it would be a good idea to move this to \Package{scrbase}, but
% currently it is not needed.
%
% \begin{macro}{\scrlayerAddToInterface}
% \begin{macro}{\scrlayerAddCsToInterface}
%   \begin{description}
%   \item[\texttt{\{\meta{command}\textbar\meta{command sequence}\}}:] the
%     command (with backslash) or the command sequence of the command (without
%     backslash) of the command, that should be added to the interface.
%   \item[\Parameter{code}:] will be executed, only if the command could be
%     added to the interface.
%   \end{description}
% Add either a command sequence or a command to the user interface.
%    \begin{macrocode}
%<*package&body>
\newcommand*{\scrlayerAddToInterface}[2][\@currname.\@currext]{%
  \begingroup
    \edef\reserve@a{%
      \noexpand\scrlayerAddCsToInterface[#1]{\expandafter\@gobble\string #2}%
    }%
  \expandafter\endgroup\reserve@a
}
\newcommand{\scrlayerAddCsToInterface}[3][\@currname.\@currext]{%
  \@ifundefined{scrlayer@#1@commandlist}{%
    \PackageError{scrlayer}{unkown interface `#1'}{%
      I've been told to add a command sequence to an interface, that hasn't
      been\MessageBreak
      defined yet. Please initialise every interface using
      \string\InitInterface\space before\MessageBreak
      trying to add command sequences to it.\MessageBreak
      If you'll continue, the command will be ignored.%
    }%
  }{%
    \@ifundefined{#2}{%
      \scrlayer@AddCsToInterface[#1]{#2}#3%
    }{%
      \@ifundefined{scrlayer@command@#2}{%
        \ifscrlayer@forceoverwrite
          \PackageWarning{scrlayer}{%
            Overloading `\@backslashchar#2'!\MessageBreak
            scrlayer detected, that the given command\MessageBreak
            has been defined already, when\MessageBreak
            `#1' tried to define it again.\MessageBreak
            Nevertheless, while scrlayer is in force overwrite\MessageBreak
            mode currently, the original definition will be\MessageBreak 
            removed%
          }%
          \expandafter\let\csname #2\endcsname\relax
          \scrlayer@AddCsToInterface[#1]{#2}#3%
        \else
          \PackageError{scrlayer}{cannot define `\@backslashchar#2'}{%
            scrlayer interface `#1' has tried to
            define command\MessageBreak
            `\@backslashchar#2', but this has already been defined\MessageBreak
            and is not part of another interface. So it cannot be
            defined.\MessageBreak
            Before continuing you should solve this conflict.\MessageBreak
            Nevertheless, you may use option `forceoverwrite' to get only a
            warning instead\MessageBreak
            of an error. But this wouldn't solve the problem at
            all!\MessageBreak
            This error is almost fatal, so you should abort the LaTeX
            run.%
          }%
        \fi
      }{%
        \ifscrlayer@autoremoveinterfaces
          \PackageInfo{scrlayer}{%
            already define interface command\MessageBreak
            `\@backslashchar#2' detected.\MessageBreak
            Command has been defined by interface\MessageBreak
            `\@nameuse{scrlayer@command@#2}'.\MessageBreak
            To continue installation of interface\MessageBreak
            `#1', interface\MessageBreak
            `\@nameuse{scrlayer@command@#2}' will\MessageBreak
            be removed%
          }%
          \@nameuse{scrlayer@\@nameuse{scrlayer@command@#2}@onremove}%
          \begingroup
            \def\@elt##1{%
              \aftergroup\let\aftergroup##1\aftergroup\relax
            }%
            \@nameuse{scrlayer@\@nameuse{scrlayer@command@#2}@commandlist}%
          \endgroup
          \expandafter\let\csname
          scrlayer@\@nameuse{scrlayer@command@#2}@commandlist\endcsname\relax
          \expandafter\let\csname
          scrlayer@\@nameuse{scrlayer@command@#2}@onremove\endcsname\relax
          \expandafter\let\csname #2\endcsname\relax
          \scrlayer@AddCsToInterface[#1]{#2}#3%
        \else
          \PackageError{scrlayer}{cannot define `\@backslashchar#2'}{%
            Interface command `\@backslashchar#2' has already
            been\MessageBreak
            defined by interface
            `\@nameuse{scrlayer@command@#2}'.\MessageBreak
            So it cannot be defined again.\MessageBreak
            You may try scrlayer option `autoremoveinterfaces' to
            automatically remove\MessageBreak
            older interfaces in such conflict situations.\MessageBreak
            For now, it's recommended so solve the problem before you'll
            continue.%
          }%
        \fi
      }%
    }%
  }%
}%
%    \end{macrocode}
% \begin{macro}{\scrlayer@AddCsToInterface}
% Little helper, to avoid repeating this \Macro{expandafter} orgy.
% \begin{description}
% \item[\OParameter{string}:] the interface name (must be expandable and
%   expand to a string)
% \item[\Parameter{command sequence}] the command sequence of the command to
%   be added.
% \end{description}
%    \begin{macrocode}
\newcommand*\scrlayer@AddCsToInterface[2][\@currname.\@currext]{%
  \expandafter\expandafter\expandafter\def\expandafter
  \csname scrlayer@#1@commandlist\expandafter\expandafter\expandafter\endcsname
  \expandafter\expandafter\expandafter{%
    \csname scrlayer@#1@commandlist\expandafter\endcsname
    \expandafter\@elt\csname #2\endcsname
  }%
  \@namedef{scrlayer@command@#2}{#1}%
}
%</package&body>
%    \end{macrocode}
% \begin{option}{forceoverwrite}
% \begin{macro}{\ifscrlayer@forceoverwrite}
%   \begin{description}
%   \item[\Parameter{simple switch}:] whether or not to overwrite already
%     defined command. Note: If true, there will still be a warning.
%   \end{description}
%    \begin{macrocode}
%<*options>
\KOMA@ifkey{forceoverwrite}{scrlayer@forceoverwrite}
%<*interface>
\scrlayer@AddCsToInterface{KV@KOMA.\@currname.\@currext @forceoverwrite}
\scrlayer@AddCsToInterface{KV@KOMA.\@currname.\@currext @forceoverwrite@default}
%</interface>
%</options>
%    \end{macrocode}
% \end{macro}^^A \ifscrlayer@forceoverwrite
% \end{option}^^A forceoverwrite
%
% \begin{option}{autoremoveinterfaces}
% \begin{macro}{\ifscrlayer@autoremoveinterfaces}
%   \begin{description}
%   \item[\Parameter{simple switch}:] whether or not older interfaces may be
%     automatically removed in conflict cases.
%   \end{description}
%    \begin{macrocode}
%<*options>
\KOMA@ifkey{autoremoveinterfaces}{scrlayer@autoremoveinterfaces}
%<*interface>
\scrlayer@AddCsToInterface{KV@KOMA.\@currname.\@currext @autoremoveinterfaces}
\scrlayer@AddCsToInterface{%
  KV@KOMA.\@currname.\@currext @autoremoveinterfaces@default}
%</interface>
%</options>
%    \end{macrocode}
% \end{macro}^^A \ifscrlayer@autoremoveinterfaces
% \end{option}^^A autoremoveinterfaces
% \end{macro}^^A \scrlayer@AddCsToInterface
% \end{macro}^^A \scrlayerAddCsToInterface
% \end{macro}^^A \scrlayerAddToInterface
%
% \begin{macro}{\scrlayerInitInterface}
%   \begin{description}
%   \item[\OParameter{string}:] the name of the interface. Generally this is
%     the file name of the package or class, that defines the interface
%     (default: \texttt{\Macro{@currname}.\Macro{@currext}}).
%   \end{description}
% This registers a new user interface.
%    \begin{macrocode}
%<*package&body>
\newcommand*{\scrlayerInitInterface}[1][\@currname.\@currext]{%
  \@ifundefined{scrlayer@#1@commandlist}{%
    \@namedef{scrlayer@#1@commandlist}{}%
  }{%
    \begingroup
      \def\@elt##1{\space\space\string##1\MessageBreak}%
      \PackageError{scrlayer}{interface `#1' already initialised}{%
        You've tried to initialise scrlayer interface `#1',\MessageBreak
        but an interface of this name has been initialised
        already.\MessageBreak
        Here's a list of all macros of the already initialised
        interface:\MessageBreak
        \@nameuse{scrlayer@#1@commandlist}.%
        If you'll continue, this re-initialisation will be ignored.%
      }%
    \endgroup
  }%
}
%</package&body>
%    \end{macrocode}
% The initialisation has to be done by each interface package:
%    \begin{macrocode}
%<interface&init>\scrlayerInitInterface
%    \end{macrocode}
% \end{macro}^^A \scrlayerInitInterface
%
% \begin{macro}{\scrlayerOnAutoRemoveInterface}
%   \begin{description}
%   \item[\OParameter{string}:] the name of the interface. Generally this is
%     the file name of the package or class, that defines the interface
%     (default: \texttt{\Macro{@currname}.\Macro{@currext}}).
%   \item[\Parameter{code}:] will be executed if the interface will be removed
%     automatically (see option \Option{autoremoveinterfaces}).
%   \end{description}
%    \begin{macrocode}
%<*package&body>
\newcommand*{\scrlayerOnAutoRemoveInterface}[2][\@currname.\@currext]{%
  \@ifundefined{scrlayer@#1@onremove}{\@namedef{scrlayer@#1@onremove}{}}{}%
  \expandafter\l@addto@macro\csname scrlayer@#1@onremove\endcsname{#2}%
}
%</package&body>
%    \end{macrocode}
% \end{macro}^^A \scrlayerOnAutoRemoveInterface
%
%
% \iffalse^^A meta-comment
%</package|interface>
% \fi^^A meta-comment
%
%
% \Finale
%
\endinput
%
% end of file `scrlayer.dtx'

%%% Local Variables:
%%% mode: doctex
%%% mode: flyspell
%%% ispell-local-dictionary: "en_GB"
%%% TeX-master: t
%%% End:
