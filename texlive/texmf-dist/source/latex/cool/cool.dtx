% \iffalse
%
%<package>\NeedsTeXFormat{LaTeX2e}[1999/12/01]
%<package>\ProvidesPackage{cool}
%<package> [2006/12/29 v1.35 COntent Oriented LaTeX]
%<package>\RequirePackage{ifthen}
%<package>\RequirePackage{coollist}
%<package>\RequirePackage{coolstr}
%<package>\RequirePackage{forloop}
%<package>\RequirePackage{amsmath}
%<package>\RequirePackage{amssymb}
%<package>\RequirePackage{bbm}
%
%
%<*driver>
\documentclass{ltxdoc}
\usepackage{cool}
\usepackage[bbgreekl]{mathbbol}
\usepackage{url}
\EnableCrossrefs
\CodelineIndex
\RecordChanges
\begin{document}
\DocInput{cool.dtx}
\end{document}
%</driver>
% \fi
%
% \CheckSum{3591}
%
%% \CharacterTable
%%  {Upper-case    \A\B\C\D\E\F\G\H\I\J\K\L\M\N\O\P\Q\R\S\T\U\V\W\X\Y\Z
%%   Lower-case    \a\b\c\d\e\f\g\h\i\j\k\l\m\n\o\p\q\r\s\t\u\v\w\x\y\z
%%   Digits        \0\1\2\3\4\5\6\7\8\9
%%   Exclamation   \!     Double quote  \"     Hash (number) \#
%%   Dollar        \$     Percent       \%     Ampersand     \&
%%   Acute accent  \'     Left paren    \(     Right paren   \)
%%   Asterisk      \*     Plus          \+     Comma         \,
%%   Minus         \-     Point         \.     Solidus       \/
%%   Colon         \:     Semicolon     \;     Less than     \<
%%   Equals        \=     Greater than  \>     Question mark \?
%%   Commercial at \@     Left bracket  \[     Backslash     \\
%%   Right bracket \]     Circumflex    \^     Underscore    \_
%%   Grave accent  \`     Left brace    \{     Vertical bar  \|
%%   Right brace   \}     Tilde         \~}
%
% \changes{v0}{2005/07/20}{pre-Initial version [tenative edition]}
% \changes{v1.0}{2005/08/27}{Initial Release}
% \changes{v1.1}{2006/03/19}{Added listlenstore to package to allow storing of the list length}
% \changes{v1.2}{2006/09/17}{Split off the list, string, and forloop parts to separate packages}
% \changes{v1.3}{2006/10/07}{Redefined the {\tt in*} commands to have a {\tt mathopen} before the {\tt left}.  Added {\tt IntegrateDifferentialDSymb} and {\tt DSymb} options for {\tt Integrate} and {\tt D}.  Added {\tt IdentityMatrixSymb} for {\tt IdentityMatrix} and changed the default to display a double-struck $1$.  Added {\tt ESymb}, {\tt ISymb}, {\tt PISymb}, and {\tt EulerGammaSymb} for fundamental constants}
% \changes{v1.35}{2006/12/29}{Adjusted package to be compatible with new \textsf{coolstr}}
%
% \GetFileInfo{cool.sty}
%
% \DoNotIndex{\#,\$,\%,\&,\@,\\,\{,\},\^,\_,\~,\ ,\!,\(,\),\,}
% \DoNotIndex{\@ne,\expandafter}
% \DoNotIndex{\advance,\begingroup,\catcode,\closein}
% \DoNotIndex{\newcommand,\renewcommand,\providecommand}
% \DoNotIndex{\closeout,\day,\def,\edef,\gdef,\let,\empty,\endgroup}
% \DoNotIndex{\newcounter,\providecounter,\addtocounter,\setcounter,\stepcounter,\value,\arabic}
% \DoNotIndex{\if,\fi,\ifthenelse,\else,\setboolean,\boolean,\newboolean,\provideboolean,\equal,\AND,\OR,\NOT,\whiledo}
% \DoNotIndex{\ifcase,\ifcat,\or,\else}
% \DoNotIndex{\par,\parbox,\mbox,\hbox,\begin,\end,\nabla,\partial}
% \DoNotIndex{\overline,\bar,\small,\tiny,\mathchoice,\scriptsize,\textrm,\texttt}
% \DoNotIndex{\alpha,\beta,\gamma,\epsilon,\varepsilon,\delta,\zeta,\eta,\theta,\vartheta,\iota,\kappa,\lambda,\mu,\nu}
% \DoNotIndex{\xi,\omicron,\pi,\varpi,\rho,\varrho,\sigma,\tau,\upsilon,\phi,\varphi,\chi,\psi,\omega}
% \DoNotIndex{\Delta,\Gamma,\Theta,\Lambda,\Xi,\Pi,\Sigma,\Phi,\Psi,\Omega}
% \DoNotIndex{\digamma,\lceil,\rceil,\lfloor,\rfloor,\left,\right,\inp,\inb,\inbr,\inap,\nop}
% \DoNotIndex{\sum,\prod,\int,\log,\ln,\exp,\sin,\cos,\tan,\csc,\sec,\cot,\arcsin,\arccos,\arctan,\det}
% \DoNotIndex{\sinh,\cosh,\tanh,\csch,\sech,\coth,\arcsinh,\arccosh,\arctanh}
% \DoNotIndex{\mod,\max,\min,\gcd,\lcm,\wp,\arg,\dots,\infty,}
% \DoNotIndex{\frac,\binom,\braket,\@@atop}
% \DoNotIndex{\cdot,\ldots,\tilde,\times,\dagger,\relax}
% \DoNotIndex{\mathbb,\roman,\bf,\mathord,\cal,\DeclareMathOperator,\PackageError,\PackageWarning}
% \DoNotIndex{\csname,\endcsname,\ifx,\ifnum}
% \DoNotIndex{\COOL@Hypergeometric@pq,\COOL@Hypergeometric@pq@ab@value,\hideOnSF,\COOL@decide@paren}
% \DoNotIndex{\COOL@decide@indicies}
% \DoNotIndex{\mod,\bmod,\pmod,\pod,\operatorname}
% \DoNotIndex{\forLoop}
% \DoNotIndex{
% \COOL@notation@AiryAiParen,
% \COOL@notation@AiryBiParen,
% \COOL@notation@AppellFOneParen,
% \COOL@notation@ArcCoshParen,
% \COOL@notation@ArcCosParen,
% \COOL@notation@ArcCothParen,
% \COOL@notation@ArcCotParen,
% \COOL@notation@ArcCschParen,
% \COOL@notation@ArcCscParen,
% \COOL@notation@ArcSechParen,
% \COOL@notation@ArcSecParen,
% \COOL@notation@ArcSinhParen,
% \COOL@notation@ArcSinParen,
% \COOL@notation@ArcTanhParen,
% \COOL@notation@ArcTanParen,
% \COOL@notation@ArithGeoMeanParen,
% \COOL@notation@AssocLegendrePParen,
% \COOL@notation@AssocLegendreQParen,
% \COOL@notation@BernoulliParen,
% \COOL@notation@BernoulliBParen,
% \COOL@notation@BesselIParen,
% \COOL@notation@BesselJParen,
% \COOL@notation@BesselKParen,
% \COOL@notation@BesselYParen,
% \COOL@notation@BetaParen,
% \COOL@notation@BetaRegularizedParen,
% \COOL@notation@CarmichaelLambdaParen,
% \COOL@notation@ChebyshevTParen,
% \COOL@notation@ChebyshevUParen,
% \COOL@notation@ConjugateParen,
% \COOL@notation@CoshIntParen,
% \COOL@notation@CoshParen,
% \COOL@notation@CosIntParen,
% \COOL@notation@CosParen,
% \COOL@notation@CothParen,
% \COOL@notation@CotParen,
% \COOL@notation@CschParen,
% \COOL@notation@CscParen,
% \COOL@notation@CyclotomicCParen,
% \COOL@notation@DaggerParen,
% \COOL@notation@DedekindEtaParen,
% \COOL@notation@DetParen,
% \COOL@notation@DiGammaParen,
% \COOL@notation@DiracDeltaParen,
% \COOL@notation@DivisorsParen,
% \COOL@notation@DivisorSigmaParen,
% \COOL@notation@DiscreteDeltaParen,
% \COOL@notation@EllipticEParen,
% \COOL@notation@EllipticExpParen,
% \COOL@notation@EllipticFParen,
% \COOL@notation@EllipticKParen,
% \COOL@notation@EllipticLogParen,
% \COOL@notation@EllipticNomeQInvParen,
% \COOL@notation@EllipticNomeQParen,
% \COOL@notation@EllipticPiParen,
% \COOL@notation@EllipticThetaParen,
% \COOL@notation@ErfcInvParen,
% \COOL@notation@ErfcParen,
% \COOL@notation@ErfInvParen,
% \COOL@notation@ErfiParen,
% \COOL@notation@ErfParen,
% \COOL@notation@EulerParen,
% \COOL@notation@EulerEParen,
% \COOL@notation@EulerPhiParen,
% \COOL@notation@ExpIntEiParen,
% \COOL@notation@ExpIntEParen,
% \COOL@notation@ExpParen,
% \COOL@notation@ExtendedGCDParen,
% \COOL@notation@FactorIntegerParen,
% \COOL@notation@FibonacciParen,
% \COOL@notation@FibonacciFParen,
% \COOL@notation@FractionalPartParen,
% \COOL@notation@FresnelCParen,
% \COOL@notation@FresnelSParen,
% \COOL@notation@GammaFuncParen,
% \COOL@notation@GammaRegularizedParen,
% \COOL@notation@GCDParen,
% \COOL@notation@GegenbauerCParen,
% \COOL@notation@HeavisideStepParen,
% \COOL@notation@HermiteHParen,
% \COOL@notation@HypergeometricParen,
% \COOL@notation@IdentityMatrixParen,
% \COOL@notation@ImagParen,
% \COOL@notation@IntegerPartParen,
% \COOL@notation@InverseBetaRegularizedParen,
% \COOL@notation@InverseGammaRegularizedParen,
% \COOL@notation@JacobiAmplitudeParen,
% \COOL@notation@JacobiCDInvParen,
% \COOL@notation@JacobiCDParen,
% \COOL@notation@JacobiCNInvParen,
% \COOL@notation@JacobiCNParen,
% \COOL@notation@JacobiCSInvParen,
% \COOL@notation@JacobiCSParen,
% \COOL@notation@JacobiDCInvParen,
% \COOL@notation@JacobiDCParen,
% \COOL@notation@JacobiDNInvParen,
% \COOL@notation@JacobiDNParen,
% \COOL@notation@JacobiDSInvParen,
% \COOL@notation@JacobiDSParen,
% \COOL@notation@JacobiNCInvParen,
% \COOL@notation@JacobiNCParen,
% \COOL@notation@JacobiNDInvParen,
% \COOL@notation@JacobiNDParen,
% \COOL@notation@JacobiNSInvParen,
% \COOL@notation@JacobiNSParen,
% \COOL@notation@JacobiPParen,
% \COOL@notation@JacobiSCInvParen,
% \COOL@notation@JacobiSCParen,
% \COOL@notation@JacobiSDInvParen,
% \COOL@notation@JacobiSDParen,
% \COOL@notation@JacobiSNInvParen,
% \COOL@notation@JacobiSNParen,
% \COOL@notation@JacobiZetaParen,
% \COOL@notation@KleinInvariantJParen,
% \COOL@notation@LaugerreLParen,
% \COOL@notation@LCMParen,
% \COOL@notation@LegendrePParen,
% \COOL@notation@LegendreQParen,
% \COOL@notation@LerchPhiParen,
% \COOL@notation@LogGammaParen,
% \COOL@notation@LogIntParen,
% \COOL@notation@LogParen,
% \COOL@notation@MathieuCharacteristicAParen,
% \COOL@notation@MathieuCharacteristicBParen,
% \COOL@notation@MathieuCharacteristicExponentParen,
% \COOL@notation@MathieuSParen,
% \COOL@notation@MathieuCParen,
% \COOL@notation@MoebiusMuParen,
% \COOL@notation@MaxParen,
% \COOL@notation@MinParen,
% \COOL@notation@ModularLambdaParen,
% \COOL@notation@NevilleThetaCParen,
% \COOL@notation@NevilleThetaDParen,
% \COOL@notation@NevilleThetaNParen,
% \COOL@notation@NevilleThetaSParen,
% \COOL@notation@NielsenPolyLogParen,
% \COOL@notation@PartitionsPParen,
% \COOL@notation@PartitionsQParen,
% \COOL@notation@PolyGammaParen,
% \COOL@notation@PolyLogParen,
% \COOL@notation@PrimeParen,
% \COOL@notation@PrimePiParen,
% \COOL@notation@ProductLogParen,
% \COOL@notation@QuotientParen,
% \COOL@notation@RealParen,
% \COOL@notation@RegHypergeometricParen,
% \COOL@notation@RiemannSiegelThetaParen,
% \COOL@notation@RiemannSiegelZParen,
% \COOL@notation@SechParen,
% \COOL@notation@SecParen,
% \COOL@notation@SignParen,
% \COOL@notation@SinhIntParen,
% \COOL@notation@SinhParen,
% \COOL@notation@SinIntParen,
% \COOL@notation@SinParen,
% \COOL@notation@SphericalHarmonicYParen,
% \COOL@notation@StruveHParen,
% \COOL@notation@StruveLParen,
% \COOL@notation@TanhParen,
% \COOL@notation@TanParen,
% \COOL@notation@TransposeParen,
% \COOL@notation@TrParen,
% \COOL@notation@WeierstrassPInvParen,
% \COOL@notation@WeierstrassPParen,
% \COOL@notation@WeierstrassZetaParen,
% \COOL@notation@ZetaParen}
% \DoNotIndex{\COOL@notation@KroneckerDeltaIndicies,\COOL@notation@LeviCivitaIndicies}
% \DoNotIndex{\COOL@notation@SphericalHarmonicParen,\COOL@notation@SphericalHarmonicSymb}
% \DoNotIndex{\COOL@notation@WeierstrassPHalfPeriodValuesDisplay,\COOL@notation@WeierstrassZetaHalfPeriodValuesDisplay}
% \DoNotIndex{
% \COOL@Beta@arg@i,
% \COOL@Beta@arg@ii,
% \COOL@Beta@arg@iii,
% \COOL@Beta@arg@iv,
% \COOL@BetaRegularized@arg@i,
% \COOL@BetaRegularized@arg@ii,
% \COOL@BetaRegularized@arg@iii,
% \COOL@BetaRegularized@arg@iv,
% \COOL@EllipticE@arg@i,
% \COOL@EllipticE@arg@ii,
% \COOL@EllipticF@arg@i,
% \COOL@EllipticF@arg@ii,
% \COOL@EllipticPi@arg@i,
% \COOL@EllipticPi@arg@ii,
% \COOL@EllipticPi@arg@iii,
% \COOL@Euler@arg@i,
% \COOL@Euler@arg@ii,
% \COOL@Fibonacci@arg@i,
% \COOL@Fibonacci@arg@ii,
% \COOL@InverseBetaRegularized@arg@i,
% \COOL@InverseBetaRegularized@arg@ii,
% \COOL@InverseBetaRegularized@arg@iii,
% \COOL@InverseBetaRegularized@arg@iv,
% \COOL@LegendreP@arg@i,
% \COOL@LegendreP@arg@ii,
% \COOL@LegendreP@arg@iii,
% \COOL@LegendreP@arg@iv,
% \COOL@LegendreQ@arg@i,
% \COOL@LegendreQ@arg@ii,
% \COOL@LegendreQ@arg@iii,
% \COOL@LegendreQ@arg@iv,
% \COOL@PolyLog@arg@i,
% \COOL@PolyLog@arg@ii,
% \COOL@PolyLog@arg@iii,
% \COOL@WeiSigma@arg@z@i,
% \COOL@WeiSigma@arg@z@ii,
% \COOL@Zeta@arg@i,
% \COOL@Zeta@arg@ii}
% \DoNotIndex{
% \COOL@notation@AssocLegendrePSymb,
% \COOL@notation@AssocLegendreQSymb,
% \COOL@notation@BesselISymb,
% \COOL@notation@BesselJSymb,
% \COOL@notation@BesselKSymb,
% \COOL@notation@BesselYSymb,
% \COOL@notation@ChebyshevTSymb,
% \COOL@notation@ChebyshevUSymb,
% \COOL@notation@EllipticESymb,
% \COOL@notation@EllipticFSymb,
% \COOL@notation@EllipticKSymb,
% \COOL@notation@EllipticPiSymb,
% \COOL@notation@GegenbauerCSymb,
% \COOL@notation@HermiteHSymb,
% \COOL@notation@HypergeometricSymb,
% \COOL@notation@HypergeometricUSymb,
% \COOL@notation@JacobiPSymb,
% \COOL@notation@JacobiZetaSymb,
% \COOL@notation@LaugerreLSymb,
% \COOL@notation@LegendrePSymb,
% \COOL@notation@LegendreQSymb,
% \COOL@notation@LogBaseESymb,
% \COOL@notation@MeijerGSymb,
% \COOL@notation@RegHypergeometricSymb,
% \COOL@notation@SphericalHarmonicYSymb}
% \DoNotIndex{\COOL@wrt@temp,\COOL@temp@D@top@power,\COOL@temp@D@top,\COOL@temp@D@result,\COOL@temp@D@bot}
% \DoNotIndex{\COOL@power@temp}
% \DoNotIndex{\listval,\liststore,\isint,\isnumeric}
% \DoNotIndex{
% \COOL@list@temp@i,
% \COOL@list@temp@ii,
% \COOL@list@temp@iii}
% \DoNotIndex{
% \COOL@MeijerG@sniffer,
% \COOL@MeijerG@sniffer@end}
% \DoNotIndex{\COOL@Multinomial@tempa}
% \DoNotIndex{
% \COOL@notation@ArcTrig,
% \COOL@notation@Conjugate,
% \COOL@notation@DShorten,
% \COOL@notation@LogShowBase}
% \DoNotIndex{
% \COOL@notation@DDisplayFunc,
% \COOL@notation@DetDisplay,
% \COOL@notation@IntegrateDisplayFunc,
% \COOL@notation@ModDisplay}
% \DoNotIndex{
% \COOL@notation@KroneckerDeltaUseComma,
% \COOL@notation@LeviCivitaUseComma}
%
% \title{The \textsf{cool} package\thanks{This document
% corresponds to \textsf{cool}~\fileversion,
% dated~\filedate.}}
% \author{nsetzer}
%
% \maketitle
%
% \setcounter{IndexColumns}{2}
% \StopEventually{\PrintChanges\PrintIndex}
%
%
% This is the \textsf{cool} package: a COntent Oriented \LaTeX{} package.  That is, it is designed to give \LaTeX{} 
% commands the ability to contain the mathematical meaning while retaining the typesetting versatility.
%
% Please note that there are examples of use of each of the defined commands at the location where they are defined.
%
% This package requires the following, non-standard \LaTeX{} packages (all of which are available on \url{www.ctan.org}):
% \textsf{coolstr},
% \textsf{coollist},
% \textsf{forloop}
%
%
%
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\section{Implementation}
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%    \begin{macrocode}
\newcounter{COOL@ct} %just a general counter
\newcounter{COOL@ct@}%just a general counter
%    \end{macrocode}
%
%
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %
%\subsection{Parenthesis}
% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%    \begin{macrocode}
\newcommand{\inp}[2][0cm]{\mathopen{}\left(#2\parbox[h][#1]{0cm}{}\right)}
        % in parentheses ()
\newcommand{\inb}[2][0cm]{\mathopen{}\left[#2\parbox[h][#1]{0cm}{}\right]}
        % in brackets []
\newcommand{\inbr}[2][0cm]{\mathopen{}\left\{#2\parbox[h][#1]{0cm}{}\right\}}
	% in braces {}
\newcommand{\inap}[2][0cm]{\mathopen{}\left<{#2}\parbox[h][#1]{0cm}{}\right>}
	% in angular parentheses <>
\newcommand{\nop}[1]{\mathopen{}\left.{#1}\right.}
	% no parentheses
%    \end{macrocode}
%
%
% \begin{macro}{\COOL@decide@paren}
% |\COOL@decide@paren[|\meta{parenthesis type}|]{|\meta{function name}|}{|\meta{contained text}|}|.
%
% \noindent Since the handling of parentheses is something that will be common to many elements this 
% function will take care of it.  
%
% If the optional argument is given, |\COOL@notation@|\meta{function name}|Paren| is ignored and 
% \meta{parenthesis type} is used
%
% \meta{parenthesis type} and |\COOL@notation@|\meta{function name}|Paren| must be one of |none|, |p| for |()|, |b| for |[]|, |br| for |{}|, |ap| for \meta{}, |inv| for |\left.\right.|
%    \begin{macrocode}
\let\COOL@decide@paren@no@type=\relax
\newcommand{\COOL@decide@paren}[3][\COOL@decide@paren@no@type]{%
\ifthenelse{ \equal{#1}{\COOL@decide@paren@no@type} }%
	{%
	\def\COOL@decide@paren@type{\csname COOL@notation@#2Paren\endcsname}%
	}%
% Else
	{%
	\def\COOL@decide@paren@type{#1}%
	}%
\ifthenelse{ \equal{\COOL@decide@paren@type}{none} }%
	{%
	#3%
	}%
% Else
	{%
	\ifthenelse{ \equal{\COOL@decide@paren@type}{p} }%
		{%
		\inp{#3}%
		}%
	% Else
		{%
		\ifthenelse{ \equal{\COOL@decide@paren@type}{b} }%
			{%
			\inb{#3}%
			}%
		% Else
			{%
			\ifthenelse{ \equal{\COOL@decide@paren@type}{br} }%
				{%
				\inbr{#3}%
				}%
			% Else
				{%
				\ifthenelse{ \equal{\COOL@decide@paren@type}{ap} }%
					{%
					\inap{#3}%
					}%
				% Else
					{%
					\ifthenelse{ \equal{\COOL@decide@paren@type}{inv} }%
						{%
						\nop{#3}%
						}%
					% Else
						{%
						\PackageError{cool}{Invalid Parenthesis Option}%
							{*Paren can only be `none', `p', `b', `br', `ap', `inv'}%
						}%
					}%
				}%
			}%
		}%
	}%
}
%    \end{macrocode}
% \end{macro}
%
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %
%\subsection{Indicies}
% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% \begin{macro}{\COOL@decide@indicies}
% |\COOL@decide@indicies|\marg{function name}\marg{local indication}\marg{indicies}
%
% \noindent Since up or down indicies can be as common as the parenthesis decision, this macro is the solution.
%
% \meta{local indication} must be either |u| or |d| 
%
% \meta{indicies} is very likely to be required to be a comma separated list in the near future
%
% the options for indicies are
%
% \begin{tabular}{ll}
% |local| 	& allow the indicies to be decided by an optional argument to  		\\
%		& the function (such as |\LeviCivita[u]{i j}|)				\\
% |up|		& force the indicies to appear as superscript				\\
% |down|	& force the indicies to appear as subscript				\\
% \end{tabular}
%
%    \begin{macrocode}
\newcommand{\COOL@decide@indicies}[3]{%
\def\COOL@decide@indicies@placement%
	{\csname COOL@notation@#1Indicies\endcsname}%
\ifthenelse{\equal{\COOL@decide@indicies@placement}{local}}%
	{%
	\ifthenelse{\equal{#2}{u}}%
		{^{#3}}%
		{_{#3}}%
	}%
% Else
	{%
	\ifthenelse{\equal{\COOL@decide@indicies@placement}{up}}%
		{%
		{^{#3}}%
		}%
	% Else
		{%
		\ifthenelse{\equal{\COOL@decide@indicies@placement}{down}}%
			{%
			{_{#3}}%
			}%
		% else
			{%
			\PackageError{cool}{Invalid Option Sent}%
				{#1Indices can only be 'up', 'down', or 'local'}%
			}%
		}%
	}%
}
%    \end{macrocode}
% \end{macro}
%
%
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %
%\subsection{COntent Oriented LaTeX (COOL)}
% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% \begin{macro}{\Style}
% |\Style{|\meta{options}|}| sets the style of the output (how to notate particular functions).
% \meta{options} is a comma delimited list of the form \meta{key}|=|\meta{value}, where \meta{key} is the \emph{long}
% form of the command name without the preceeding backslash (i.e. |Integrate| and not |Int| or |\Int|).
% The list can be in any order and need only contain the styles that the user desires to set.
%
% There can be multiple |\Style| commands within any document---the styled output of the command depends on the
% last |\Style| command to have specified its style.
%
% For a list of styling options for a command, see the code where the command is defined
%
%    \begin{macrocode}
\newcommand{\Style}[1]{%
\COOL@keyeater#1,\COOL@keystop\COOL@keyend%
}
\newcommand{\COOL@keystop}{@@@}%
\def\COOL@keyeater#1=#2,#3\COOL@keyend{%
\ifx#3\COOL@keystop%
	\expandafter\gdef\csname COOL@notation@#1\endcsname{#2}%
\else%
	\expandafter\gdef\csname COOL@notation@#1\endcsname{#2}%
	\COOL@keyeater#3\COOL@keyend%
\fi%
}
%    \end{macrocode}
% \end{macro}
%
%
%
% \begin{macro}{\UseStyleFile}
% Since notational style should be kept consistent and will likely need to span several documents, use this command
% to input a notation style file that has previously been prepared. (to be implemented in a future release)
%    \begin{macrocode}
\newcommand{\UseStyleFile}[1]{}
%    \end{macrocode}
% \end{macro}
%
%
%
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% %  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %
% \subsubsection{Fundamental Constants}
% %  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% see \url{http://functions.wolfram.com/} for the definitions
% \begin{macro}{\I}
% The square root of minus 1, $\I = \sqrt{-1}$. 
%
% |\Style{ISymb=\mathbbm{i}}| \Style{ISymb=\mathbbm{i}}, |\I| gives $\I$. \Style{ISymb=i}
%    \begin{macrocode}
	\newcommand{\COOL@notation@ISymb}{i}
\newcommand{\I}{\COOL@notation@ISymb}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\E}
% Euler's constant and the base of the natural logarithm, $\E$. 
%
%|\Style{ESymb=\mathbbm{e}}| \Style{ESymb=\mathbbm{e}}, |\E| gives $\E$. \Style{ESymb=e}
%    \begin{macrocode}
	\newcommand{\COOL@notation@ESymb}{e}
\newcommand{\E}{\COOL@notation@ESymb}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\PI}
% Pi---the ratio of the circumference of a circle to its diameter, $\PI$. 
%
% |\Style{PISymb=\bbpi}| \footnote{to get the `bbpi' symbol , you will need to use the package \textsf{mathbbol} and pass the \textsf{bbgreekl} option} \Style{PISymb=\bbpi}, |\PI| gives $\PI$. \Style{PISymb=\pi}
%    \begin{macrocode}
	\newcommand{\COOL@notation@PISymb}{\pi}
\newcommand{\PI}{\COOL@notation@PISymb}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\GoldenRatio}
% The Golden Ratio, $\GoldenRatio$
%    \begin{macrocode}
\newcommand{\GoldenRatio}{\varphi}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\EulerGamma}
% Euler's Gamma constant, $\EulerGamma$. 
%
%|\Style{EulerGammaSymb=\gamma_E}| \Style{EulerGammaSymb=\gamma_E}, |\EulerGamma| gives $\EulerGamma$ \Style{EulerGammaSymb=\gamma}
%    \begin{macrocode}
	\newcommand{\COOL@notation@EulerGammaSymb}{\gamma}
\newcommand{\EulerGamma}{\COOL@notation@EulerGammaSymb}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\Catalan}
% Catalan constant, $\Catalan$
%    \begin{macrocode}
\newcommand{\Catalan}{C}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\Glaisher}
% Glaisher constant, $\Glaisher$
%    \begin{macrocode}
\newcommand{\Glaisher}{\mathord{\operatorname{Glaisher}}}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\Khinchin}
% Khinchin constant, $\Khinchin$
%    \begin{macrocode}
\newcommand{\Khinchin}{\mathord{\operatorname{Khinchin}}}
%    \end{macrocode}
% \end{macro}
%
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% %  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %
% \subsubsection{Symbols}
% %  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% \begin{macro}{\Infinity}
% Infinity, $\Infinity$
%    \begin{macrocode}
\newcommand{\Infinity}{\infty}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\Indeterminant}
% An indeterminant quantity
%    \begin{macrocode}
\newcommand{\Indeterminant}{%
	\mathchoice%
		{\mbox{\textrm>}}%
		{\mbox{\small>}}%
		{\mbox{\scriptsize>}}%
		{\mbox{\tiny>}}%
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\DirectedInfinity}
% \begin{macro}{\DirInfty}
% Directed Infinity |\DirectedInfinity{|\meta{complex number}|}| or |\DirInfty{|\meta{complex number}|}|
%    \begin{macrocode}
\newcommand{\DirectedInfinity}[1]{#1 \, \infty}
\newcommand{\DirInfty}[1]{\DirectedInfinity{#1}}
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\ComplexInfinity}
% \begin{macro}{\CInfty}
% Complex infinity, $\CInfty$
%    \begin{macrocode}
\newcommand{\ComplexInfinity}{\tilde{\infty}}
\newcommand{\CInfty}{\ComplexInfinity}
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% %  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %
% \subsubsection{Exponential Functions}
% %  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% \begin{macro}{\Exp}
% Exponential---for use when $\E^x$ won't suffice, $\Exp{x}$
%    \begin{macrocode}
	\newcommand{\COOL@notation@ExpParen}{p}
\newcommand{\Exp}[1]
{%
\exp\COOL@decide@paren{Exp}{#1}%
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\Log}
% Logarithm, |\Log{x}|.  This function has several options to be set.  The usual parentheses, then some
% about the notation to be used for displaying the symbol.
%    \begin{macrocode}
	\newcommand{\COOL@notation@LogParen}{none}
%    \end{macrocode}
% The following set the symbols:
%
% |LogBaseESymb| can be |ln| or |log|, indicating what symbol should be used for the natural logarithm.  If set to
% |log| then logarithms of base 10 are displayed as $\log_{10}$.
%
% |LogShowBase| can be either |at will| or |always| and decides whether or not one should show the base, as in
% |log_b x|.  If this option is set to |always| then |LogBaseESymb| is ignored.
%
% \begin{tabular}{lll}
% |\Log{5}|				& $\Log{5}$		& $\displaystyle \Log{5}$		\\
% |\Log[10]{5}| 			& $\Log[10]{5}$		& $\displaystyle \Log[10]{5}$		\\
% |\Log[4]{5}|				& $\Log[4]{5}$		& $\displaystyle \Log[4]{5}$		\\
% |\Style{LogBaseESymb=log}|%
% \Style{LogBaseESymb=log}										\\
% |\Log{5}|				& $\Log{5}$		& $\displaystyle \Log{5}$		\\
% |\Log[10]{5}| 			& $\Log[10]{5}$		& $\displaystyle \Log[10]{5}$		\\
% |\Log[4]{5}|				& $\Log[4]{5}$		& $\displaystyle \Log[4]{5}$		\\
% |\Style{LogShowBase=always}|%
% \Style{LogBaseESymb=ln}%
% \Style{LogShowBase=always}										\\
% |\Log{5}|				& $\Log{5}$		& $\displaystyle \Log{5}$		\\
% |\Log[10]{5}| 			& $\Log[10]{5}$		& $\displaystyle \Log[10]{5}$		\\
% |\Log[4]{5}|				& $\Log[4]{5}$		& $\displaystyle \Log[4]{5}$		\\
% |\Style{LogShowBase=at will}|%
% \Style{LogShowBase=at will}										\\
% |\Log{5}|				& $\Log{5}$		& $\displaystyle \Log{5}$		\\
% |\Log[10]{5}| 			& $\Log[10]{5}$		& $\displaystyle \Log[10]{5}$		\\
% |\Log[4]{5}|				& $\Log[4]{5}$		& $\displaystyle \Log[4]{5}$		\\
% |\Style{LogParen=p}|%
% \Style{LogParen=p}											\\
% |\Log[4]{5}|				& $\Log[4]{5}$		& $\displaystyle \Log[4]{5}$		\\
% \end{tabular}
%    \begin{macrocode}
	\newcommand{\COOL@notation@LogBaseESymb}{ln}% 'ln', 'log'
	\newcommand{\COOL@notation@LogShowBase}{at will}% 'at will', 'always'
\newcommand{\Log}[2][\E]
{%
\ifthenelse{ \equal{\COOL@notation@LogShowBase}{at will} }%
	{%
	\ifthenelse{ \equal{#1}{\E} }%
		{%
		\ifthenelse{ \equal{\COOL@notation@LogBaseESymb}{ln} }%
			{%
			\ln \COOL@decide@paren{Log}{#2}%
			}%
		% Else
			{%
			\ifthenelse{ \equal{\COOL@notation@LogBaseESymb}{log} }%
				{%
				\log \COOL@decide@paren{Log}{#2}%
				}%
			% Else
				{%
				\PackageError{cool}{Invalid Option Sent}%
					{LogBaseESymb can only be `ln' or `log'}%
				}%
			}%
		}%
	% Else
		{%
		\ifthenelse{	\equal{#1}{10} \AND 
				\NOT \equal{\COOL@notation@LogBaseESymb}{log}	 }%
			{%
			\log \COOL@decide@paren{Log}{#2}%
			}%
		% Else
			{%
			\log_{#1} \COOL@decide@paren{Log}{#2}%
			}%
		}%
	}%
% Else
	{%
	\ifthenelse{ \equal{\COOL@notation@LogShowBase}{always} }%
		{%
		\log_{#1}\COOL@decide@paren{Log}{#2}%
		}%
	% Else
		{%
		\PackageError{cool}{Invalid Option Sent}%
			{LogShowBase can only be 'at will' or 'always'}%
		}%
	}%
}
%    \end{macrocode}
% \end{macro}
%
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% %  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %
% \subsubsection{Trigonometric Functions}
% %  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% \begin{macro}{\Sin}
% The sine function, |\Sin{x}|, $\Sin{x}$
%    \begin{macrocode}
	\newcommand{\COOL@notation@SinParen}{p}
\newcommand{\Sin}[1]{\sin\COOL@decide@paren{Sin}{#1}}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\Cos}
% The cosine function, |\Cos{x}|, $\Cos{x}$
%    \begin{macrocode}
	\newcommand{\COOL@notation@CosParen}{p}
\newcommand{\Cos}[1]{\cos\COOL@decide@paren{Cos}{#1}}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\Tan}
% The tangent function, |\Tan{x}|, $\Tan{x}$
%    \begin{macrocode}
	\newcommand{\COOL@notation@TanParen}{p}
\newcommand{\Tan}[1]{\tan\COOL@decide@paren{Tan}{#1}}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\Csc}
% The cosecant function, |\Csc{x}|, $\Csc{x}$
%    \begin{macrocode}
	\newcommand{\COOL@notation@CscParen}{p}
\newcommand{\Csc}[1]{\csc\COOL@decide@paren{Csc}{#1}}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\Sec}
% The secant function, |\Sec{x}|, $\Sec{x}$
%    \begin{macrocode}
	\newcommand{\COOL@notation@SecParen}{p}
\newcommand{\Sec}[1]{\sec\COOL@decide@paren{Sec}{#1}}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\Cot}
% The cotangent function, |\Cot{x}|, $\Cot{x}$
%    \begin{macrocode}
	\newcommand{\COOL@notation@CotParen}{p}
\newcommand{\Cot}[1]{\cot\COOL@decide@paren{Cot}{#1}}
%    \end{macrocode}
% \end{macro}
%
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% %  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %
% \subsubsection{Inverse Trigonometric Functions}
% %  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% \begin{macro}{\COOL@notation@ArcTrig}
% The inverse trigoneometric functions style is governed by this global key.  It's options are
%
% |inverse| (default), this displays as $\sin^{-1}$
%
% |arc|, this displays as $\arcsin$
%    \begin{macrocode}
	\def\COOL@notation@ArcTrig{inverse}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\ArcSin}
% The inverse of the sine function, |\ArcSin{x}|, $\ArcSin{x}$
%    \begin{macrocode}
	\newcommand{\COOL@notation@ArcSinParen}{p}
\newcommand{\ArcSin}[1]{%
\ifthenelse{ \equal{\COOL@notation@ArcTrig}{inverse} }%
	{%
	\sin^{-1}\COOL@decide@paren{ArcSin}{#1}%
	}
% else
	{
	\ifthenelse{\equal{\COOL@notation@ArcTrig}{arc}}%
		{%
		\arcsin\COOL@decide@paren{ArcSin}{#1}%
		}%
	% else
		{%
		\PackageError{cool}{Invalid option sent}{}%
		}%
	}%
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\ArcCos}
% the inverse of the cosine function, |\ArcCos{x}|, $\ArcCos{x}$
%    \begin{macrocode}
	\newcommand{\COOL@notation@ArcCosParen}{p}
\newcommand{\ArcCos}[1]{%
\ifthenelse{ \equal{\COOL@notation@ArcTrig}{inverse} }%
	{%
	\cos^{-1}\COOL@decide@paren{ArcCos}{#1}%
	}%
% else
	{%
	\ifthenelse{\equal{\COOL@notation@ArcTrig}{arc}}%
		{%
		\arccos\COOL@decide@paren{ArcCos}{#1}%
		}%
	% else
		{%
		\PackageError{cool}{Invalid option sent}{}%
		}%
	}%
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\ArcTan}
% The inverse of the tangent function, |\ArcTan{x}|, $\ArcTan{x}$
%    \begin{macrocode}
	\newcommand{\COOL@notation@ArcTanParen}{p}
\newcommand{\ArcTan}[1]{%
\ifthenelse{ \equal{\COOL@notation@ArcTrig}{inverse} }%
	{%
	\tan^{-1}\COOL@decide@paren{ArcTan}{#1}%
	}%
% else
	{%
	\ifthenelse{\equal{\COOL@notation@ArcTrig}{arc}}%
		{%
		\arctan\COOL@decide@paren{ArcTan}{#1}%
		}%
	% else
		{%
		\PackageError{cool}{Invalid option sent}{}%
		}%
	}%
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\ArcCsc}
% The Inverse Cosecant function, |\ArcCsc{x}|, $\ArcCsc{x}$
%    \begin{macrocode}
	\newcommand{\COOL@notation@ArcCscParen}{p}
\newcommand{\ArcCsc}[1]{\csc^{-1}\COOL@decide@paren{ArcCsc}{#1}}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\ArcSec}
% The inverse secant function, |\ArcSec{x}|, $\ArcSec{x}$
%    \begin{macrocode}
	\newcommand{\COOL@notation@ArcSecParen}{p}
\newcommand{\ArcSec}[1]{\sec^{-1}\COOL@decide@paren{ArcSec}{#1}}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\ArcCot}
% The inverse cotangent function, |\ArcCot{x}|, $\ArcCot{x}$
%    \begin{macrocode}
	\newcommand{\COOL@notation@ArcCotParen}{p}
\newcommand{\ArcCot}[1]{\cot^{-1}\COOL@decide@paren{ArcCot}{#1}}
%    \end{macrocode}
% \end{macro}
%
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% %  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %
% \subsubsection{Hyperbolic Functions}
% %  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% \begin{macro}{\Sinh}
% Hyperbolic sine, |\Sinh{x}|, $\Sinh{x}$
%    \begin{macrocode}
	\newcommand{\COOL@notation@SinhParen}{p}
\newcommand{\Sinh}[1]{\sinh\COOL@decide@paren{Sinh}{#1}}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\Cosh}
% Hyperbolic cosine, |\Cosh{x}|, $\Cosh{x}$
%    \begin{macrocode}
	\newcommand{\COOL@notation@CoshParen}{p}
\newcommand{\Cosh}[1]{\cosh\COOL@decide@paren{Cosh}{#1}}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\Tanh}
% Hyperbolic Tangent, |\Tanh{x}|, $\Tanh{x}$
%    \begin{macrocode}
	\newcommand{\COOL@notation@TanhParen}{p}
\newcommand{\Tanh}[1]{\tanh\COOL@decide@paren{Tanh}{#1}}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\Csch}
% Hyperbolic cosecant |\Csch{x}|, $\Csch{x}$
%    \begin{macrocode}
	\newcommand{\COOL@notation@CschParen}{p}
	\DeclareMathOperator{\csch}{csch}
\newcommand{\Csch}[1]{\csch\COOL@decide@paren{Csch}{#1}}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\Sech}
% Hyperbolic secant, |\Sech{x}|, $\Sech{x}$
%    \begin{macrocode}
	\newcommand{\COOL@notation@SechParen}{p}
	\DeclareMathOperator{\sech}{sech}
\newcommand{\Sech}[1]{\sech\COOL@decide@paren{Sech}{#1}}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\Coth}
% Hyperbolic Cotangent, |\Coth{x}|, $\Coth{x}$
%    \begin{macrocode}
	\newcommand{\COOL@notation@CothParen}{p}
\newcommand{\Coth}[1]{\coth\COOL@decide@paren{Coth}{#1}}
%    \end{macrocode}
% \end{macro}
%
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% %  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %
% \subsubsection{Inverse Hyperbolic Functions}
% %  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% \begin{macro}{\ArcSinh}
% Inverse hyperbolic sine, |\ArcSinh{x}|, $\ArcSinh{x}$
%    \begin{macrocode}
	\newcommand{\COOL@notation@ArcSinhParen}{p}
\newcommand{\ArcSinh}[1]{\sinh^{-1}\COOL@decide@paren{ArcSinh}{#1}}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\ArcCosh}
% Inverse hyperbolic cosine, |\ArcCosh{x}|, $\ArcCosh{x}$
%    \begin{macrocode}
	\newcommand{\COOL@notation@ArcCoshParen}{p}
\newcommand{\ArcCosh}[1]{\cosh^{-1}\COOL@decide@paren{ArcCosh}{#1}}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\ArcTanh}
% Inverse hyperbolic tangent, |\ArcTanh{x}|, $\ArcTanh{x}$
%    \begin{macrocode}
	\newcommand{\COOL@notation@ArcTanhParen}{p}
\newcommand{\ArcTanh}[1]{\tanh^{-1}\COOL@decide@paren{ArcTanh}{#1}}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\ArcCsch}
% Inverse hyperbolic cosecant, |\ArcCsch{x}|, $\ArcCsch{x}$
%    \begin{macrocode}
	\newcommand{\COOL@notation@ArcCschParen}{p}
\newcommand{\ArcCsch}[1]{\csch^{-1}\COOL@decide@paren{ArcCsch}{#1}}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\ArcSech}
% Inverse hyperbolic secant, |\ArcSech{x}|, $\ArcSech{x}$
%    \begin{macrocode}
	\newcommand{\COOL@notation@ArcSechParen}{p}
\newcommand{\ArcSech}[1]{\sech^{-1}\COOL@decide@paren{ArcSech}{#1}}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\ArcCoth}
% Inverse hyperbolic cotangent, |\ArcCoth{x}|, $\ArcCoth{x}$
%    \begin{macrocode}
	\newcommand{\COOL@notation@ArcCothParen}{p}
\newcommand{\ArcCoth}[1]{\coth^{-1}\COOL@decide@paren{ArcCoth}{#1}}
%    \end{macrocode}
% \end{macro}
%
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% %  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %
% \subsubsection{Product Logarithms}
% %  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%
% \begin{macro}{\LambertW}
% Lambert Function. |\LambertW| is an alias for |\ProductLog| and its properties are therefore set using that function
%    \begin{macrocode}
\newcommand{\LambertW}[1]{\ProductLog{#1}}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\ProductLog}
% Generalized Lambert Function |\ProductLog{|[\meta{index}|,|]\meta{variable}|}|.
%
% \begin{tabular}{lll}
% Lambert Function		& |\ProductLog{x}|	& $\ProductLog{x}$		\\
% Generalized Lambert Function	& |\ProductLog{k,x}|	& $\ProductLog{k,x}$		\\
% \end{tabular}
%    \begin{macrocode}
	\newcommand{\COOL@notation@ProductLogParen}{p}
\newcommand{\ProductLog}[1]{%
\listval{#1}{0}%
\ifthenelse{\value{COOL@listpointer}=1}%
	{%
	W\COOL@decide@paren{ProductLog}{#1}%
	}%
% else
	{%
	\ifthenelse{\value{COOL@listpointer}=2}%
		{%
		W_{\listval{#1}{1}}\COOL@decide@paren{ProductLog}{\listval{#1}{2}}%
		}%
	% else
		{%
		\PackageError{cool}{`ProductLog' Invaid Argument}%
			{Must have a comma separated list of length 1 or 2}
		}%
	}%
}
%    \end{macrocode}
% \end{macro}
%
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% %  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %
% \subsubsection{Max and Min}
% %  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% \begin{macro}{\Max}
% the maximum function, |\Max{x,y,z}|, $\Max{x,y,z}$ 
%    \begin{macrocode}
	\newcommand{\COOL@notation@MaxParen}{p}
\newcommand{\Max}[1]{\max\COOL@decide@paren{Max}{#1}}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\Min}
% the minimum function, |\Min{x,y,z}|, $\Min{x,y,z}$ 
%    \begin{macrocode}
	\newcommand{\COOL@notation@MinParen}{p}
\newcommand{\Min}[1]{\min\COOL@decide@paren{Min}{#1}}
%    \end{macrocode}
% \end{macro}
%
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% %  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %
% \subsubsection{Bessel Functions}
% %  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% \begin{macro}{\BesselJ}
% Bessel Function of the first kind, |\BesselJ{\nu}{x}|, $\BesselJ{\nu}{x}$
%    \begin{macrocode}
	\newcommand{\COOL@notation@BesselJSymb}{J}
	\newcommand{\COOL@notation@BesselJParen}{p}
\newcommand{\BesselJ}[2]%
{\COOL@notation@BesselJSymb_{#1}\COOL@decide@paren{BesselJ}{#2}}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\BesselY}
% Bessel Function of the second kind, |\BesselY{\nu}{x}|, $\BesselY{\nu}{x}$
%    \begin{macrocode}
	\newcommand{\COOL@notation@BesselYSymb}{Y}
	\newcommand{\COOL@notation@BesselYParen}{p}
\newcommand{\BesselY}[2]%
{\COOL@notation@BesselYSymb_{#1}\COOL@decide@paren{BesselY}{#2}}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\BesselI}
% Modified Bessel Function of the first kind, |\BesselI{\nu}{x}|, $\BesselI{\nu}{x}$
%    \begin{macrocode}
	\newcommand{\COOL@notation@BesselISymb}{I}
	\newcommand{\COOL@notation@BesselIParen}{p}
\newcommand{\BesselI}[2]%
{\COOL@notation@BesselISymb_{#1}\COOL@decide@paren{BesselI}{#2}}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\BesselK}
% Modified Bessel Function of the second kind, |\BesselK{\nu}{x}|, $\BesselK{\nu}{x}$
%    \begin{macrocode}
	\newcommand{\COOL@notation@BesselKSymb}{K}
	\newcommand{\COOL@notation@BesselKParen}{p}
\newcommand{\BesselK}[2]%
{\COOL@notation@BesselKSymb_{#1}\COOL@decide@paren{BesselK}{#2}}
%    \end{macrocode}
% \end{macro}
%
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% %  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %
% \subsubsection{Airy Functions}
% %  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% \begin{macro}{\AiryAi}
% Airy Ai Function, |\AiryAi{x}|, $\AiryAi{x}$
%    \begin{macrocode}
	\newcommand{\COOL@notation@AiryAiParen}{p}
	\DeclareMathOperator{\AiryAiSymb}{Ai}
\newcommand{\AiryAi}[1]{\AiryAiSymb\COOL@decide@paren{AiryAi}{#1}}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\AiryBi}
% Airy Bi Function, |\AiryBi{x}|, $\AiryBi{x}$
%    \begin{macrocode}
	\newcommand{\COOL@notation@AiryBiParen}{p}
	\DeclareMathOperator{\AiryBiSymb}{Bi}
\newcommand{\AiryBi}[1]{\AiryBiSymb\COOL@decide@paren{AiryBi}{#1}}
%    \end{macrocode}
% \end{macro}
%
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% %  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %
% \subsubsection{Struve Functions}
% %  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% \begin{macro}{\StruveH}
% Struve H function, |\StruveH{\nu}{z}|,  $\StruveH{\nu}{z}$
%    \begin{macrocode}
	\newcommand{\COOL@notation@StruveHParen}{p}
\newcommand{\StruveH}[2]{ {\bf H}_{#1}\COOL@decide@paren{StruveH}{#2}}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\StruveL}
% Struve L function,  |\StruveL{\nu}{z}|, $\StruveL{\nu}{z}$
%    \begin{macrocode}
	\newcommand{\COOL@notation@StruveLParen}{p}
\newcommand{\StruveL}[2]{ {\bf L}_{#1}\COOL@decide@paren{StruveL}{#2}}
%    \end{macrocode}
% \end{macro}
%
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% %  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %
% \subsubsection{Integer Functions}
% %  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% \begin{macro}{\Floor}
% floor, |\Floor{x}|, $\Floor{x}$
%    \begin{macrocode}
\newcommand{\Floor}[1]{\lfloor #1 \rfloor}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\Ceiling}
% ceiling, |\Ceiling{x}|, $\Ceiling{x}$
%    \begin{macrocode}
\newcommand{\Ceiling}[1]{\lceil #1 \rceil}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\Round}
% round, |\Round{x}|, $\Round{x}$
%    \begin{macrocode}
\newcommand{\Round}[1]{\lfloor #1 \rceil}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\iPart}
% \begin{macro}{\IntegerPart}
% The integer part of a real number, |\iPart{x}|, |\IntegerPart{x}|, $\iPart{x}$
%    \begin{macrocode}
	\newcommand{\COOL@notation@IntegerPartParen}{p}
	\DeclareMathOperator{\iPartSymb}{int}
\newcommand{\iPart}[1]{\iPartSymb\COOL@decide@paren{IntegerPart}{#1}}
\newcommand{\IntegerPart}[1]{\iPart{#1}}
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\fPart}
% \begin{macro}{\FractionalPart}
% the fractional part of a real number, |\fPart{x}|, |\FractionalPart{x}|, $\fPart{x}$
%    \begin{macrocode}
	\newcommand{\COOL@notation@FractionalPartParen}{p}
	\DeclareMathOperator{\fPartSymb}{frac}
\newcommand{\fPart}[1]{\fPartSymb\COOL@decide@paren{FractionalPart}{#1}}
\newcommand{\FractionalPart}[1]{\fPart{#1}}
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\Mod}
% Modulo, |\Mod{n}{m}|, $\Mod{n}{m}$
%    \begin{macrocode}
	\newcommand{\COOL@notation@ModDisplay}{mod}
\newcommand{\Mod}[2]{%
\ifthenelse{\equal{\COOL@notation@ModDisplay}{mod}}%
	{%
	#1 \mod #2%
	}%
% ElseIf
{ \ifthenelse{\equal{\COOL@notation@ModDisplay}{bmod}}%
	{%
	#1 \bmod #2%
	}%
% ElseIf
{ \ifthenelse{\equal{\COOL@notation@ModDisplay}{pmod}}%
	{%
	#1 \pmod #2%
	}%
% ElseIf
{\ifthenelse{\equal{\COOL@notation@ModDisplay}{pod}}%
	{%
	#1 \pod #2%
	}%
% Else
	{%
	\PackageError{cool}{Invalid Option Sent}%
		{ModDisplay can only be `mod', `bmod', `pmod', or `pod'}%
	}}}}%
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\Quotient}
% quotient, |\Quotient{m}{n}|, $\Quotient{m}{n}$
%    \begin{macrocode}
	\newcommand{\COOL@notation@QuotientParen}{p}
	\DeclareMathOperator{\QuotientSymb}{quotient}
\newcommand{\Quotient}[2]%
{\QuotientSymb\COOL@decide@paren{Quotient}{#1,#2}}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\GCD}
% greatest common divisor, |\GCD{n_1,n_2,\dots,n_m}|, $\GCD{n_1,n_2,\dots,n_m}$
%    \begin{macrocode}
	\newcommand{\COOL@notation@GCDParen}{p}
\newcommand{\GCD}[1]{\gcd\COOL@decide@paren{GCD}{#1}}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\ExtendedGCD}
% \begin{macro}{\EGCD}
% Extended Greatest Common Divisor, 
%
%|\EGCD{n}{m}|, |\ExtendedGCD{n}{m}|, $\EGCD{n}{m}$
%    \begin{macrocode}
	\newcommand{\COOL@notation@ExtendedGCDParen}{p}
	\DeclareMathOperator{\ExtendedGCDSymb}{egcd}
\newcommand{\ExtendedGCD}[2]%
{\ExtendedGCDSymb\COOL@decide@paren{ExtendedGCD}{#1,#2}}
\newcommand{\EGCD}[2]{\ExtendedGCD{#1}{#2}}
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\LCM}
% Least Common Multiple, |\LCM{n_1,n_2,\ldots,n_m}|, $\LCM{n_1,n_2,\ldots,n_m}$
%    \begin{macrocode}
	\newcommand{\COOL@notation@LCMParen}{p}
	\DeclareMathOperator{\LCMSymb}{lcm}
\newcommand{\LCM}[1]{\LCMSymb\COOL@decide@paren{LCM}{#1}}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\Fibonacci}
% Fibonacci number, |\Fibonacci{n}|, $\Fibonacci{n}$, and 
%
% Fibonacci Polynomial, |\Fibonacci{n,x}|, $\Fibonacci{n,x}$
%    \begin{macrocode}
	\newcommand{\COOL@notation@FibonacciParen}{p}
\newcommand{\Fibonacci}[1]{%
\liststore{#1}{COOL@Fibonacci@arg@}%
\listval{#1}{0}%
\ifthenelse{\value{COOL@listpointer} = 1}%
	{%
	F_{#1}%
	}%
% ElseIf
{ \ifthenelse{\value{COOL@listpointer} = 2}%
	{%
	F_{\COOL@Fibonacci@arg@i}%
		\COOL@decide@paren{Fibonacci}{\COOL@Fibonacci@arg@ii}%
	}%
% Else
	{%
	\PackageError{cool}{Invalid Argument}%
		{`Fibonacci' can only accept a 
		comma separate list of length 1 or 2}%
	}}%
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\Euler}
% Euler number, |\Euler{n}|, $\Euler{n}$, and Euler Polynomial, |\Euler{n,x}|, $\Euler{n,x}$
%    \begin{macrocode}
	\newcommand{\COOL@notation@EulerParen}{p}
\newcommand{\Euler}[1]{%
\liststore{#1}{COOL@Euler@arg@}%
\listval{#1}{0}%
\ifthenelse{\value{COOL@listpointer} = 1}%
	{%
	E_{#1}%
	}%
% ElseIf
{ \ifthenelse{\value{COOL@listpointer} = 2}%
	{%
	E_{\COOL@Euler@arg@i}%
		\COOL@decide@paren{Euler}{\COOL@Euler@arg@ii}%
	}%
% Else
	{%
	\PackageError{cool}{Invalid Argument}%
		{`Euler' can only accept a 
		comma separate list of length 1 or 2}%
	}}%
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\Bernoulli}
% Bernoulli number, |\Bernoulli{n}|, $\Bernoulli{n}$ and 
%
% Bernoulli Polynomial |\Bernoulli{n,x}|, $\Bernoulli{n,x}$
%    \begin{macrocode}
	\newcommand{\COOL@notation@BernoulliParen}{p}
\newcommand{\Bernoulli}[1]{%
\liststore{#1}{COOL@Bernoulli@arg@}%
\listval{#1}{0}%
\ifthenelse{\value{COOL@listpointer} = 1}%
	{%
	B_{#1}%
	}%
% ElseIf
{ \ifthenelse{\value{COOL@listpointer} = 2}%
	{%
	B_{\COOL@Bernoulli@arg@i}%
		\COOL@decide@paren{Bernoulli}{\COOL@Bernoulli@arg@ii}%
	}%
% Else
	{%
	\PackageError{cool}{Invalid Argument}%
		{`Bernoulli' can only accept a 
		comma separate list of length 1 or 2}%
	}}%
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\StirlingSOne}
% Stirling number of the first kind |\StirlingSOne{n}{m}|, $\StirlingSOne{n}{m}$
%    \begin{macrocode}
\newcommand{\StirlingSOne}[2]{S_{#1}^{\inp{#2}}}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\StirlingSTwo}
% Stirling number of the second kind, |\StirlingSTwo{n}{m}|, $\StirlingSTwo{n}{m}$
%    \begin{macrocode}
\newcommand{\StirlingSTwo}[2]{{\cal S}_{#1}^{\inp{#2}}}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\PartitionsP}
% Number of unrestricted partitions of an integer, |\PartitionsP{x}|, $\PartitionsP{x}$
%    \begin{macrocode}
	\newcommand{\COOL@notation@PartitionsPParen}{p}
\newcommand{\PartitionsP}[1]{p\COOL@decide@paren{PartitionsP}{#1}}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\PartitionsQ}
% number of partitions of an integer into distinct parts, |\PartitionsQ{x}|, $\PartitionsQ{x}$
%    \begin{macrocode}
	\newcommand{\COOL@notation@PartitionsQParen}{p}
\newcommand{\PartitionsQ}[1]{q\COOL@decide@paren{PartitionsQ}{#1}}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\DiscreteDelta}
% Discrete delta function,
%
% |\DiscreteDelta{n_1,n_2,\ldots,n_m}|, $\DiscreteDelta{n_1,n_2,\ldots,n_m}$
%    \begin{macrocode}
	\newcommand{\COOL@notation@DiscreteDeltaParen}{p}
\newcommand{\DiscreteDelta}[1]%
{\delta\COOL@decide@paren{DiscreteDelta}{#1}}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\KroneckerDelta}
% Kronecker Delta, |\KroneckerDelta{n_1,n_2,\ldots,n_m}|, $\KroneckerDelta{n_1,n_2,\ldots,n_m}$
%    \begin{macrocode}
	\newcommand{\COOL@notation@KroneckerDeltaUseComma}{false}%
	\newcommand{\COOL@notation@KroneckerDeltaIndicies}{local}
\newcommand{\KroneckerDelta}[2][u]{%
\liststore{#2}{COOL@arg@}%
\listval{#2}{0}%
\def\COOL@arg@temp{}%
\forLoop{1}{\value{COOL@listpointer}}{COOL@ct}%
	{%
	\ifthenelse{\equal{\COOL@notation@KroneckerDeltaUseComma}{true}}%
		{%
		\ifthenelse{\NOT \value{COOL@ct} = 1}
			{%
			\edef\COOL@arg@temp%
			{\COOL@arg@temp, \csname COOL@arg@\roman{COOL@ct}\endcsname}%
			}%
		% Else
			{%
			\edef\COOL@arg@temp%
			{\COOL@arg@temp \csname COOL@arg@\roman{COOL@ct}\endcsname}%
			}%
		}%
	% Else
		{%
		\edef\COOL@arg@temp%
			{\COOL@arg@temp \csname COOL@arg@\roman{COOL@ct}\endcsname}%
		}%
	}%
\delta\COOL@decide@indicies{KroneckerDelta}{#1}{\COOL@arg@temp}%
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\LeviCivita}
% \begin{macro}{\Signature}
% Levi-Civita totally anti-symmetric Tensor density, 
%
% |\LeviCivita{n_1,n_2,\ldots,n_m}|, $\LeviCivita{n_1,n_2,\ldots,n_m}$
%    \begin{macrocode}
	\newcommand{\COOL@notation@LeviCivitaUseComma}{false}
	\newcommand{\COOL@notation@LeviCivitaIndicies}{local}
\newcommand{\LeviCivita}[2][u]{%
\liststore{#2}{COOL@arg@}%
\listval{#2}{0}%
\def\COOL@arg@temp{}%
\forLoop{1}{\value{COOL@listpointer}}{COOL@ct}%
	{%
	\ifthenelse{\equal{\COOL@notation@LeviCivitaUseComma}{true}}%
		{%
		\ifthenelse{\NOT \value{COOL@ct} = 1}%
			{%
			\edef\COOL@arg@temp%
				{\COOL@arg@temp, \csname COOL@arg@\roman{COOL@ct}\endcsname}%
			}%
		% Else
			{%
			\edef\COOL@arg@temp%
				{\COOL@arg@temp \csname COOL@arg@\roman{COOL@ct}\endcsname}%
			}%
		}%
	% Else
		{%
		\edef\COOL@arg@temp%
			{\COOL@arg@temp \csname COOL@arg@\roman{COOL@ct}\endcsname}%
		}%
	}%
\epsilon\COOL@decide@indicies{LeviCivita}{#1}{\COOL@arg@temp}%
}%
\newcommand{\Signature}[2][u]{\LeviCivita[#1]{#2}}
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% %  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %
% \subsubsection{Classical Orthogonal Polynomials}
% %  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% \begin{macro}{\HermiteH}
% Hermite Polynomial, |\HermiteH{n}{x}|, $\HermiteH{n}{x}$
%    \begin{macrocode}
	\newcommand{\COOL@notation@HermiteHParen}{p}
	\newcommand{\COOL@notation@HermiteHSymb}{H}
\newcommand{\HermiteH}[2]%
{\COOL@notation@HermiteHSymb_{#1}\COOL@decide@paren{HermiteH}{#2}}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\LaugerreL}
% Laugerre Polynomial, |\LaugerreL{\nu,x}|, $\LaugerreL{\nu,x}$ and 
%
% \noindent Generalized Laugerre Polynomial |\LaugerreL{\nu,\lambda,x}|, $\LaugerreL{\nu,\lambda,x}$
%    \begin{macrocode}
	\newcommand{\COOL@notation@LaugerreLParen}{p}
	\newcommand{\COOL@notation@LaugerreLSymb}{L}
\newcommand{\LaugerreL}[1]{%
\liststore{#1}{COOL@list@temp@}%
\listval{#1}{0}%
\ifthenelse{\value{COOL@listpointer}=2}%
	{%
	\COOL@notation@LaugerreLSymb_{\COOL@list@temp@i}%
		\COOL@decide@paren{LaugerreL}{\COOL@list@temp@ii}%
	}%
% Else If
{ \ifthenelse{\value{COOL@listpointer}=3}%
	{%
	\COOL@notation@LaugerreLSymb_{\COOL@list@temp@i}^{\COOL@list@temp@ii}%
		\COOL@decide@paren{LaugerreL}{\COOL@list@temp@iii}%
	}%
% Else
{%
	\PackageError{cool}{Invalid Argument}%
		{`LaugerrL' only accepts a comma separated list of length 2 or 3}%
}}%
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\LegendreP}
% Legendre Polynomials
%
% \begin{tabular}{lll}
% Legendre Polynomial		& |\LegendreP{n,x}|		& $\LegendreP{n,x}$		\\
% Associated Legendre Polynomial \\
% \indent of the first kind of type 2
%				& |\LegendreP{\ell,m,x}|	& $\LegendreP{\ell,m,x}$	\\
%				& |\LegendreP{\ell,m,2,x}|	& $\LegendreP{\ell,m,2,x}$	\\
% Associated Legendre Function \\
% \indent of the first kind of type 3
%				& |\LegendreP{\ell,m,3,x}|	& $\LegendreP{\ell,m,3,x}$	\\
% \end{tabular}
%    \begin{macrocode}
	\newcommand{\COOL@notation@LegendrePParen}{p}
	\newcommand{\COOL@notation@LegendrePSymb}{P}
\newcommand{\LegendreP}[1]{%
\liststore{#1}{COOL@LegendreP@arg@}%
\listval{#1}{0}%
\ifthenelse{\value{COOL@listpointer} = 2}%
	{%
	\COOL@notation@LegendrePSymb_{\COOL@LegendreP@arg@i}%
		\COOL@decide@paren{LegendreP}{\COOL@LegendreP@arg@ii}%
	}%
% ElseIf
{ \ifthenelse{\value{COOL@listpointer} = 3}%
	{%
	\COOL@notation@LegendrePSymb_{\COOL@LegendreP@arg@i}%
		^{\COOL@LegendreP@arg@ii}%
		\COOL@decide@paren{LegendreP}{\COOL@LegendreP@arg@iii}%
	}%
% ElseIf
{ \ifthenelse{\value{COOL@listpointer} = 4}%
	{%
	\isint{\COOL@LegendreP@arg@iii}{COOL@isint}%
	\ifthenelse{\boolean{COOL@isint}}%
		{%
		\ifcase\COOL@LegendreP@arg@iii\relax%
		\PackageError{cool}{Invalid Argument}%
			{`LegendreP' third argument must be $>$ 1}%
		\or%
		\PackageError{cool}{Invalid Argument}%
			{`LegendreP' third argument must be $>$ 1}%
		\or%
		\COOL@notation@LegendrePSymb_{\COOL@LegendreP@arg@i}%
			^{\COOL@LegendreP@arg@ii}%
			\COOL@decide@paren{LegendreP}{\COOL@LegendreP@arg@iv}%
		\or%
		{\cal P}_{\COOL@LegendreP@arg@i}%
			^{\COOL@LegendreP@arg@ii}%
			\COOL@decide@paren{LegendreP}{\COOL@LegendreP@arg@iv}%
		\else%
		\PackageError{cool}{Invalid Argument}{unsupported}%
		\fi%
		}
	% Else
		{%
		\PackageError{cool}{Invalid Argument}{third arg must be int}%
		}%
	}%
% Else
	{%
	\PackageError{cool}{Invalid Argument}%
		{`LegendreP' can only accept a%
		 comma separated list of length 2-4}%
	}}}%
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\LegendreQ}
% Legendre Polynomials of the second kind
%
% \begin{tabular}{lll}
% Legendre Polynomial		& |\LegendreQ{n,x}|		& $\LegendreQ{n,x}$		\\
% Associated Legendre Polynomial \\
% \indent of the second kind of type 2
%				& |\LegendreQ{\ell,m,x}|	& $\LegendreQ{\ell,m,x}$	\\
%				& |\LegendreQ{\ell,m,2,x}|	& $\LegendreQ{\ell,m,2,x}$	\\
% Associated Legendre Function \\
% \indent of the second kind of type 3
%				& |\LegendreQ{\ell,m,3,x}|	& $\LegendreQ{\ell,m,3,x}$	\\
% \end{tabular}
%    \begin{macrocode}
	\newcommand{\COOL@notation@LegendreQParen}{p}
	\newcommand{\COOL@notation@LegendreQSymb}{Q}
\newcommand{\LegendreQ}[1]{%
\liststore{#1}{COOL@LegendreQ@arg@}%
\listval{#1}{0}%
\ifthenelse{\value{COOL@listpointer} = 2}%
	{%
	\COOL@notation@LegendreQSymb_{\COOL@LegendreQ@arg@i}%
		\COOL@decide@paren{LegendreQ}{\COOL@LegendreQ@arg@ii}%
	}%
% ElseIf
{ \ifthenelse{\value{COOL@listpointer} = 3}%
	{%
	\COOL@notation@LegendreQSymb_{\COOL@LegendreQ@arg@i}%
		^{\COOL@LegendreQ@arg@ii}%
		\COOL@decide@paren{LegendreQ}{\COOL@LegendreQ@arg@iii}%
	}%
% ElseIf
{ \ifthenelse{\value{COOL@listpointer} = 4}%
	{%
	\isint{\COOL@LegendreQ@arg@iii}{COOL@isint}%
	\ifthenelse{\boolean{COOL@isint}}%
		{%
		\ifcase\COOL@LegendreQ@arg@iii\relax%
		\PackageError{cool}{Invalid Argument}%
			{`LegendreQ' third argument must be $>$ 1}%
		\or%
		\PackageError{cool}{Invalid Argument}%
			{`LegendreQ' third argument must be $>$ 1}%
		\or%
		\COOL@notation@LegendreQSymb_{\COOL@LegendreQ@arg@i}%
			^{\COOL@LegendreQ@arg@ii}%
			\COOL@decide@paren{LegendreQ}{\COOL@LegendreQ@arg@iv}%
		\or%
		{\cal Q}_{\COOL@LegendreQ@arg@i}%
			^{\COOL@LegendreQ@arg@ii}%
			\COOL@decide@paren{LegendreQ}{\COOL@LegendreQ@arg@iv}%
		\else%
		\PackageError{cool}{Invalid Argument}{unsupported}%
		\fi%
		}
	% Else
		{%
		\PackageError{cool}{Invalid Argument}{third arg must be int}%
		}%
	}%
% Else
	{%
	\PackageError{cool}{Invalid Argument}%
		{`LegendreQ' can only accept a%
		 comma separated list of length 2-4}%
	}}}%
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\ChebyshevT}
% Chebyshev Polynomial of the first kind, |ChebyshevT{n}{x}|, $ChebyshevT{n}{x}$
%    \begin{macrocode}
	\newcommand{\COOL@notation@ChebyshevTParen}{p}
	\newcommand{\COOL@notation@ChebyshevTSymb}{T}
\newcommand{\ChebyshevT}[2]%
{\COOL@notation@ChebyshevTSymb_{#1}\COOL@decide@paren{ChebyshevT}{#2}}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\ChebyshevU}, |\ChebyshevU{n}{z}|, $\ChebyshevU{n}{z}$
% Chebyshev Polynomial of the second kind 
%    \begin{macrocode}
	\newcommand{\COOL@notation@ChebyshevUParen}{p}
	\newcommand{\COOL@notation@ChebyshevUSymb}{U}
\newcommand{\ChebyshevU}[2]%
{\COOL@notation@ChebyshevUSymb_{#1}\COOL@decide@paren{ChebyshevU}{#2}}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\JacobiP}
% Jacobi Polynomial, |\JacobiP{n}{a}{b}{x}|, $\JacobiP{n}{a}{b}{x}$
%    \begin{macrocode}
	\newcommand{\COOL@notation@JacobiPParen}{p}
	\newcommand{\COOL@notation@JacobiPSymb}{P}
\newcommand{\JacobiP}[4]{%
\COOL@notation@JacobiPSymb_{#1}^{\inp{#2, #3}}%
\COOL@decide@paren{JacobiP}{#4}%
}
%    \end{macrocode}
% \end{macro}
%
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% %  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %
% \subsubsection{Associated Polynomials}
% %  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% \begin{macro}{\AssocLegendreP}
% Associated Legendre Polynomial of the first kind of type 2
%
% |\AssocLegendreP{\ell}{m}{x}|, $\AssocLegendreP{\ell}{m}{x}$
%    \begin{macrocode}
\newcommand{\AssocLegendreP}[3]{\LegendreP{#1,#2,#3}}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\AssocLegendreQ}
% Associated Legendre Polynomial of the second kind of type 2
%
% |\AssocLegendreQ{\ell}{m}{x}|, $\AssocLegendreQ{\ell}{m}{x}$
%    \begin{macrocode}
\newcommand{\AssocLegendreQ}[3]{\LegendreQ{#1,#2,#3}}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\GegenbauerC}
% Gegenbauer Polynomial, |\GegenbauerC{n}{\lambda}{x}|, $\GegenbauerC{n}{\lambda}{x}$
%    \begin{macrocode}
	\newcommand{\COOL@notation@GegenbauerCParen}{p}
	\newcommand{\COOL@notation@GegenbauerCSymb}{C}
\newcommand{\GegenbauerC}[3]{%
\COOL@notation@GegenbauerCSymb_{#1}^{#2}%
\COOL@decide@paren{GegenbauerC}{#3}%
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\SphericalHarmonicY}
% \begin{macro}{\SphericalHarmY}
% \begin{macro}{\SpHarmY}
% Spherical Harmonic, |\SpHarmY{\ell}{m}{\theta}{\phi}|, 
%
% |\SphericalHarmY{\ell}{m}{\theta}{\phi}|, 
%
% |\SphericalHarmonicY{\ell}{m}{\theta}{\phi}|, $\SpHarmY{\ell}{m}{\theta}{\phi}$
%    \begin{macrocode}
	\newcommand{\COOL@notation@SphericalHarmonicYParen}{p}
	\newcommand{\COOL@notation@SphericalHarmonicYSymb}{Y}
\newcommand{\SphericalHarmonicY}[4]{%
\COOL@notation@SphericalHarmonicYSymb_{#1}^{#2}%
\COOL@decide@paren{SphericalHarmonicY}{#3,#4}%
}
\newcommand{\SphericalHarmY}[4]{\SphericalHarmonicY{#1}{#2}{#3}{#4}}
\newcommand{\SpHarmY}[4]{\SphericalHarmonicY{#1}{#2}{#3}{#4}}
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
%
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% %  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %
% \subsubsection{Other Polynomials}
% %  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% \begin{macro}{\CyclotomicC}
% Cyclotomic Polynomial, |\CyclotomicC{n}{z}|, $\CyclotomicC{n}{z}$
%    \begin{macrocode}
	\newcommand{\COOL@notation@CyclotomicCParen}{p}
\newcommand{\CyclotomicC}[2]%
{C_{#1}\COOL@decide@paren{CyclotomicC}{#2}}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\FibonacciF}
% Fibonacci Polynomial, |\FibonacciF{n}{z}|, $\FibonacciF{n}{z}$
%    \begin{macrocode}
\newcommand{\FibonacciF}[2]{\Fibonacci{#1,#2}}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\EulerE}
% Euler Polynomial, |\EulerE{n}{z}|, $\EulerE{n}{z}$
%    \begin{macrocode}
\newcommand{\EulerE}[2]{\Euler{#1,#2}}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\BernoulliB}
% Bernoulli Polynomial, |\BernoulliB{n}{z}|, $\BernoulliB{n}{z}$
%    \begin{macrocode}
\newcommand{\BernoulliB}[2]{\Bernoulli{#1,#2}}
%    \end{macrocode}
% \end{macro}
%
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% %  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %
% \subsubsection{Factorial Functions}
% %  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% \begin{macro}{\Factorial}
% Factorial, |\Factorial{n}|, $\Factorial{n}$
%    \begin{macrocode}
\newcommand{\Factorial}[1]{#1!}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\DblFactorial}
% Double Factorial, |\DblFactorial{n}|, $\DblFactorial{n}$
%    \begin{macrocode}
\newcommand{\DblFactorial}[1]{#1!!}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\Binomial}
% binomial, |\Binomial{n}{r}|, $\Binomial{n}{r}$
%    \begin{macrocode}
\newcommand{\Binomial}[2]{ \binom{#1}{#2} }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\Multinomial}
% Multinomial, |\Multinomial{n_1,\ldots,n_m}|, $\Multinomial{n_1,\ldots,n_m}$
%    \begin{macrocode}
\newcommand{\Multinomial}[1]%
{%
\listval{#1}{0}% get the length of the list
\setcounter{COOL@listlen}{\value{COOL@listpointer}}% record length
\liststore{#1}{COOL@list@temp@}%
\isint{\COOL@list@temp@i}{COOL@isint}% check that the entries are integers
\setcounter{COOL@ct}{2}%
\whiledo{	\boolean{COOL@isint} \AND 
		\NOT \value{COOL@ct}>\value{COOL@listlen}	 }%
	{%
	\def\COOL@Multinomial@tempa%
		{\csname COOL@list@temp@\roman{COOL@ct}\endcsname}%
	\isint{\COOL@Multinomial@tempa}{COOL@isint}%
	\stepcounter{COOL@ct}%
	}%
\ifthenelse{\boolean{COOL@isint}}%
	{%
	% all of them are integers
	\setcounter{COOL@ct@}{ \COOL@list@temp@i }% records the sum
	\forLoop{2}{\value{COOL@listlen}}{COOL@ct}%
		{%
		\addtocounter{COOL@ct@}%
			{\csname COOL@list@temp@\roman{COOL@ct}\endcsname}%
		}%
	\left(\arabic{COOL@ct@}%
	}%
% Else
	{%
	\left(%
	\listval{#1}{1}%
	\forLoop{2}{\value{COOL@listlen}}{COOL@ct}%
		{%
		+ \listval{#1}{\arabic{COOL@ct}}%
		}%
	}%
;#1\right)%
}
%    \end{macrocode}
% \end{macro}
%
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% %  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %
% \subsubsection{Gamma Functions}
% %  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% \begin{macro}{\GammaFunc}
% Gamma Function
%
% \noindent \begin{tabular}{lll}
% Gamma Function			& |\GammaFunc{z}|	& $\GammaFunc{z}$		\\
% Incomplete Gamma Function		& |\GammaFunc{a,z}|	& $\GammaFunc{a,z}$		\\
% Generalized Incomplete Gamma Function	& |\GammaFunc{a,x,y}|	& $\GammaFunc{a,x,y}$
% \end{tabular}
%    \begin{macrocode}
	\newcommand{\COOL@notation@GammaFuncParen}{p}
\newcommand{\GammaFunc}[1]{%
\listval{#1}{0}%
\ifthenelse{\value{COOL@listpointer} = 1}%
	{%
	\Gamma\COOL@decide@paren{GammaFunc}{#1}%
	}%
% ElseIf
{ \ifthenelse{\value{COOL@listpointer} = 2}%
	{%
	\Gamma\COOL@decide@paren{GammaFunc}{#1}%
	}%
% ElseIf
{ \ifthenelse{\value{COOL@listpointer} = 3}%
	{%
	\Gamma\COOL@decide@paren{GammaFunc}{#1}%
	}%
% Else
	{%
	\PackageError{cool}{Invalid Argument}%
		{`GammaFunc' can only accept a comma separate list of length 1 to 3}%
	}%
}}%
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\IncGamma}
% incomplete Gamma function, |\IncGamma{a}{x}|, $\IncGamma{a}{x}$
%    \begin{macrocode}
\newcommand{\IncGamma}[2]{\GammaFunc{#1,#2}}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\GenIncGamma}
% Generalized Incomplete Gamma, |\GenIncGamma{a}{x}{y}|, $\GenIncGamma{a}{x}{y}$
%    \begin{macrocode}
\newcommand{\GenIncGamma}[3]{\GammaFunc{#1, #2, #3}}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\GammaRegularized}
% \begin{macro}{\RegIncGamma}
% \begin{macro}{\GammaReg}
% Regularized Incomplete Gamma 
%
% \begin{tabular}{ll}
% |\GammaRegularized{a,x}|	& $\GammaRegularized{a,x}$		\\
% |\RegIncGamma{a}{x}|		& $\RegIncGamma{a}{x}$			\\
% |\GammaReg{a,x}|		& $\GammaReg{a,x}$			\\
% \end{tabular}
%    \begin{macrocode}
	\newcommand{\COOL@notation@GammaRegularizedParen}{p}%
\newcommand{\GammaRegularized}[1]{%
\listval{#1}{0}%
\ifthenelse{\value{COOL@listpointer} = 2}%
	{%
	Q\COOL@decide@paren{GammaRegularized}{#1}%
	}%
% ElseIf
{ \ifthenelse{\value{COOL@listpointer} = 3}%
	{%
	Q\COOL@decide@paren{GammaRegularized}{#1}%
	}%
% Else
	{%
	\PackageError{cool}{Invalid Argument}%
		{`GammaRegularized' can only accept comma%
		 separated lists of length 2 or 3}%
	}%
}%
}
\newcommand{\RegIncGamma}[2]{\GammaRegularized{#1, #2}}
\newcommand{\GammaReg}[1]{\GammaRegularized{#1}}
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\RegIncGammaInv}
% \begin{macro}{\InverseGammaRegularized}
% \begin{macro}{\GammaRegInv}
% Inverse of Regularized Incomplete Gamma,
%
% \begin{tabular}{ll}
% |\RegIncGammaInv{a}{x}|		&  $\RegIncGammaInv{a}{x}$		\\
% |\InverseGammaRegularized{a,x}|	& $\InverseGammaRegularized{a,x}$	\\
% |\GammaRegInv{a,x}|			& $\GammaRegInv{a,x}$			\\
% \end{tabular}
%    \begin{macrocode}
	\newcommand{\COOL@notation@InverseGammaRegularizedParen}{p}
\newcommand{\InverseGammaRegularized}[1]{%
\listval{#1}{0}%
\ifthenelse{\value{COOL@listpointer} = 2}%
	{%
	Q^{-1}\COOL@decide@paren{InverseGammaRegularized}{#1}%
	}%
% ElseIf
{ \ifthenelse{\value{COOL@listpointer} = 3}%
	{%
	Q^{-1}\COOL@decide@paren{InverseGammaRegularized}{#1}%
	}%
% Else
	{%
	\PackageError{cool}{Invalid Argument}%
		{`InverseGammaRegularized' can only accept%
		 a comma separated list of length 2 or 3}%
	}%
}%
}
\newcommand{\RegIncGammaInv}[2]{\InverseGammaRegularized{#1, #2}}
\newcommand{\GammaRegInv}[1]{\InverseGammaRegularized{#1}}
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\GenRegIncGamma}
% Generalized Regularized Incomplete Gamma 
%
% \begin{tabular}{ll}
% |\GenRegIncGamma{a}{x}{y}|	& $\GenRegIncGamma{a}{x}{y}$		\\
% |\GammaRegularized{a,x,y}|	& $\GammaRegularized{a,x,y}$
% \end{tabular}
%    \begin{macrocode}
\newcommand{\GenRegIncGamma}[3]{\GammaRegularized{#1, #2, #3}}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\GenRegIncGammaInv}
% Inverse of Gen. Reg. Incomplete Gamma, |\GenRegIncGammaInv{a}{x}{y}|, $\GenRegIncGammaInv{a}{x}{y}$
%    \begin{macrocode}
\newcommand{\GenRegIncGammaInv}[3]{\InverseGammaRegularized{#1, #2, #3}}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\Pochhammer}
% Pochhammer Symbol |\Pochhammer{a}{n}|, $\Pochhammer{a}{n}$
%    \begin{macrocode}
\newcommand{\Pochhammer}[2]{\inp{#1}_{#2}}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\LogGamma}
% Log Gamma Function, |\LogGamma{x}|, $\LogGamma{x}$
%    \begin{macrocode}
	\newcommand{\COOL@notation@LogGammaParen}{p}
	\DeclareMathOperator{\LogGammaSymb}{log\Gamma}
\newcommand{\LogGamma}[1]{\LogGammaSymb\COOL@decide@paren{LogGamma}{#1}}
%    \end{macrocode}
% \end{macro}
%
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% %  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %
% \subsubsection{Derivatives of Gamma Functions}
% %  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% \begin{macro}{\DiGamma}
% Digamma function, |\DiGamma{x}|, $\DiGamma{x}$
%    \begin{macrocode}
	\newcommand{\COOL@notation@DiGammaParen}{p}
\newcommand{\DiGamma}[1]{\digamma\COOL@decide@paren{DiGamma}{#1}}
%    \end{macrocode}
% \end{macro}
% PolyGamma function, |\PolyGamma{\nu}{x}|, $\PolyGamma{\nu}{x}$
% \begin{macro}{\PolyGamma}
% 
%    \begin{macrocode}
	\newcommand{\COOL@notation@PolyGammaParen}{p}
\newcommand{\PolyGamma}[2]%
{\psi^{\inp{#1}}\COOL@decide@paren{PolyGamma}{#2}}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\HarmNum}
% Harmonic Number
%
% \begin{tabular}{lll}
% Harmonic Number		& |\HarmNum{x}|		& $\HarmNum{x}$ 		\\
% General Harmonic Number	& |\HarmNum{x,r}|	& $\HarmNum{x,r}$		\\
% \end{tabular}
%    \begin{macrocode}
\newcommand{\HarmNum}[1]{%
\listval{#1}{0}%
\ifthenelse{\value{COOL@listpointer}=1}%
	{%
	H_{#1}
	}%
% Else If
{ \ifthenelse{\value{COOL@listpointer}=2}%
	{%
	\liststore{#1}{COOL@list@temp@}%
	H^{\inp{\COOL@list@temp@ii}}_{\COOL@list@temp@i}%
	}%
% Else
{%
	\PackageError{cool}{Invalid Argument}%
		{`Harm Num' can only accept a comma separated list of length 1 or 2}%
}}%	
}
%    \end{macrocode}
% \end{macro}
%
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% %  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %
% \subsubsection{Beta Functions}
% %  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% \begin{macro}{\Beta}
% \begin{tabular}{lll}
% Beta Function 			& |\Beta{a,b}|		& $\Beta{a,b}$		\\
% Incomplete Beta Function		& |\Beta{z,a,b}|	& $\Beta{z,a,b}$	\\
% Generalized Incomplete Beta Function	& |\Beta{z_1,z_2,a,b}|	& $\Beta{z_1,z_2,a,b}$
% \end{tabular}
%    \begin{macrocode}
	\newcommand{\COOL@notation@BetaParen}{p}
\newcommand{\Beta}[1]{%
\liststore{#1}{COOL@Beta@arg@}%
\listval{#1}{0}%
\ifthenelse{\value{COOL@listpointer} = 2}%
	{%
	B\COOL@decide@paren{Beta}{\COOL@Beta@arg@i, \COOL@Beta@arg@ii}%
	}%
% ElseIf
{ \ifthenelse{\value{COOL@listpointer} = 3}%
	{%
	B_{\COOL@Beta@arg@i}%
		\COOL@decide@paren{Beta}{\COOL@Beta@arg@ii, \COOL@Beta@arg@iii}%
	}%
% ElseIf
{ \ifthenelse{\value{COOL@listpointer} = 4}%
	{%
	B_{\inp{\COOL@Beta@arg@i,\COOL@Beta@arg@ii}}%
		\COOL@decide@paren{Beta}{\COOL@Beta@arg@iii, \COOL@Beta@arg@iv}%
	}%
% Else
	{%
	\PackageError{cool}{Invalid Argument}%
		{`Beta' can only accept a comma separated list of length 2 to 4}%
	}%
}}%
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\IncBeta}
% Incomplete Beta Function 
%
% \begin{tabular}{ll}
% |\IncBeta{z}{a}{b}|	& $\IncBeta{z}{a}{b}$	\\
% |\Beta{z,a,b}|	& $\Beta{z,a,b}$
% \end{tabular}
%    \begin{macrocode}
\newcommand{\IncBeta}[3]{\Beta{#1,#2, #3}}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\GenIncBeta}
% Generalized Incomplete Beta Function
%
% \begin{tabular}{ll}
% |\GenIncBeta{x}{y}{a}{b}|	& $\GenIncBeta{x}{y}{a}{b}$	\\
% |\Beta{x,y,a,b}|		& $\Beta{x,y,a,b}$
% \end{tabular}
%    \begin{macrocode}
\newcommand{\GenIncBeta}[4]{\Beta{#1,#2,#3,#4}}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\BetaRegularized}
% \begin{macro}{\BetaReg}
% \begin{macro}{\RegIncBeta}
% Regularized Incomplete Beta Function 
% 
% \begin{tabular}{ll}
% |\BetaRegularized{z,a,b}|	& $\BetaRegularized{z,a,b}$	\\
% |\BetaReg{z,a,b}|		& $\BetaReg{z,a,b}$		\\
% |\RegIncBeta{z}{a}{b}|	& $\RegIncBeta{z}{a}{b}$
% \end{tabular}
%    \begin{macrocode}
	\newcommand{\COOL@notation@BetaRegularizedParen}{p}
\newcommand{\BetaRegularized}[1]{%
\liststore{#1}{COOL@BetaRegularized@arg@}%
\listval{#1}{0}%
\ifthenelse{\value{COOL@listpointer} = 3}%
	{%
	I_{\COOL@BetaRegularized@arg@i}%
		\COOL@decide@paren{BetaRegularized}%
			{\COOL@BetaRegularized@arg@ii, \COOL@BetaRegularized@arg@iii}%
	}%
% ElseIf
{ \ifthenelse{\value{COOL@listpointer} = 4}%
	{%
	I_{\inp{\COOL@BetaRegularized@arg@i, \COOL@BetaRegularized@arg@ii}}%
		\COOL@decide@paren{BetaRegularized}%
			{\COOL@BetaRegularized@arg@iii, \COOL@BetaRegularized@arg@iv}%
	}%
% Else
	{%
	\PackageError{cool}{Invalid Argument}%
		{`BetaRegularized' can only accept%
		 a comma separated list of length 3 or 4}%
	}%
}%
}
\newcommand{\RegIncBeta}[3]{\BetaRegularized{#1,#2,#3}}
\newcommand{\BetaReg}[1]{\BetaRegularized{#1}}
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\InverseBetaRegularized}
% \begin{macro}{\BetaRegInv}
% \begin{macro}{\RegIncBetaInv}
% Inverse of Regularized Incomplete Beta Function
%
% \begin{tabular}{ll}
% |\InverseBetaRegularized{z,a,b}|	& $\InverseBetaRegularized{z,a,b}$	\\
% |\BetaRegInv{z,a,b}|			& $\BetaRegInv{z,a,b}$			\\
% |\RegIncBetaInv{z}{a}{b}|		& $\RegIncBetaInv{z}{a}{b}$
% \end{tabular}
%    \begin{macrocode}
	\newcommand{\COOL@notation@InverseBetaRegularizedParen}{p}
\newcommand{\InverseBetaRegularized}[1]{%
\liststore{#1}{COOL@InverseBetaRegularized@arg@}%
\listval{#1}{0}%
\ifthenelse{\value{COOL@listpointer} = 3}%
	{%
	I^{-1}_{\COOL@InverseBetaRegularized@arg@i}%
		\COOL@decide@paren{InverseBetaRegularized}%
			{\COOL@InverseBetaRegularized@arg@ii,%
			 \COOL@InverseBetaRegularized@arg@iii}%
	}%
% ElseIf
{ \ifthenelse{\value{COOL@listpointer} = 4}%
	{%
	I^{-1}_{\inp{	\COOL@InverseBetaRegularized@arg@i,%
			\COOL@InverseBetaRegularized@arg@ii%
		    }%
		}%
		\COOL@decide@paren{InverseBetaRegularized}%
			{\COOL@InverseBetaRegularized@arg@iii,%
			 \COOL@InverseBetaRegularized@arg@iv}%
	}%
% Else
	{%
	\PackageError{cool}{Invalid Argument}%
		{`InverseBetaRegularized' can only accept%
		 a comma separated list of length 3 or 4}%
	}%
}%
}
\newcommand{\RegIncBetaInv}[3]{\InverseBetaRegularized{#1,#2,#3}}
\newcommand{\BetaRegInv}[1]{\InverseBetaRegularized{#1}}
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\GenRegIncBeta}
% Generalized Regularized Incomplete Beta Func
%
% \begin{tabular}{ll}
% |\GenRegIncBeta{x}{y}{a}{b}|	& $\GenRegIncBeta{x}{y}{a}{b}$		\\
% |\Beta{x,y,a,b}|		& $\Beta{x,y,a,b}$
% \end{tabular}
%    \begin{macrocode}
\newcommand{\GenRegIncBeta}[4]{\Beta{#1,#2,#3,#4}}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\GenRegIncBetaInv}
% Inverse of Generalized Regularized Incomplete Beta Function
%
% \begin{tabular}{ll}
% |\GenRegIncBetaInv{x}{y}{z}{b}|	& $\GenRegIncBetaInv{x}{y}{z}{b}$		\\
% |\InverseBetaRegularized{x,y,z,b}|	& $\InverseBetaRegularized{x,y,z,b}$
% \end{tabular}
%    \begin{macrocode}
\newcommand{\GenRegIncBetaInv}[4]{\InverseBetaRegularized{#1,#2,#3,#4}}
%    \end{macrocode}
% \end{macro}
%
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% %  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %
% \subsubsection{Error Functions}
% %  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% \begin{macro}{\Erf}
% \begin{tabular}{lll}
% Error Function		& |\Erf{x}|		& $\Erf{x}$		\\
% Generalized Error Function	& |\Erf{x,y}|		& $\Erf{x,y}$
% \end{tabular}
%    \begin{macrocode}
	\newcommand{\COOL@notation@ErfParen}{p}
	\DeclareMathOperator{\ErfSymb}{erf}
\newcommand{\Erf}[1]{%
\liststore{#1}{COOL@Erf@arg@}%
\listval{#1}{0}%
\ifthenelse{\value{COOL@listpointer} = 1}%
	{%
	\ErfSymb\COOL@decide@paren{Erf}{#1}
	}%
% ElseIf
{ \ifthenelse{\value{COOL@listpointer} = 2}%
	{%
	\ErfSymb\COOL@decide@paren{Erf}{#1}
	}%
% Else
	{%
	\PackageError{cool}{Invalid Argument}%
		{`Erf' can only accept a comma separated list of length 1 or 2}%
	}%
}%
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\ErfInv}
% Inverse of Error Function
%
% \begin{tabular}{ll}
% |\ErfInv{x}|		& $\ErfInv{x}$		\\
% |\ErfInv{x,y}|	& $\ErfInv{x,y}$
% \end{tabular}
%    \begin{macrocode}
	\newcommand{\COOL@notation@ErfInvParen}{p}
\newcommand{\ErfInv}[1]{%
\liststore{#1}{COOL@Erf@arg@}%
\listval{#1}{0}%
\ifthenelse{\value{COOL@listpointer} = 1}%
	{%
	\ErfSymb^{-1}\COOL@decide@paren{ErfInv}{#1}
	}%
% ElseIf
{ \ifthenelse{\value{COOL@listpointer} = 2}%
	{%
	\ErfSymb^{-1}\COOL@decide@paren{ErfInv}{#1}
	}%
% Else
	{%
	\PackageError{cool}{Invalid Argument}%
		{`Erf' can only accept a comma separated list of length 1 or 2}%
	}%
}%
}
%    \end{macrocode}
% \end{macro}

%
% \begin{macro}{\GenErf}
% \begin{macro}{\GenErfInv}
% Generalized Error Function and its inverse
%
% \begin{tabular}{ll}
% |\GenErf{z_1}{z_2}|		& $\GenErf{z_1}{z_2}$	\\
% |\GenErfInv{z_1}{z_2}|	& $\GenErfInv{z_1}{z_2}$
% \end{tabular}
%    \begin{macrocode}
\newcommand{\GenErf}[2]{\Erf{#1,#2}}
\newcommand{\GenErfInv}[2]{\ErfInv{#1, #2}}
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\Erfc}
% Complimentary Error Function and its inverse
%
% \begin{tabular}{ll}
% |\Erfc{z}|		& $\Erfc{z}$ 		\\
% |\ErfcInv{z}|		& $\ErfcInv{z}$
% \end{tabular}
%    \begin{macrocode}
	\newcommand{\COOL@notation@ErfcParen}{p}
	\DeclareMathOperator{\ErfcSymb}{erfc}
\newcommand{\Erfc}[1]{\ErfcSymb\COOL@decide@paren{Erfc}{#1}}
	\newcommand{\COOL@notation@ErfcInvParen}{p}
\newcommand{\ErfcInv}[1]%
{\ErfcSymb^{-1}\COOL@decide@paren{ErfcInv}{#1}}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\Erfi}
% Imaginary Error Function, |\Erfi{z}|, $\Erfi{z}$
%    \begin{macrocode}
	\newcommand{\COOL@notation@ErfiParen}{p}
	\DeclareMathOperator{\ErfiSymb}{erfi}
\newcommand{\Erfi}[1]{\ErfiSymb\COOL@decide@paren{Erfi}{#1}}
%    \end{macrocode}
% \end{macro}
%
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% %  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %
% \subsubsection{Fresnel Integrals}
% %  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% \begin{macro}{\FresnelS}
% Fresnel Integral, |\FresnelS{z}|, $\FresnelS{z}$
%    \begin{macrocode}
	\newcommand{\COOL@notation@FresnelSParen}{p}
\newcommand{\FresnelS}[1]{S\COOL@decide@paren{FresnelS}{#1}}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\FresnelC}
% Fresnel Integral, |\FresnelC{z}|, $\FresnelC{z}$
%    \begin{macrocode}
	\newcommand{\COOL@notation@FresnelCParen}{p}
\newcommand{\FresnelC}[1]{C\COOL@decide@paren{FresnelC}{#1}}
%    \end{macrocode}
% \end{macro}
%
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% %  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %
% \subsubsection{Exponential Integrals}
% %  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% \begin{macro}{\ExpIntE}
% Exponential Integral, |\ExpIntE{\nu}{x}|, $\ExpIntE{\nu}{x}$
%    \begin{macrocode}
	\newcommand{\COOL@notation@ExpIntEParen}{p}
\newcommand{\ExpIntE}[2]{E_{#1}\COOL@decide@paren{ExpIntE}{#2}}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\ExpIntEi}
% Exponential Integral, |\ExpIntEi{x}|, $\ExpIntEi{x}$
%    \begin{macrocode}
	\newcommand{\COOL@notation@ExpIntEiParen}{p}
	\DeclareMathOperator{\ExpIntEiSymb}{Ei}
\newcommand{\ExpIntEi}[1]%
{\ExpIntEiSymb\COOL@decide@paren{ExpIntEi}{#1}}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\LogInt}
% Logarithmic Integral, |\LogInt{x}|, $\LogInt{x}$
%    \begin{macrocode}
	\newcommand{\COOL@notation@LogIntParen}{p}
	\DeclareMathOperator{\LogIntSymb}{li}
\newcommand{\LogInt}[1]{\LogIntSymb\COOL@decide@paren{LogInt}{#1}}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\SinInt}
% Sine Integral, |\SinInt{x}|, $\SinInt{x}$
%    \begin{macrocode}
	\newcommand{\COOL@notation@SinIntParen}{p}
	\DeclareMathOperator{\SinIntSymb}{Si}
\newcommand{\SinInt}[1]{\SinIntSymb\COOL@decide@paren{SinInt}{#1}}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\CosInt}
% Cosine Integral, |\CosInt{x}|, $\CosInt{x}$
%    \begin{macrocode}
	\newcommand{\COOL@notation@CosIntParen}{p}
	\DeclareMathOperator{\CosIntSymb}{Ci}
\newcommand{\CosInt}[1]{\CosIntSymb\COOL@decide@paren{CosInt}{#1}}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\SinhInt}
% Hyberbolic Sine Integral, |\SinhInt{x}|, $\SinhInt{x}$
%    \begin{macrocode}
	\newcommand{\COOL@notation@SinhIntParen}{p}
	\DeclareMathOperator{\SinhIntSymb}{Shi}
\newcommand{\SinhInt}[1]{\SinhIntSymb\COOL@decide@paren{SinhInt}{#1}}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\CoshInt}
% Hyberbolic Cosine Integral, |\CoshInt{x}|, $\CoshInt{x}$
%    \begin{macrocode}
	\newcommand{\COOL@notation@CoshIntParen}{p}
	\DeclareMathOperator{\CoshIntSymb}{Chi}
\newcommand{\CoshInt}[1]{\CoshIntSymb\COOL@decide@paren{CoshInt}{#1}}
%    \end{macrocode}
% \end{macro}
%
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% %  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %
% \subsubsection{Hypergeometric Functions}
% %  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% \begin{macro}{\COOL@Hypergeometric@pq@ab@value}
% This macro is a decision maker that decides what to return for the Hypergeometric function since
% its results vary based on the nature of the input.  This macro is called as
%
% |\COOL@Hypergeometric@pq@ab@value|
% \DeleteShortVerb{\|}%
% \verb|{|`p'\texttt{|}`q'\verb|}|%
% \marg{p\_input\textnormal{\texttt{|}}q\_input}%
% \verb|{|`a'\texttt{|}`b'\verb|}|%
% \marg{a\_input\textnormal{\texttt{|}}b\_input}%
% \MakeShortVerb{\|}
%    \begin{macrocode}
\newcommand{\COOL@Hypergeometric@pq@ab@value}[4]{%
\ifthenelse{\boolean{COOL@#1@isint} \AND \boolean{COOL@#3@islist}}%
	{% #1 is an INT and #3 is a LIST
	\ifthenelse{ #2 = 0 }%
		{%
		\PackageWarning{cool}{`#3'-arg ignored}%
		}%
	% Else
		{%
		\ifthenelse{ #2 = 1 }%
			{%
			\PackageError{cool}{`Hypergeometric' `#1'-arg mismatch with `#3'-arg}{}%
			}%
		% Else
			{%
			#4%
			}%
		}%
	}%
% Else
	{}%
\ifthenelse{	\boolean{COOL@#1@isint} \AND 
		\NOT \boolean{COOL@#3@islist}	 }%
	{%
	\ifthenelse{ #2 = 0 }%
		{%
		% return nothing
		}%
	% Else
		{%
		\ifthenelse{ #2 = 1 }%
			{%
			% return
			#4%
			}%
		% Else
			{%
			\forLoop{1}{#2}{COOL@ct}
				{% 
				\ifthenelse{ \value{COOL@ct} = 1 }{}{,}%
				#4_{\arabic{COOL@ct}}%
				}% end for loop
			}%
		}%
	}%
% else
	{}%
\ifthenelse{ 	\NOT \boolean{COOL@#1@isint} \AND 
		\boolean{COOL@#3@islist} 		}%
	{%
	\PackageError{cool}{Invalid Argument}%
		{`Hypergeometric': `#1'-arg is not int but `#3'-arg is list}
	}%
% else
	{}%
\ifthenelse{	\NOT \boolean{COOL@#1@isint} \AND 
		\NOT \boolean{COOL@#3@islist} 		}%
	{%
	%return
	#4_1,\ldots,#4_{#2}%
	}%
% else
	{}%
}%
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\Hypergeometric}
% Generalized Hypergeometric function. $\Hypergeometric{p}{q}{a}{b}{x}$
%
% \begin{tabular}{lr}
% |\Hypergeometric{0}{0}{}{}{x}|	& $\Hypergeometric{0}{0}{}{}{x}$	\\
% |\Hypergeometric{0}{1}{}{b}{x}|	& $\Hypergeometric{0}{1}{}{b}{x}$	\\
% |\Hypergeometric{1}{1}{a}{b}{x}|	& $\Hypergeometric{1}{1}{a}{b}{x}$	\\
% |\Hypergeometric{1}{1}{1}{1}{x}|	& $\Hypergeometric{1}{1}{1}{1}{x}$	\\
% |\Hypergeometric{3}{5}{a}{b}{x}|	\\
% 					\multicolumn{2}{r}{$\Hypergeometric{3}{5}{a}{b}{x}$}
%										\\
% |\Hypergeometric{3}{5}{1,2,3}{1,2,3,4,5}{x}|
%					\\
%					\multicolumn{2}{r}{$\Hypergeometric{3}{5}{1,2,3}{1,2,3,4,5}{x}$}
%										\\
% |\Hypergeometric{p}{5}{a}{b}{x}|	\\
%					\multicolumn{2}{r}{$\Hypergeometric{p}{5}{a}{b}{x}$}
%										\\
% |\Hypergeometric{p}{3}{a}{1,2,3}{x}|	\\
%					\multicolumn{2}{r}{$\Hypergeometric{p}{3}{a}{1,2,3}{x}$	}
%										\\
% |\Hypergeometric{p}{q}{a}{b}{x}|	\\
%					\multicolumn{2}{r}{$\Hypergeometric{p}{q}{a}{b}{x}$}
% \end{tabular}
%    \begin{macrocode}
	\newcommand{\COOL@notation@HypergeometricParen}{p}
	\newcommand{\COOL@notation@HypergeometricSymb}{F}
\newcommand{\Hypergeometric}[6][F]{%
\provideboolean{COOL@p@isint}%
\provideboolean{COOL@q@isint}%
\provideboolean{COOL@a@islist}%
\provideboolean{COOL@b@islist}%
\isint{#2}{COOL@isint}%
\ifthenelse{\boolean{COOL@isint}}%
	{\setboolean{COOL@p@isint}{true}}%
% Else
	{\setboolean{COOL@p@isint}{false}}%
\isint{#3}{COOL@isint}%
\ifthenelse{\boolean{COOL@isint}}%
	{\setboolean{COOL@q@isint}{true}}%
% Else
	{\setboolean{COOL@q@isint}{false}}%
\listval{#4}{0}%
\ifthenelse{\value{COOL@listpointer}>1}%
	{\setboolean{COOL@a@islist}{true}}%
% Else
	{\setboolean{COOL@a@islist}{false}}%
%    \end{macrocode}
% ensure that the submitted list is the same length as p
%    \begin{macrocode}
\ifthenelse{	\boolean{COOL@p@isint} \AND 
		\boolean{COOL@a@islist} \AND 
		\NOT \( #2 = \value{COOL@listpointer} \)	}%
	{%
	\PackageError{cool}{`Hypergeometric' `p'-arg mismatch with `a'-arg}{}%
	}%
% else
	{}%
\listval{#5}{0}%
\ifthenelse{\value{COOL@listpointer}>1}%
	{\setboolean{COOL@b@islist}{true}}%
% Else
	{\setboolean{COOL@b@islist}{false}}%
%    \end{macrocode}
% ensure that the submitted `b' list is the same length as q
%    \begin{macrocode}
\ifthenelse{	\boolean{COOL@q@isint} \AND 
		\boolean{COOL@b@islist} \AND 
		\NOT \( #3 = \value{COOL@listpointer} \)	}%
	{%
	\PackageError{cool}{`Hypergeometric' `q'-arg mismatch with `b'-arg}%
		{`b' list is not the same length as `q'}%
	}%
% else
	{}%
% troubleshoot
\ifthenelse{ \boolean{COOL@a@islist} \AND \NOT \boolean{COOL@p@isint} }%
	{%
	\PackageError{cool}{`Hypergeometric' `a'-arg mismatch with `p'-arg}%
		{happens if `a'-arg is a list and `p'-arg isn't an integer}%
	}%
% else
	{}%
\ifthenelse{ \boolean{COOL@b@islist} \AND \NOT \boolean{COOL@q@isint} }%
	{%
	\PackageError{cool}{`Hypergeometric' `b'-arg mismatch with `q'-arg}%
		{happens if `b'-arg is a list and `q'-arg isn't an integer}%
	}%
% else
	{}%
%    \end{macrocode}
% First print the ${}_p F_q$
%    \begin{macrocode}
{}_{#2}{\COOL@notation@HypergeometricSymb}_{#3}%
\COOL@decide@paren{Hypergeometric}%
	{%
	\COOL@Hypergeometric@pq@ab@value{p}{#2}{a}{#4};%
	\COOL@Hypergeometric@pq@ab@value{q}{#3}{b}{#5};%
	#6%
	}%
}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\RegHypergeometric}
% Regularized hypergeometric function $\RegHypergeometric{p}{q}{a}{b}{x}$ 
%    \begin{macrocode}
	\newcommand{\COOL@notation@RegHypergeometricParen}{p}
	\newcommand{\COOL@notation@RegHypergeometricSymb}{\tilde{F}}
\newcommand{\RegHypergeometric}[6][\tilde{F}]{%
\provideboolean{COOL@p@isint}%
\provideboolean{COOL@q@isint}%
\provideboolean{COOL@a@islist}%
\provideboolean{COOL@b@islist}%
\isint{#2}{COOL@isint}%
\ifthenelse{\boolean{COOL@isint}}%
	{\setboolean{COOL@p@isint}{true}}%
% Else
	{\setboolean{COOL@p@isint}{false}}%
\isint{#3}{COOL@isint}%
\ifthenelse{\boolean{COOL@isint}}%
	{\setboolean{COOL@q@isint}{true}}%
% Else
	{\setboolean{COOL@q@isint}{false}}%
\listval{#4}{0}%
\ifthenelse{\value{COOL@listpointer}>1}%
	{\setboolean{COOL@a@islist}{true}}%
% Else
	{\setboolean{COOL@a@islist}{false}}%
%    \end{macrocode}
% ensure that the submitted list is the same length as p
%    \begin{macrocode}
\ifthenelse{	\boolean{COOL@p@isint} \AND 
		\boolean{COOL@a@islist} \AND 
		\NOT \( #2 = \value{COOL@listpointer} \)	}%
	{%
	\PackageError{cool}%
		{`RegHypergeometric' `p'-arg mismatch with `a'-arg}{}%
	}%
% else
	{}%
\listval{#5}{0}%
\ifthenelse{\value{COOL@listpointer}>1}%
	{\setboolean{COOL@b@islist}{true}}%
% Else
	{\setboolean{COOL@b@islist}{false}}%
%    \end{macrocode}
% ensure that the submitted `b' list is the same length as q
%    \begin{macrocode}
\ifthenelse{	\boolean{COOL@q@isint} \AND 
		\boolean{COOL@b@islist} \AND 
		\NOT \( #3 = \value{COOL@listpointer} \)	}%
	{%
	\PackageError{cool}%
		{`RegHypergeometric' `q'-arg mismatch with `b'-arg}%
		{`b' list is not the same length as `q'}%
	}%
% else
	{}%
% troubleshoot
\ifthenelse{ \boolean{COOL@a@islist} \AND \NOT \boolean{COOL@p@isint} }%
	{%
	\PackageError{cool}%
		{`RegHypergeometric' `a'-arg mismatch with `p'-arg}%
		{happens if `a'-arg is a list and `p'-arg isn't an integer}%
	}%
% else
	{}%
\ifthenelse{ \boolean{COOL@b@islist} \AND \NOT \boolean{COOL@q@isint} }%
	{%
	\PackageError{cool}%
		{`RegHypergeometric' `b'-arg mismatch with `q'-arg}%
		{happens if `b'-arg is a list and `q'-arg isn't an integer}%
	}%
% else
	{}%
%    \end{macrocode}
% First print the ${}_p F_q$
%    \begin{macrocode}
{}_{#2}{\COOL@notation@RegHypergeometricSymb}_{#3}%
\COOL@decide@paren{RegHypergeometric}%
	{%
	\COOL@Hypergeometric@pq@ab@value{p}{#2}{a}{#4};%
	\COOL@Hypergeometric@pq@ab@value{q}{#3}{b}{#5};%
	#6%
	}%
}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\AppellFOne}
% Appell Hypergeometric Function 
%
% \begin{tabular}{ll}
% |\AppellFOne{a}{b_1,b_2}{c}{z_1,z_2}|		& $\AppellFOne{a}{b_1,b_2}{c}{z_1,z_2}$		\\
% \end{tabular}
%    \begin{macrocode}
	\newcommand{\COOL@notation@AppellFOneParen}{p}
\newcommand{\AppellFOne}[4]%
	{F_{1}\COOL@decide@paren{AppellFOne}{#1; #2; #3; #4}}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\HypergeometricU}
% Tricomi confluent hypergeometric function 
%
% \begin{tabular}{ll}
% |\HypergeometricU{a}{b}{z}|	& $\HypergeometricU{a}{b}{z}$ 		\\
% \end{tabular}
%    \begin{macrocode}
	\newcommand{\COOL@notation@HypergeometricUSymb}{U}
\newcommand{\HypergeometricU}[3]%
{\COOL@notation@HypergeometricUSymb\inp{#1, #2, #3}}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\COOL@MeijerG@anp@value}
% This macro is a decision maker for the |\MeijerG| macro.  Despite the name it is used for both $p$ and $q$.
% It is called as
%
% |\COOL@MeijerG@anp@value|
% \DeleteShortVerb{\|}
% \marg{a\textnormal{\texttt{|}}b}
% \marg{n\textnormal{\texttt{|}}m}
% \marg{p\textnormal{\texttt{|}}q}
% \MakeShortVerb{\|}
%    \begin{macrocode}
\newcommand{\COOL@MeijerG@anp@value}[3]{%
\isint{#3}{COOL@isint}%
\ifthenelse{\boolean{COOL@isint}}%
	{%
	\isint{#2}{COOL@isint}%
	\ifthenelse{\boolean{COOL@isint}}%
		{%
		\forLoop{1}{#3}{COOL@ct}%
			{%
			\ifthenelse{\value{COOL@ct}=1}{}{,}%
			#1_{\arabic{COOL@ct}}%
			}%
		}%
	% else
		{%
		#1_1,\ldots,#1_{#2},#1_{#2+1},\dots,#1_{#3}%
		}%
	}%
% else
	{%
	\isint{#2}{COOL@isint}%
	\ifthenelse{\boolean{COOL@isint}}%
		{%
		\forLoop{1}{#2}{COOL@ct}%
			{%
			\ifthenelse{\value{COOL@ct}=1}{}{,}%
			#1_{\arabic{COOL@ct}}%
			}%
		\setcounter{COOL@ct}{#2}%
		\addtocounter{COOL@ct}{1}%
		,#1_{\arabic{COOL@ct}}, \ldots, #1_{#3}%
		}%
	% else
		{%
		#1_1,\ldots,#1_{#2},#1_{#2+1},\dots,#1_{#3}%
		}%
	}%
}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\MeijerG}
% |\MeijerG{|$a_1, \ldots, a_n$|}{|$a_{n+1}, \ldots, a_p$|}{|$b_1, \ldots, b_m$|}{|$b_{m+1}, \ldots, b_q$|}|\marg{x}
%
% \noindent |\MeijerG[|\meta{a list symbol},\meta{b list symbol}|]|\marg{n}\marg{p}\marg{m}\marg{q}\marg{x}
%
% \noindent |\MeijerG[|\meta{a list symbol}|]|\marg{n}\marg{p}|{|$b_1, \ldots, b_m$|}{|$b_{m+1}, \ldots, b_q$|}|\marg{x}
%
% \noindent |\MeijerG[,|\meta{b list symbol}|]{|$a_1, \ldots, a_n$|}{|$a_{n+1}, \ldots, a_p$|}|\marg{m}\marg{q}\marg{x}
%
% \hspace{0.25cm}
%
% \begin{tabular}{c}
% Meijer $G$-Function
% \\
%	\begin{tabular}{ll}
%	|\MeijerG[a,b]{n}{p}{m}{q}{z}|		& $\MeijerG[a,b]{n}{p}{m}{q}{z}$		\\
%	\end{tabular}
% \\
% Meijer $G$-Function
% \\
%	\begin{tabular}{ll}
%	|\MeijerG{1,2}{3}{a,b}{c,d}{z}|		& $\MeijerG{1,2}{3}{a,b}{c,d}{z}$		\\
%	\end{tabular}
% \\
% Generalized Meijer $G$-Function
% \\
%	\begin{tabular}{ll}
%	|\MeijerG[a,b]{n}{p}{m}{q}{z,r}|	& $\MeijerG[a,b]{n}{p}{m}{q}{z,r}$		\\
%	\end{tabular}
% \\
% Generalized Meijer $G$-Function
% \\
%	\begin{tabular}{ll}
%	|\MeijerG{1,2}{3}{a,b}{c,d}{z,r}|	& $\MeijerG{1,2}{3}{a,b}{c,d}{z,r}$
%	\end{tabular}
% \end{tabular}
%    \begin{macrocode}
	\newcommand{\COOL@notation@MeijerGSymb}{G}
\newcommand{\MeijerG}[6][@,@]{%
\listval{#1}{0}
\ifthenelse{\value{COOL@listpointer}>2 \OR \value{COOL@listpointer}<1}%
	{%
	\PackageError{cool}{`MeijerG' Invalid Optional Argument}%
		{Must be a comma separated list of length 1 or 2}%
	}%
% else
	{%
	}%
\COOL@notation@MeijerGSymb%
\ifthenelse{\equal{#1}{@,@}}%
	{%
	\listval{#2}{0}% n
	\setcounter{COOL@ct}{\value{COOL@listpointer}}%
	\listval{#4}{0}% m
	\setcounter{COOL@ct@}{\value{COOL@listpointer}}%
	^{\arabic{COOL@ct@},\arabic{COOL@ct}}%
	\listval{#3}{0}% p - n
	\addtocounter{COOL@ct}{\value{COOL@listpointer}}%
	\listval{#5}{0}% q - m
	\addtocounter{COOL@ct@}{\value{COOL@listpointer}}%
	_{\arabic{COOL@ct},\arabic{COOL@ct@}}%
	\mathopen{}\left(%
		#6%
		\left|%
		{ {#2,#3} \@@atop {#4,#5} }%
	\right)\right.%
	}%
% else
	{%
	\listval{#1}{0}%
	\ifthenelse{\value{COOL@listpointer}=2}%
		{%
		\provideboolean{COOL@MeijerG@opt@one@blank}%
		\def\COOL@MeijerG@sniffer##1,##2\COOL@MeijerG@sniffer@end{%
			\ifthenelse{\equal{##1}{}}%
				{%
				\setboolean{COOL@MeijerG@opt@one@blank}{true}%
				}%
			% else
				{%
				\setboolean{COOL@MeijerG@opt@one@blank}{false}%
				}%
			}%
		\expandafter\COOL@MeijerG@sniffer#1\COOL@MeijerG@sniffer@end\relax%
		\ifthenelse{\boolean{COOL@MeijerG@opt@one@blank}}%
			{%
%    \end{macrocode}
% this is |\MeijerG[,b]{a_1,...,a_n}{a_{n++},...,a_p}{m}{q}{x}|
%    \begin{macrocode}
			\listval{#2}{0}% n
			\setcounter{COOL@ct}{\value{COOL@listpointer}}%
			^{#4,\arabic{COOL@ct}}%
			\listval{#3}{0}% p
			\addtocounter{COOL@ct}{\value{COOL@listpointer}}%
			_{\arabic{COOL@ct},#5}%
			\mathopen{}\left(%
			#6%
			\left|%
				{%
				{#2,#3} \@@atop {\COOL@MeijerG@anp@value{\listval{#1}{2}}{#4}{#5}}
				}%
			\right)\right.%
			}%
		% else
			{%
			^{#4,#2}_{#3,#5}%
			\mathopen{}\left(%
			#6%
			\left|%
			{%
				{\COOL@MeijerG@anp@value{\listval{#1}{1}}{#2}{#3}}%
				\@@atop%
				{\COOL@MeijerG@anp@value{\listval{#1}{2}}{#4}{#5}}
			}%
			\right)\right.%
			}%
		}%
	% else
		{%
%    \end{macrocode}
% this is| \MeijerG[a]{n}{p}{b_1,...,b_m}{b_{m++},...,a_p}{x}|
%    \begin{macrocode}
		\listval{#4}{0}% m
		\setcounter{COOL@ct}{\value{COOL@listpointer}}%
		^{\arabic{COOL@ct}, #2}%
		\listval{#5}{0}% q
		\addtocounter{COOL@ct}{\value{COOL@listpointer}}%
		_{#3, \arabic{COOL@ct}}%
		\mathopen{}\left(%
		#6%
		\left|%
			{%
			{\COOL@MeijerG@anp@value{#1}{#2}{#3}} \@@atop {#4,#5}
			}%
		\right)\right.%
		}%
	}%
}%
%    \end{macrocode}
% \end{macro}
%
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% %  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %
% \subsubsection{Angular Momentum Functions}
% %  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% \begin{macro}{\ClebschGordon}
% Clebsch-Gordon Coefficients
%
% \begin{tabular}{ll}
% |\ClebschGordon{j_1,m_1}{j_2,m_2}{j,m}|	& $\ClebschGordon{j_1,m_1}{j_2,m_2}{j,m}$	\\
% \end{tabular}
%
% \noindent \url{http://functions.wolfram.com/HypergeometricFunctions/ClebschGordan/}
%    \begin{macrocode}
\newcommand{\ClebschGordon}[3]{%
\listval{#1}{0}%
\ifthenelse{\NOT \value{COOL@listpointer}=2}%
	{%
	\PackageError{cool}{`ClebschGordon' Invalid Argument}%
		{Must have a comma separated list of length two}%
	}%
% else
	{}%
\listval{#2}{0}%
\ifthenelse{\NOT \value{COOL@listpointer}=2}%
	{%
	\PackageError{cool}{`ClebschGordon' Invalid Argument}%
		{Must have a comma separated list of length two}%
	}%
% else
	{}%
\listval{#3}{0}%
\ifthenelse{\NOT \value{COOL@listpointer}=2}%
	{%
	\PackageError{cool}{`ClebschGordon' Invalid Argument}%
		{Must have a comma separated list of length two}%
	}%
% else
	{}%
\left<%
	\listval{#1}{1},\listval{#2}{1};%
	\listval{#1}{2},\listval{#2}{2}%
	\left|%
	\listval{#1}{1},\listval{#2}{1};%
	\listval{#3}{1},\listval{#3}{2}%
\right>\right.%
}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\ThreeJSymbol}
% Wigner 3-j Symbol
%
% \begin{tabular}{ll}
% |\ThreeJSymbol{j_1,m_1}{j_2,m_2}{j_3,m_3}|	& $\ThreeJSymbol{j_1,m_1}{j_2,m_2}{j_3,m_3}$	\\
% \end{tabular}
%
% \noindent \url{http://functions.wolfram.com/HypergeometricFunctions/ThreeJSymbol/}
%    \begin{macrocode}
\newcommand{\ThreeJSymbol}[3]{%
\listval{#1}{0}%
\ifthenelse{\NOT \value{COOL@listpointer}=2}%
	{%
	\PackageError{cool}{`ThreeJSymbol' Invalid Argument}%
		{Must have comma separated list of length 2}%
	}%
% else
	{}%
\listval{#2}{0}%
\ifthenelse{\NOT \value{COOL@listpointer}=2}%
	{%
	\PackageError{cool}{`ThreeJSymbol' Invalid Argument}%
		{Must have comma separated list of length 2}%
	}%
% else
	{}%
\listval{#3}{0}%
\ifthenelse{\NOT \value{COOL@listpointer}=2}%
	{%
	\PackageError{cool}{`ThreeJSymbol' Invalid Argument}%
		{Must have comma separated list of length 2}%
	}%
% else
	{}%
\mathchoice{%
% displaystyle
\inp{\!%
	\begin{array}{ccc}%
	\listval{#1}{1}	& \listval{#2}{1}	& \listval{#3}{1}	\\%
	\listval{#1}{2}	& \listval{#2}{2}	& \listval{#3}{2}
	\end{array}%
     \!}%
	   }%
	   {%
% inline
\inp{\!%
	{\listval{#1}{1} \@@atop \listval{#1}{2}}%
	{\listval{#2}{1} \@@atop \listval{#2}{2}}%
	{\listval{#3}{1} \@@atop \listval{#3}{2}}%
     \!}%
	   }%
	   {%
% subscript
\inp{\!%
	{\listval{#1}{1} \@@atop \listval{#1}{2}}%
	{\listval{#2}{1} \@@atop \listval{#2}{2}}%
	{\listval{#3}{1} \@@atop \listval{#3}{2}}%
     \!}%
	   }%
	   {%
% subsubscript
\inp{\!%
	{\listval{#1}{1} \@@atop \listval{#1}{2}}%
	{\listval{#2}{1} \@@atop \listval{#2}{2}}%
	{\listval{#3}{1} \@@atop \listval{#3}{2}}%
     \!}%
	   }%
}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\SixJSymbol}
% Racah 6-j Symbol
%
% \begin{tabular}{ll}
% |\SixJSymbol{j_1,j_2,j_3}{j_4,j_5,j_6}|	& $\SixJSymbol{j_1,j_2,j_3}{j_4,j_5,j_6}$	\\
% \end{tabular}
%
% \url{http://functions.wolfram.com/HypergeometricFunctions/SixJSymbol/}
%    \begin{macrocode}
\newcommand{\SixJSymbol}[2]{%
\listval{#1}{0}%
\ifthenelse{\NOT \value{COOL@listpointer}=3}%
	{%
	\PackageError{cool}{`SixJSymbol' Invalid Argument}%
		{Must have a comma separated list of length 3}%
	}%
%else
	{}%
\listval{#2}{0}%
\ifthenelse{\NOT \value{COOL@listpointer}=3}%
	{%
	\PackageError{cool}{`SixJSymbol' Invalid Argument}%
		{Must have a comma separated list of length 3}%
	}%
%else
	{}%
\mathchoice{%
% displaystyle
\inbr{\!%
\begin{array}{ccc}%
\listval{#1}{1}	& \listval{#1}{2}	& \listval{#1}{3}	\\%
\listval{#2}{1}	& \listval{#2}{2}	& \listval{#2}{3}%
\end{array}%
     \!}%
	  }%
	  {%
% inline
\inbr{\!%
	{\listval{#1}{1} \@@atop \listval{#2}{1}}%
	{\listval{#1}{2} \@@atop \listval{#2}{2}}%
	{\listval{#1}{3} \@@atop \listval{#2}{3}}%
     \!}%
	  }%
	  {%
% superscript
\inbr{\!%
	{\listval{#1}{1} \@@atop \listval{#2}{1}}%
	{\listval{#1}{2} \@@atop \listval{#2}{2}}%
	{\listval{#1}{3} \@@atop \listval{#2}{3}}%
     \!}%
	  }%
	  {%
% supersuperscript
\inbr{\!%
	{\listval{#1}{1} \@@atop \listval{#2}{1}}%
	{\listval{#1}{2} \@@atop \listval{#2}{2}}%
	{\listval{#1}{3} \@@atop \listval{#2}{3}}%
     \!}%
	  }%
}
%    \end{macrocode}
% \end{macro}
%
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% %  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %
% \subsubsection{Complete Elliptic Integrals}
% %  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% \begin{macro}{\EllipticK}
% Complete Elliptic Integral of the First Kind 
%
% \begin{tabular}{ll}
% |\EllipticK{x}|	& $\EllipticK{x}$	\\
% \end{tabular}
%    \begin{macrocode}
	\newcommand{\COOL@notation@EllipticKParen}{p}
	\newcommand{\COOL@notation@EllipticKSymb}{K}
\newcommand{\EllipticK}[1]%
	{\COOL@notation@EllipticKSymb\COOL@decide@paren{EllipticK}{#1}}%
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\EllipticE}
% Complete Elliptic Integral of the Second Kind 
%
% \begin{tabular}{ll}
% |\EllipticE{x}|	& $\EllipticE{x}$	\\
% \end{tabular}
%    \begin{macrocode}
	\newcommand{\COOL@notation@EllipticEParen}{p}
	\newcommand{\COOL@notation@EllipticESymb}{E}
\newcommand{\EllipticE}[1]{%
\liststore{#1}{COOL@EllipticE@arg@}%
\listval{#1}{0}%
\ifthenelse{\value{COOL@listpointer} = 1}%
	{%
	\COOL@notation@EllipticESymb\COOL@decide@paren{EllipticE}{#1}%
	}%
% ElseIf
{ \ifthenelse{\value{COOL@listpointer} = 2}%
	{%
	\COOL@notation@EllipticESymb%
	\COOL@decide@paren{EllipticE}%
		{\COOL@EllipticE@arg@i \left| \, \COOL@EllipticE@arg@ii \!\!\right.}%
	}%
% Else
	{%
	\PackageError{Invalid Argument}%
		{`EllipticE' can only accept a comma separated list of length 1 or 2}%
	}%
}%
}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\EllipticPi}
% Complete Elliptic Integral of the Third Kind 
% 
% \begin{tabular}{ll}
% |\EllipticPi{n,m}| 	& $\EllipticPi{n,m}$	\\
% \end{tabular}
%    \begin{macrocode}
	\newcommand{\COOL@notation@EllipticPiParen}{p}
	\newcommand{\COOL@notation@EllipticPiSymb}{\Pi}
\newcommand{\EllipticPi}[1]{%
\liststore{#1}{COOL@EllipticPi@arg@}%
\listval{#1}{0}%
\ifthenelse{\value{COOL@listpointer} = 2}%
	{%
	\COOL@notation@EllipticPiSymb%
	\COOL@decide@paren{EllipticPi}%
		{\COOL@EllipticPi@arg@i \left| \, \COOL@EllipticPi@arg@ii \!\!\right.}%
	}%
% ElseIf
{ \ifthenelse{\value{COOL@listpointer} = 3}%
	{%
	\COOL@notation@EllipticPiSymb%
	\COOL@decide@paren{EllipticPi}%
		{	\COOL@EllipticPi@arg@i; \,%
			\COOL@EllipticPi@arg@ii \left| \,%
			\COOL@EllipticPi@arg@iii \!\!\right.%
		}%
	}%
% Else
	{%
	\PackageError{cool}{Invalid Argument}%
		{`EllipticPi' can only accept a comma separated list of length 2 or 3}%
	}%
}%
}
%    \end{macrocode}
% \end{macro}
%
%
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% %  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %
% \subsubsection{Incomplete Elliptic Integrals}
% %  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% \begin{macro}{\EllipticF}
% \begin{macro}{\IncEllipticF}
% Incomplete Elliptic Integral of the First Kind 
%
% \begin{tabular}{ll}
% |\EllipticF{z,m}|		& $\EllipticF{z,m}$ 		\\
% |\IncEllipticF{z}{m}|		& $\IncEllipticF{z}{m}$		\\
% \end{tabular}
%    \begin{macrocode}
	\newcommand{\COOL@notation@EllipticFParen}{p}
	\newcommand{\COOL@notation@EllipticFSymb}{F}
\newcommand{\EllipticF}[1]{%
\liststore{#1}{COOL@EllipticF@arg@}%
\listval{#1}{0}%
\ifthenelse{ \value{COOL@listpointer} = 2 }%
	{%
	\COOL@notation@EllipticFSymb%
	\COOL@decide@paren{EllipticF}%
		{\COOL@EllipticF@arg@i \left| \, \COOL@EllipticF@arg@ii \!\!\right.}%
	}%
% Else
	{%
	\PackageError{cool}{Invalid Argument}%
		{`EllipticF' can only accept a comma separated list of length 2}%
	}%
}
\newcommand{\IncEllipticF}[2]{\EllipticF{#1,#2}}
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
%
% \begin{macro}{\IncEllipticE}
% Incomplete Elliptic Integral of the Second Kind
%
% \begin{tabular}{ll}
% |\IncEllipticE{z}{m}|		& $\IncEllipticE{z}{m}$		\\
% |\EllipticE{z,m}|		& $\EllipticE{z,m}$
% \end{tabular}
%    \begin{macrocode}
\newcommand{\IncEllipticE}[2]{\EllipticE{#1,#2}}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\IncEllipticPi}
% \begin{macro}{\EllipticPi}
% Incomplete Elliptic Integral of the Third Kind
%
% \begin{tabular}{ll}
% |\IncEllipticPi{n}{z}{m}|	& $\IncEllipticPi{n}{z}{m}$		\\
% |\EllipticPi{n,z,m}|		& $\EllipticPi{n,z,m}$
% \end{tabular}
%    \begin{macrocode}
\newcommand{\IncEllipticPi}[3]{\EllipticPi{#1,#2,#3}}
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
%
% \begin{macro}{\JacobiZeta}
% Jacobi Zeta Function 
%
% \begin{tabular}{ll}
% |\JacobiZeta{z}{m}|	& $\JacobiZeta{z}{m}$	\\
% \end{tabular}
%    \begin{macrocode}
	\newcommand{\COOL@notation@JacobiZetaParen}{p}
	\newcommand{\COOL@notation@JacobiZetaSymb}{Z}
\newcommand{\JacobiZeta}[2]{%
\COOL@notation@JacobiZetaSymb
\COOL@decide@paren{JacobiZeta}{#1 \left| \, #2 \right.\!\!}%
}
%    \end{macrocode}
% \end{macro}
%
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% %  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %
% \subsubsection{Jacobi Theta Functions}
% %  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% \begin{macro}{\EllipticTheta}
% \begin{macro}{\JacobiTheta}
% Jacobi Theta Functions 
% 
% \begin{tabular}{ll}
% |\JacobiTheta{1}{z}{q}|	& $\JacobiTheta{1}{z}{q}$	\\
% |\JacobiTheta{2}{z}{q}|	& $\JacobiTheta{2}{z}{q}$	\\
% |\JacobiTheta{3}{z}{q}|	& $\JacobiTheta{3}{z}{q}$	\\
% |\JacobiTheta{4}{z}{q}|	& $\JacobiTheta{4}{z}{q}$	\\
% \end{tabular}
%    \begin{macrocode}
	\newcommand{\COOL@notation@EllipticThetaParen}{p}
\newcommand{\EllipticTheta}[3]%
	{\vartheta_{#1}\COOL@decide@paren{EllipticTheta}{#2, #3}}
\newcommand{\JacobiTheta}[3]{\EllipticTheta{#1}{#2}{#3}}
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
%
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% %  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %
% \subsubsection{Neville Theta Functions}
% %  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% \begin{macro}{\NevilleThetaC}
% Neville Theta Function, |\NevilleThetaC{z}{m}|, $\NevilleThetaC{z}{m}$
%    \begin{macrocode}
	\newcommand{\COOL@notation@NevilleThetaCParen}{p}
\newcommand{\NevilleThetaC}[2]{%
	\vartheta_{c}\COOL@decide@paren{NevilleThetaC}%
			{#1 \left| \, #2 \right.\!\!}%
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\NevilleThetaD}
% Neville Theta Function, |\NevilleThetaD{z}{m}|, $\NevilleThetaD{z}{m}$
%    \begin{macrocode}
	\newcommand{\COOL@notation@NevilleThetaDParen}{p}
\newcommand{\NevilleThetaD}[2]{%
	\vartheta_{d}\COOL@decide@paren{NevilleThetaD}%
			{#1 \left| \, #2 \right.\!\!}%
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\NevilleThetaN}
% Neville Theta Function, |\NevilleThetaN{z}{m}|, $\NevilleThetaN{z}{m}$
%    \begin{macrocode}
	\newcommand{\COOL@notation@NevilleThetaNParen}{p}
\newcommand{\NevilleThetaN}[2]{%
	\vartheta_{n}\COOL@decide@paren{NevilleThetaN}%
			{#1 \left| \, #2 \right.\!\!}%
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\NevilleThetaS}
% Neville Theta Function, |\NevilleThetaS{z}{m}|, $\NevilleThetaS{z}{m}$
%    \begin{macrocode}
	\newcommand{\COOL@notation@NevilleThetaSParen}{p}
\newcommand{\NevilleThetaS}[2]{%
	\vartheta_{s}\COOL@decide@paren{NevilleThetaS}%
			{#1 \left| \, #2 \right.\!\!}%
}
%    \end{macrocode}
% \end{macro}
%
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% %  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %
% \subsubsection{Weierstrass Functions}
% %  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% \begin{macro}{\WeierstrassP}
% \begin{macro}{\WeiP}
% Weierstrass Elliptic Function
%
% \begin{tabular}{ll}
% |\WeierstrassP{z}{g_2,g_3}|	& $\WeierstrassP{z}{g_2,g_3}$	\\
% |\WeiP{z}{g_2,g_3}|		& $\WeiP{z}{g_2,g_3}$		\\
% \end{tabular}
%    \begin{macrocode}
	\newcommand{\COOL@notation@WeierstrassPParen}{p}
\newcommand{\WeierstrassP}[2]{%
\liststore{#2}{COOL@WeiP@arg@g@}%
\listval{#2}{0}%
\ifthenelse{\NOT \value{COOL@listpointer} = 2}%
	{%
	\PackageError{cool}{Invalid Argument}%
		{`WeierstrassP' second argument must be%
		 a comma separated list of length 2}%
	}
% Else
	{%
	\wp\COOL@decide@paren{WeierstrassP}{#1; #2}
	}%
}
\newcommand{\WeiP}[2]{\WeierstrassP{#1}{#2}}
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\WeierstrassPInv}
% \begin{macro}{\WeiPInv}
% Inverse of Weierstrass Elliptic Function
%
% \begin{tabular}{lll}
% Inverse 		& |\WeiPInv{z}{g_2,g_3}|	& $\WeiPInv{z}{g_2,g_3}$
%														\\
% Generalized Inverse 	& |\WeiPInv{z_1,z_2}{g_2,g_3}|	& $\WeiPInv{z_1,z_2}{g_2,g_3}$
%														\\
% \end{tabular}
%    \begin{macrocode}
	\newcommand{\COOL@notation@WeierstrassPInvParen}{p}
\newcommand{\WeierstrassPInv}[2]{%
\liststore{#1}{COOL@WeiPinv@arg@z@}%
\liststore{#1}{COOL@WeiPinv@arg@g@}%
\listval{#2}{0}%
\ifthenelse{\NOT \value{COOL@listpointer} = 2}%
	{%
	\PackageError{cool}{Invalid Argument}%
		{`WeierstrassPInv' second argument must be%
		 a comma separated list of length 2}%
	}
% Else
	{
	\listval{#1}{0}%
	\ifthenelse{\value{COOL@listpointer} = 1}%
		{%
		\wp^{-1}\COOL@decide@paren{WeierstrassPInv}{#1; #2}%
		}%
	% ElseIf
	{ \ifthenelse{\value{COOL@listpointer} = 2}%
		{%
		\wp^{-1}\COOL@decide@paren{WeierstrassPInv}{#1; #2}%
		}%
	% Else
		{%
		\PackageError{cool}{Invalid Argument}%
			{`WeierstrassPInv' first argument must be%
			 a comma separate list of length 1 or 2}%
		}}%
	}%
}
\newcommand{\WeiPInv}[2]{\WeierstrassPInv{#1}{#2}}
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\WeierstrassPGenInv}
% Generalized Inverse of Weierstrass Elliptic Function
%
% |\WierstrassPGenInv{z_1}{z_2}{g_1}{g_2}|
%    \begin{macrocode}
\newcommand{\WeierstrassPGenInv}[4]{\WeierstrassPInv{#1,#2}{#3,#4}}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\WeierstrassSigma}
% \begin{macro}{\WeiSigma}
% Wierstrass Sigma Function
%
% \begin{tabular}{lll}
% Sigma			& |\WeierstrassSigma{z}{g_2,g_3}|	& $\WeierstrassSigma{z}{g_2,g_3}$	\\
% 			& |\WeiSigma{z}{g_2,g_3}|		& $\WeiSigma{z}{g_2,g_3}$		\\
% Associated Sigma	& |\WeierstrassSigma{n,z}{g_2,g_3}|	& $\WeierstrassSigma{n,z}{g_2,g_3}$	\\
% 			& |\WeiSigma{n,z}{g_2,g_3}|		& $\WeiSigma{n,z}{g_2,g_3}$		\\
% \end{tabular}
%    \begin{macrocode}
\newcommand{\WeierstrassSigma}[2]{%
\liststore{#1}{COOL@WeiSigma@arg@z@}%
\liststore{#2}{COOL@WeiSigma@arg@g@}%
\listval{#2}{0}%
\ifthenelse{\NOT \value{COOL@listpointer} = 2}
	{%
	\PackageError{cool}{Invalid Argument}%	
		{`WeierstrassSigma' second argument must be%
		 a comma separated list of length 2}%
	}%
% Else
	{%
	\listval{#1}{0}%
	\ifthenelse{\value{COOL@listpointer} = 1}%
		{%
		\sigma\inp{#1; #2}%
		}%
	% ElseIf
	{ \ifthenelse{\value{COOL@listpointer} = 2}%
		{%
		\sigma_{\COOL@WeiSigma@arg@z@i}\inp{\COOL@WeiSigma@arg@z@ii; #2}%
		}%
	% Else
		{%
		\PackageError{cool}{Invalid Argument}%
			{`WeierstrassSigma' first argument must be%
			 a comma separated list of length 1 or 2}%
		}}%
	}%
}
\newcommand{\WeiSigma}[2]{\WeierstrassSigma{#1}{#2}}
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\AssocWeierstrassSigma}
% Associated Weierstrass Sigma Function
%
% \begin{tabular}{ll}
% |\AssocWeierstrassSigma{n}{z}{g_2}{g_3}|	& $\AssocWeierstrassSigma{n}{z}{g_2}{g_3}$	\\
% |\WeiSigma{n,z}{g_2,g_3}|			& $\WeiSigma{n,z}{g_2,g_3}$
% \end{tabular}
%    \begin{macrocode}
\newcommand{\AssocWeierstrassSigma}[4]{\WeierstrassSigma{#1,#2}{#3,#4}}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\WeierstrassZeta}
% \begin{macro}{\WeiZeta}
% Weierstrass Zeta Function 
%
% \begin{tabular}{ll}
% |\WeierstrassZeta{z}{g_2,g_3}|	& $\WeierstrassZeta{z}{g_2,g_3}$	\\
% |\WeiZeta{z}{g_2,g_3}|		& $\WeiZeta{z}{g_2,g_3}$		\\
% \end{tabular}
%    \begin{macrocode}
	\newcommand{\COOL@notation@WeierstrassZetaParen}{p}%
\newcommand{\WeierstrassZeta}[2]{%
\listval{#2}{0}%
\ifthenelse{\NOT \value{COOL@listpointer} = 2}%
	{%
	\PackageError{cool}{Invalid Argument}%
		{`WeierstrassZeta' second argument must be%
		 a comma separated list of length 2}%
	}%
% Else
	{%
	\zeta\COOL@decide@paren{WeierstrassZeta}{#1; #2}%
	}%
}
\newcommand{\WeiZeta}[2]{\WeierstrassZeta{#1}{#2}}
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\WeierstrassHalfPeriods}
% \begin{macro}{\WeiHalfPeriods}
% Weierstrass half-periods 
%
% \begin{tabular}{ll}
% |\WeierstrassHalfPeriods{g_2,g_3}|	& $\WeierstrassHalfPeriods{g_2,g_3}$	\\
% |\WeiHalfPeriods{g_2,g_3}|		& $\WeiHalfPeriods{g_2,g_3}$		\\
% \end{tabular}
%    \begin{macrocode}
\newcommand{\WeierstrassHalfPeriods}[1]{%
\listval{#1}{0}%
\ifthenelse{\NOT \value{COOL@listpointer} = 2}%
	{%
	\PackageError{cool}{Invalid Argument}%
		{`WeierstrassHalfPeriods' can only accept%
		 a comma separated list of length 2}%
	}%
% Else
	{%
	\{ \omega_1\inp{#1}, \omega_3\inp{#1} \}%
	}%
}
\newcommand{\WeiHalfPeriods}[1]{\WeierstrassHalfPeriods{#1}}
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\WeierstrassInvariants}
% Weierstrass Invariants 
%
% \noindent
% \begin{tabular}{ll}
% |\WeierstrassInvariants{\omega_1,\omega_3}|	& $\WeierstrassInvariants{\omega_1,\omega_3}$	\\
% |\WeiInvars{\omega_1,\omega_3}|		& $\WeiInvars{\omega_1,\omega_3}$		\\
% \end{tabular}
%    \begin{macrocode}
\newcommand{\WeierstrassInvariants}[1]{%
\listval{#1}{0}%
\ifthenelse{\NOT \value{COOL@listpointer} = 2}%
	{%
	\PackageError{cool}{Invalid Argument}%
		{`WeierstrassInvariants' can only accept%
		 a comma separated list of length 2}%
	}%
% Else
	{%
	\{ g_2\inp{#1}, g_3\inp{#1} \}%
	}%
}
\newcommand{\WeiInvars}[1]{\WeierstrassInvariants{#1}}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\COOL@hideOnSF}
% Used to hide inputs or other when style is |sf|
%
% \begin{tabular}{ll}
% |sf|	& short form	\\
% |ff|	& full form
% \end{tabular}
%    \begin{macrocode}
	\newcommand{\COOL@hideOnSF}[2]
		{%
		\ifthenelse{ \equal{\csname COOL@notation@#1\endcsname}{sf} }%
			{}%
		% Else
			{#2}%
		}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\WeierstrassPHalfPeriodValues}
% \begin{macro}{\WeiPHalfPeriodVal}
% Weierstrass elliptic function values at half-periods 
%
% \begin{tabular}{c}
% |\Style{WeierstrassPHalfPeriodValuesDisplay=sf}| (Default)	\\
% |\WeierstrassPHalfPeriodValues{g_2,g_3}|			\\
% |\WeiPHalfPeriodVal{g_2,g_3}|					\\
% $\WeiPHalfPeriodVal{g_2,g_3}$					\\
%								\\
% |\Style{WeierstrassPHalfPeriodValuesDisplay=ff}|
% \Style{WeierstrassPHalfPeriodValuesDisplay=ff}%		\\
% |\WeierstrassPHalfPeriodValues{g_2,g_3}|			\\
% |\WeiPHalfPeriodVal{g_2,g_3}|					\\
% $\WeiPHalfPeriodVal{g_2,g_3}$
% \end{tabular}
%    \begin{macrocode}
	\newcommand{\COOL@notation@WeierstrassPHalfPeriodValuesDisplay}{sf}
\newcommand{\WeierstrassPHalfPeriodValues}[1]
{%
\listval{#1}{0}%
\ifthenelse{\NOT \value{COOL@listpointer} = 2}%
	{%
	\PackageError{cool}{Invalid Argument}%
		{`WeierstrassPHalfPeriodValues' can only accept%
		 a comma separated list of length 2}%
	}%
% Else
	{%
	\{ 	e_1\COOL@hideOnSF{WeierstrassPHalfPeriodValuesDisplay}{\inp{#1}},%
		e_2\COOL@hideOnSF{WeierstrassPHalfPeriodValuesDisplay}{\inp{#1}},%
		e_3\COOL@hideOnSF{WeierstrassPHalfPeriodValuesDisplay}{\inp{#1}}%
	\}%
	}%
}
\newcommand{\WeiPHalfPeriodVal}[1]{\WeierstrassPHalfPeriodValues{#1}}
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\WeierstrassZetaHalfPeriodValues}
% \begin{macro}{\WeiZetaHalfPeriodVal}
% Weierstrass zeta function values at half-periods
%
% \begin{tabular}{c}
% |\Style{WeierstrassZetaHalfPeriodValuesDisplay=sf}| (Default)	\\
% |\WeierstrassZetaHalfPeriodValues{g_2,g_3}|			\\
% |\WeiZetaHalfPeriodVal{g_2,g_3}|				\\
% $\WeiZetaHalfPeriodVal{g_2,g_3}$				\\
%								\\
% |\Style{WeierstrassZetaHalfPeriodValuesDisplay=ff}|
% \Style{WeierstrassZetaHalfPeriodValuesDisplay=ff}%		\\
% |\WeierstrassZetaHalfPeriodValues{g_2,g_3}|			\\
% |\WeiZetaHalfPeriodVal{g_2,g_3}|				\\
% $\WeiZetaHalfPeriodVal{g_2,g_3}$
% \end{tabular}
%    \begin{macrocode}
	\newcommand{\COOL@notation@WeierstrassZetaHalfPeriodValuesDisplay}{sf}
\newcommand{\WeierstrassZetaHalfPeriodValues}[1]
{%
\listval{#1}{0}%
\ifthenelse{\NOT \value{COOL@listpointer} = 2}%
	{%
	\PackageError{cool}{Invalid Argument}%
		{`WeierstrassZetaHalfPeriodValues' can only accept%
		 a comma separated list of length 2}%
	}%
% Else
	{%
	\{%
	\eta_1\COOL@hideOnSF%
		{WeierstrassZetaHalfPeriodValuesDisplay}{\inp{#1}},%
	\eta_2\COOL@hideOnSF%
		{WeierstrassZetaHalfPeriodValuesDisplay}{\inp{#1}},%
	\eta_3\COOL@hideOnSF%
		{WeierstrassZetaHalfPeriodValuesDisplay}{\inp{#1}}%
	\}%
	}%
}
\newcommand{\WeiZetaHalfPeriodVal}[1]%
	{\WeierstrassZetaHalfPeriodValues{#1}}
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% %  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %
% \subsubsection{Jacobi Functions}
% %  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% \begin{macro}{\JacobiAmplitude}
% Amplitude, |\JacobiAmplitude{z}{m}|, $\JacobiAmplitude{z}{m}$
%    \begin{macrocode}
	\newcommand{\COOL@notation@JacobiAmplitudeParen}{p}
	\DeclareMathOperator{\JacobiAmplitudeSymb}{am}
\newcommand{\JacobiAmplitude}[2]{%
\JacobiAmplitudeSymb\COOL@decide@paren%
	{JacobiAmplitude}{#1 \left| \, #2 \right.\!\!}%
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\JacobiCD}
% \begin{macro}{\JacobiCDInv}
% Jacobi elliptic function and its inverse
%
% \begin{tabular}{ll}
% |\JacobiCD{z}{m}|	& $\JacobiCD{z}{m}$ 	\\
% |\JacobiCDInv{z}{m}|	& $\JacobiCDInv{z}{m}$	\\
% \end{tabular}
%    \begin{macrocode}
	\newcommand{\COOL@notation@JacobiCDParen}{p}
	\newcommand{\COOL@notation@JacobiCDInvParen}{p}
	\DeclareMathOperator{\JacobiCDSymb}{cd}
\newcommand{\JacobiCD}[2]{%
\JacobiCDSymb\COOL@decide@paren%
	{JacobiCD}{#1 \left| \, #2 \right.\!\!}%
}
\newcommand{\JacobiCDInv}[2]{%
\JacobiCDSymb^{-1}\COOL@decide@paren%
	{JacobiCDInv}{#1 \left| \, #2 \right.\!\!}%
}
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\JacobiCN}
% \begin{macro}{\JacobiCNInv}
% Jacobi elliptic function and its inverse
%
% \begin{tabular}{ll}
% |\JacobiCN{z}{m}|	& $\JacobiCN{z}{m}$	\\
% |\JacobiCNInv{z}{m}|	& $\JacobiCNInv{z}{m}$	\\
% \end{tabular}
%    \begin{macrocode}
	\newcommand{\COOL@notation@JacobiCNParen}{p}
	\newcommand{\COOL@notation@JacobiCNInvParen}{p}
	\DeclareMathOperator{\JacobiCNSymb}{cn}
\newcommand{\JacobiCN}[2]{%
\JacobiCNSymb\COOL@decide@paren%
	{JacobiCN}{#1 \left| \, #2 \right.\!\!}%
}
\newcommand{\JacobiCNInv}[2]{%
\JacobiCNSymb^{-1}\COOL@decide@paren%
	{JacobiCNInv}{#1 \left| \, #2 \right.\!\!}%
}
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\JacobiCS}
% \begin{macro}{\JacobiCSInv}
% Jacobi elliptic function and its inverse
%
% \begin{tabular}{ll}
% |\JacobiCS{z}{m}|		& $\JacobiCS{z}{m}$ 		\\
% |\JacobiCSInv{z}{m}|		& $\JacobiCSInv{z}{m}$		\\
% \end{tabular}
%    \begin{macrocode}
	\newcommand{\COOL@notation@JacobiCSParen}{p}
	\newcommand{\COOL@notation@JacobiCSInvParen}{p}
	\DeclareMathOperator{\JacobiCSSymb}{cs}
\newcommand{\JacobiCS}[2]{%
\JacobiCSSymb\COOL@decide@paren%
	{JacobiCS}{#1 \left| \, #2 \right.\!\!}%
}
\newcommand{\JacobiCSInv}[2]{%
\JacobiCSSymb^{-1}\COOL@decide@paren%
	{JacobiCSInv}{#1 \left| \, #2 \right.\!\!}%
}
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\JacobiDC}
% \begin{macro}{\JacobiDCInv}
% Jacobi elliptic function and its inverse
%
% \begin{tabular}{ll}
% |\JacobiDC{z}{m}|		& $\JacobiDC{z}{m}$		\\
% |\JacobiDCInv{z}{m}|		& $\JacobiDCInv{z}{m}$		\\
% \end{tabular}
%    \begin{macrocode}
	\newcommand{\COOL@notation@JacobiDCParen}{p}
	\newcommand{\COOL@notation@JacobiDCInvParen}{p}
	\DeclareMathOperator{\JacobiDCSymb}{dc}
\newcommand{\JacobiDC}[2]{%
\JacobiDCSymb\COOL@decide@paren%
	{JacobiDC}{#1 \left| \, #2 \right.\!\!}%
}
\newcommand{\JacobiDCInv}[2]{%
\JacobiDCSymb^{-1}\COOL@decide@paren%
	{JacobiDCInv}{#1 \left| \, #2 \right.\!\!}%
}
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\JacobiDN}
% \begin{macro}{\JacobiDNInv}
% Jacobi elliptic function and its inverse
%
% \begin{tabular}{ll}
% |\JacobiDN{z}{m}|		& $\JacobiDN{z}{m}$ 		\\
% |\JacobiDNInv{z}{m}|		& $\JacobiDNInv{z}{m}$		\\
% \end{tabular}
%    \begin{macrocode}
	\newcommand{\COOL@notation@JacobiDNParen}{p}
	\newcommand{\COOL@notation@JacobiDNInvParen}{p}
	\DeclareMathOperator{\JacobiDNSymb}{dn}
\newcommand{\JacobiDN}[2]{%
\JacobiDNSymb\COOL@decide@paren%
	{JacobiDN}{#1 \left| \, #2 \right.\!\!}%
}
\newcommand{\JacobiDNInv}[2]{%
\JacobiDNSymb^{-1}\COOL@decide@paren%
	{JacobiDNInv}{#1 \left| \, #2 \right.\!\!}%
}
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\JacobiDS}
% \begin{macro}{\JacobiDSInv}
% Jacobi elliptic function and its inverse
%
% \begin{tabular}{ll}
% |\JacobiDS{z}{m}|		& $\JacobiDS{z}{m}$ 	\\
% |\JacobiDSInv{z}{m}|		& $\JacobiDSInv{z}{m}$	\\
% \end{tabular}
%    \begin{macrocode}
	\newcommand{\COOL@notation@JacobiDSParen}{p}
	\newcommand{\COOL@notation@JacobiDSInvParen}{p}
	\DeclareMathOperator{\JacobiDSSymb}{ds}
\newcommand{\JacobiDS}[2]{%
\JacobiDSSymb\COOL@decide@paren%
	{JacobiDS}{#1 \left| \, #2 \right.\!\!}%
}
\newcommand{\JacobiDSInv}[2]{%
\JacobiDSSymb^{-1}\COOL@decide@paren%
	{JacobiDSInv}{#1 \left| \, #2 \right.\!\!}%
}
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\JacobiNC}
% \begin{macro}{\JacobiNCInv}
% Jacobi elliptic function and its inverse
%
% \begin{tabular}{ll}
% |\JacobiNC{z}{m}|		& $\JacobiNC{z}{m}$ 		\\
% |\JacobiNCInv{z}{m}|		& $\JacobiNCInv{z}{m}$		\\
% \end{tabular}
%    \begin{macrocode}
	\newcommand{\COOL@notation@JacobiNCParen}{p}
	\newcommand{\COOL@notation@JacobiNCInvParen}{p}
	\DeclareMathOperator{\JacobiNCSymb}{nc}
\newcommand{\JacobiNC}[2]{%
\JacobiNCSymb\COOL@decide@paren%
	{JacobiNC}{#1 \left| \, #2 \right.\!\!}%
}
\newcommand{\JacobiNCInv}[2]{%
\JacobiNCSymb^{-1}\COOL@decide@paren%
	{JacobiNCInv}{#1 \left| \, #2 \right.\!\!}%
}
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\JacobiND}
% \begin{macro}{\JacobiNDinv}
% Jacobi elliptic function and its inverse
%
% \begin{tabular}{ll}
% |\JacobiND{z}{m}|		& $\JacobiND{z}{m}$ 		\\
% |\JacobiNDInv{z}{m}|		& $\JacobiNDInv{z}{m}$		\\
% \end{tabular}
%    \begin{macrocode}
	\newcommand{\COOL@notation@JacobiNDParen}{p}
	\newcommand{\COOL@notation@JacobiNDInvParen}{p}
	\DeclareMathOperator{\JacobiNDSymb}{nd}
\newcommand{\JacobiND}[2]{%
\JacobiNDSymb\COOL@decide@paren%
	{JacobiND}{#1 \left| \, #2 \right.\!\!}%
}
\newcommand{\JacobiNDInv}[2]{%
\JacobiNDSymb^{-1}\COOL@decide@paren%
	{JacobiNDInv}{#1 \left| \, #2 \right.\!\!}%
}
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\JacobiNS}
% \begin{macro}{\JacobiNSInv}
% Jacobi elliptic function and its inverse
%
% \begin{tabular}{ll}
% |\JacobiNS{z}{m}|		& $\JacobiNS{z}{m}$ 	\\
% |\JacobiNSInv{z}{m}|		& $\JacobiNSInv{z}{m}$	\\
% \end{tabular}
%    \begin{macrocode}
	\newcommand{\COOL@notation@JacobiNSParen}{p}
	\newcommand{\COOL@notation@JacobiNSInvParen}{p}
	\DeclareMathOperator{\JacobiNSSymb}{ns}
\newcommand{\JacobiNS}[2]{%
\JacobiNSSymb\COOL@decide@paren%
	{JacobiNS}{#1 \left| \, #2 \right.\!\!}%
}
\newcommand{\JacobiNSInv}[2]{%
\JacobiNSSymb^{-1}\COOL@decide@paren%
	{JacobiNSInv}{#1 \left| \, #2 \right.\!\!}%
}
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\JacobiSC}
% \begin{macro}{\JacobiSCInv}
% Jacobi elliptic function and its inverse
%
% \begin{tabular}{ll}
% |\JacobiSC{z}{m}|		& $\JacobiSC{z}{m}$		\\
% |\JacobiSCInv{z}{m}|		& $\JacobiSCInv{z}{m}$		\\
% \end{tabular}
%    \begin{macrocode}
	\newcommand{\COOL@notation@JacobiSCParen}{p}
	\newcommand{\COOL@notation@JacobiSCInvParen}{p}
	\DeclareMathOperator{\JacobiSCSymb}{sc}
\newcommand{\JacobiSC}[2]{%
\JacobiSCSymb\COOL@decide@paren%
	{JacobiSC}{#1 \left| \, #2 \right.\!\!}%
}
\newcommand{\JacobiSCInv}[2]{%
\JacobiSCSymb^{-1}\COOL@decide@paren%
	{JacobiSCInv}{#1 \left| \, #2 \right.\!\!}%
}
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\JacobiSD}
% \begin{macro}{\JacobiSDInv}
% Jacobi elliptic function and its inverse
%
% \begin{tabular}{ll}
% |\JacobiSD{z}{m}|		& $\JacobiSD{z}{m}$		\\
% |\JacobiSDInv{z}{m}|		& $\JacobiSDInv{z}{m}$		\\
% \end{tabular}
%    \begin{macrocode}
	\newcommand{\COOL@notation@JacobiSDParen}{p}
	\newcommand{\COOL@notation@JacobiSDInvParen}{p}
	\DeclareMathOperator{\JacobiSDSymb}{sd}
\newcommand{\JacobiSD}[2]{%
\JacobiSDSymb\COOL@decide@paren%
	{JacobiSD}{#1 \left| \, #2 \right.\!\!}%
}
\newcommand{\JacobiSDInv}[2]{%
\JacobiSDSymb^{-1}\COOL@decide@paren%
	{JacobiSDInv}{#1 \left| \, #2 \right.\!\!}%
}
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\JacobiSN}
% \begin{macro}{\JacobiSNInv}
% Jacobi elliptic function and its inverse
%
% \begin{tabular}{ll}
% |\JacobiSN{z}{m}|		& $\JacobiSN{z}{m}$		\\
% |\JacobiSNInv{z}{m}|		& $\JacobiSNInv{z}{m}$		\\
% \end{tabular}
%    \begin{macrocode}
	\newcommand{\COOL@notation@JacobiSNParen}{p}
	\newcommand{\COOL@notation@JacobiSNInvParen}{p}
	\DeclareMathOperator{\JacobiSNSymb}{sn}
\newcommand{\JacobiSN}[2]{%
\JacobiSNSymb\COOL@decide@paren%
	{JacobiSN}{#1 \left| \, #2 \right.\!\!}%
}
\newcommand{\JacobiSNInv}[2]{%
\JacobiSNSymb^{-1}\COOL@decide@paren%
	{JacobiSNInv}{#1 \left| \, #2 \right.\!\!}%
}
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% %  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %
% \subsubsection{Modular Functions}
% %  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% \begin{macro}{\DedekindEta}
% Dedekind eta modular function, |\DedekindEta{z}|, $\DedekindEta{z}$
%    \begin{macrocode}
	\newcommand{\COOL@notation@DedekindEtaParen}{p}
\newcommand{\DedekindEta}[1]{\eta\COOL@decide@paren{DedekindEta}{#1}}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\KleinInvariantJ}
% Klein invariant modular function, |\KleinInvariantJ{z}|, $\KleinInvariantJ{z}$
%    \begin{macrocode}
	\newcommand{\COOL@notation@KleinInvariantJParen}{p}
\newcommand{\KleinInvariantJ}[1]%
	{J\COOL@decide@paren{KleinInvariantJ}{#1}}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\ModularLambda}
% Modular lambda function, |\ModularLambda{z}|, $\ModularLambda{z}$
%    \begin{macrocode}
	\newcommand{\COOL@notation@ModularLambdaParen}{p}
\newcommand{\ModularLambda}[1]%
	{\lambda\COOL@decide@paren{ModularLambda}{#1}}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\EllipticNomeQ}
% \begin{macro}{\EllipticNomeQInv}
% Nome and its inverse
%
% \begin{tabular}{ll}
% |\EllipticNomeQ{m}|		& $\EllipticNomeQ{m}$		\\
% |\EllipticNomeQInv{m}|	& $\EllipticNomeQInv{m}$	\\
% \end{tabular}
%    \begin{macrocode}
	\newcommand{\COOL@notation@EllipticNomeQParen}{p}
	\newcommand{\COOL@notation@EllipticNomeQInvParen}{p}
\newcommand{\EllipticNomeQ}[1]%
	{q\COOL@decide@paren{EllipticNomeQ}{#1}}
\newcommand{\EllipticNomeQInv}[1]%
	{q^{-1}\COOL@decide@paren{EllipticNomeQ}{#1}}
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% %  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %
% \subsubsection{Arithmetic Geometric Mean}
% %  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% \begin{macro}{\ArithGeoMean}
% \begin{macro}{\AGM}
% Arithmetic Geometric Mean
%
% \begin{tabular}{ll}
% |\ArithGeoMean{a}{b}|		& $\ArithGeoMean{a}{b}$		\\
% |\AGM{a}{b}|			& $\AGM{a}{b}$			\\
% \end{tabular}
%    \begin{macrocode}
	\newcommand{\COOL@notation@ArithGeoMeanParen}{p}
	\DeclareMathOperator{\ArithGeoMeanSymb}{agm}
\newcommand{\ArithGeoMean}[2]%
	{\ArithGeoMeanSymb\COOL@decide@paren{ArithGeoMean}{#1, #2}}
\newcommand{\AGM}[2]{\ArithGeoMean{#1}{#2}}
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% %  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %
% \subsubsection{Elliptic Exp and Log}
% %  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% \begin{macro}{\EllipticExp}
% \begin{macro}{\EExp}
% Elliptic exponential
%
% \begin{tabular}{ll}
% |\EllipticExp{z}{a,b}|	& $\EllipticExp{z}{a,b}$	\\
% |\EExp{z}{a,b}|		& $\EExp{z}{a,b}$		\\
% \end{tabular}
%    \begin{macrocode}
	\newcommand{\COOL@notation@EllipticExpParen}{p}
	\DeclareMathOperator{\EllipticExpSymb}{eexp}
\newcommand{\EllipticExp}[2]{%
\liststore{#2}{COOL@EllipticExp@arg@}
\listval{#2}{0}%
\ifthenelse{\NOT \value{COOL@listpointer} = 2}%
	{%
	\PackageError{cool}{Invalid Argument}%
		{`EllipticExp' second argument must be
		 a comma separated list of length 2}%
	}%
% Else
	{%
	\EllipticExpSymb\COOL@decide@paren{EllipticExp}{#1; #2}%
	}%
}
\newcommand{\EExp}[2]{\EllipticExp{#1}{#2}}
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\EllipticLog}
% \begin{macro}{\ELog}
% Elliptic logarithm
%
% \begin{tabular}{ll}
% |\EllipticLog{z_1,z_2}{a,b}|	& $\EllipticLog{z_1,z_2}{a,b}$		\\
% |\ELog{z_1,z_2}{a,b}|		& $\ELog{z_1,z_2}{a,b}$			\\
% \end{tabular}
%    \begin{macrocode}
	\newcommand{\COOL@notation@EllipticLogParen}{p}
	\DeclareMathOperator{\EllipticLogSymb}{elog}
\newcommand{\EllipticLog}[2]{%
\liststore{#1}{COOL@EllipticLog@arg@z@}%
\liststore{#2}{COOL@EllipticLog@arg@a@}%
\listval{#1}{0}%
\ifthenelse{\NOT \value{COOL@listpointer} = 2}%
	{%
	\PackageError{cool}{Invalid Argument}%
		{`EllipticLog' first argument must be
		 a comma separated list of length 2}%
	}%
% Else
	{%
	\listval{#2}{0}%
	\ifthenelse{\NOT \value{COOL@listpointer} = 2}%
		{%
		\PackageError{cool}{Invalid Argument}%
			{`EllipticLog' second argument must be%
			 a comma separated list of length 2}%
		}%
	% Else
		{%
		\EllipticLogSymb\COOL@decide@paren{EllipticLog}{#1; #2}%
		}%
	}%
}
\newcommand{\ELog}[2]{\EllipticLog{#1}{#2}}
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% %  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %
% \subsubsection{Zeta Functions}
% %  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% \begin{macro}{\RiemannZeta}
% Riemann Zeta Function
%
% \begin{tabular}{ll}
% |\RiemannZeta{s}|	& $\RiemannZeta{s}$	\\
% |\Zeta{s}|		& $\Zeta{s}$
% \end{tabular}
%    \begin{macrocode}
\newcommand{\RiemannZeta}[1]{\Zeta{#1}}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\HurwitzZeta}
% Hurwitz Zeta Function 
%
% \begin{tabular}{ll}
% |\HurwitzZeta{s}{a}|	& $\HurwitzZeta{s}{a}$	\\
% |\Zeta{s,a}|		& $\Zeta{s,a}$
% \end{tabular}
%    \begin{macrocode}
\newcommand{\HurwitzZeta}[2]{\Zeta{#1,#2}}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\Zeta}
% Riemann and Hurwitz Zeta
%
% \begin{tabular}{lll}
% Riemann Zeta	& |\Zeta{s}|	& $\Zeta{s}$	\\
% Hurwitz Zeta	& |\Zeta{s,a}|	& $\Zeta{s,a}$
% \end{tabular}
%    \begin{macrocode}
	\newcommand{\COOL@notation@ZetaParen}{p}
\newcommand{\Zeta}[1]{%
\liststore{#1}{COOL@Zeta@arg@}%
\listval{#1}{0}% get the list length
\ifthenelse{\value{COOL@listpointer} = 2}%
	{%
	\zeta\COOL@decide@paren{Zeta}{\COOL@Zeta@arg@i,\COOL@Zeta@arg@ii}%
	}%
% else
	{%
	\ifthenelse{\value{COOL@listpointer} = 1}%
		{%
		\zeta\COOL@decide@paren{Zeta}{#1}%
		}%
	% else
		{%
		\PackageError{cool}{`Zeta' Invalid Argument}%
			{the Zeta function can only accept%
			 a comma deliminated list of length 1 or 2}
		}%
	}%
}%
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\RiemannSiegelTheta}
% Riemann-Siegel Theta Function, |\RiemannSiegelTheta{z}|, $\RiemannSiegelTheta{z}$
%    \begin{macrocode}
	\newcommand{\COOL@notation@RiemannSiegelThetaParen}{p}
\newcommand{\RiemannSiegelTheta}[1]%
	{\vartheta\COOL@decide@paren{RiemannSiegelTheta}{#1}}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\RiemannSiegelZ}
% Riemann-Siegel Z Function, |\RiemannSiegelZ{z}|, $\RiemannSiegelZ{z}$
%    \begin{macrocode}
	\newcommand{\COOL@notation@RiemannSiegelZParen}{p}
\newcommand{\RiemannSiegelZ}[1]%
	{Z\COOL@decide@paren{RiemannSiegelZ}{#1}}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\StieltjesGamma}
% Stieltjes Constant, |\StieltjesGamma{n}|, $\StieltjesGamma{n}$
%    \begin{macrocode}
\newcommand{\StieltjesGamma}[1]{\gamma_{#1}}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\LerchPhi}
% Lerch transcendent, |\LerchPhi{z}{s}{a}|, $\LerchPhi{z}{s}{a}$
%    \begin{macrocode}
	\newcommand{\COOL@notation@LerchPhiParen}{p}
\newcommand{\LerchPhi}[3]{\Phi\COOL@decide@paren{LerchPhi}{#1,#2,#3}}
%    \end{macrocode}
% \end{macro}
%
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% %  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %
% \subsubsection{Polylogarithms}
% %  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% \begin{macro}{\NielsenPolyLog}
% Nielsen Polylogarithm, |\NielsenPolyLog{\nu}{p}{z}|, $\NielsenPolyLog{\nu}{p}{z}$
%    \begin{macrocode}
	\newcommand{\COOL@notation@NielsenPolyLogParen}{p}
\newcommand{%
\NielsenPolyLog}[3]{S_{#1}^{#2}%
	\COOL@decide@paren{NielsenPolyLog}{#3}%
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\PolyLog}
% Polylogarithm
%
% \begin{tabular}{lll}
% Nielsen PolyLog	& |\PolyLog{\nu,p,z}|	& $\PolyLog{\nu,p,z}$		\\
% PolyLog		& |\PolyLog{\nu,z}|	& $\PolyLog{\nu,z}$		\\
% \end{tabular}
%    \begin{macrocode}
	\newcommand{\COOL@notation@PolyLogParen}{p}
	\DeclareMathOperator{\PolyLogSymb}{Li}
\newcommand{\PolyLog}[1]{%
\liststore{#1}{COOL@PolyLog@arg@}%
\listval{#1}{0}%
\ifthenelse{\value{COOL@listpointer} = 3}%
	{%
	\NielsenPolyLog{\COOL@PolyLog@arg@i}%
		{\COOL@PolyLog@arg@ii}{\COOL@PolyLog@arg@iii}%
	}%
% else
	{%
	\ifthenelse{ \value{COOL@listpointer} = 2 }%
		{%
		\PolyLogSymb_{\COOL@PolyLog@arg@i}%
			\COOL@decide@paren{PolyLog}{\COOL@PolyLog@arg@ii}%
		}%
	% else
		{%
		\PackageError{cool}{`PolyLog' Invalid Argument}%
			{This function returns either the Polylogarithm or the%
			 Nielsen Polylogarithm.  It therefore only accepts a comma%
			 deliminated list of length two or three (1 or 2 commas)}%
		}%
	}%
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\DiLog}
% Dilogarithm (alias for |\PolyLog{2,x}|); |\DiLog{x}|, $\DiLog{x}$
%    \begin{macrocode}
\newcommand{\DiLog}[1]{\PolyLog{2,#1}}
%    \end{macrocode}
% \end{macro}
%
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% %  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %
% \subsubsection{Mathieu Functions}
% %  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% \begin{macro}{\MathieuC}
% Even Mathieu Function, |\MathieuC{a}{q}{z}|, $\MathieuC{a}{q}{z}$
%    \begin{macrocode}
	\newcommand{\COOL@notation@MathieuCParen}{p}
	\DeclareMathOperator{\MathieuCSymb}{Ce}
\newcommand{\MathieuC}[3]%
	{\MathieuCSymb\COOL@decide@paren{MathieuC}{#1,#2,#3}}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\MathieuS}
% Odd Mathieu Function, |\MathieuS{a}{q}{z}|, $\MathieuS{a}{q}{z}$
%    \begin{macrocode}
	\newcommand{\COOL@notation@MathieuSParen}{p}
	\DeclareMathOperator{\MathieuSSymb}{Se}
\newcommand{\MathieuS}[3]%
	{\mathord{\MathieuSSymb}\COOL@decide@paren{MathieuS}{#1,#2,#3}}
%    \end{macrocode}
% \end{macro}
%
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% %  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %
% \subsubsection{Mathieu Characteristics}
% %  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% \begin{macro}{\MathieuCharacteristicA}
% \begin{macro}{\MathieuCharisticA}
% Characteristic Value of Even Mathieu Function 
%
% \begin{tabular}{ll}
% |\MathieuCharacteristicA{r}{q}|	& $\MathieuCharacteristicA{r}{q}$	\\
% |\MathieuCharisticA{r}{q}|		& $\MathieuCharisticA{r}{q}$		\\
% \end{tabular}
%    \begin{macrocode}
	\newcommand{\COOL@notation@MathieuCharacteristicAParen}{p}
\newcommand{\MathieuCharacteristicA}[2]%
	{a_{#1}\COOL@decide@paren{MathieuCharacteristicA}{#2}}
\newcommand{\MathieuCharisticA}[2]{\MathieuCharacteristicA{#1}{#2}}
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\MathieuCharacteristicB}
% \begin{macro}{\MathieuCharisticB}
% Characteristic Value of Even Mathieu Fucntion 
%
% \begin{tabular}{ll}
% |\MathieuCharacteristicB{r}{q}|	& $\MathieuCharacteristicB{r}{q}$	\\
% |\MathieuCharisticB{r}{q}|		& $\MathieuCharisticB{r}{q}$		\\
% \end{tabular}
%    \begin{macrocode}
	\newcommand{\COOL@notation@MathieuCharacteristicBParen}{p}
\newcommand{\MathieuCharacteristicB}[2]%
	{b_{#1}\COOL@decide@paren{MathieuCharacteristicB}{#2}}
\newcommand{\MathieuCharisticB}[2]{\MathieuCharacteristicB{#1}{#2}}
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\MathieuCharacteristicExponent}
% \begin{macro}{\MathieuCharisticExp}
% Characteristic Exponent of a Mathieu Fucntion
%
% \begin{tabular}{ll}
% |\MathieuCharateristicExponent{a}{q}|		& $\MathieuCharacteristicExponent{a}{q}$	\\
% |\MathieuCharisticExp{a}{q}|			& $\MathieuCharisticExp{a}{q}$			\\
% \end{tabular}
%    \begin{macrocode}
	\newcommand{\COOL@notation@MathieuCharacteristicExponentParen}{p}
\newcommand{\MathieuCharacteristicExponent}[2]%
	{r\COOL@decide@paren{MathieuCharacteristicExponent}{#1,#2}}
\newcommand{\MathieuCharisticExp}[2]%
	{\MathieuCharacteristicExponent{#1}{#2}}
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% %  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %
% \subsubsection{Complex variables}
% %  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% \begin{macro}{\Abs}
% Absolute value, |\Abs{z}|, $\Abs{z}$
%    \begin{macrocode}
\newcommand{\Abs}[1]{ \left|#1\right| }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\Arg}
% Argument, |\Arg{z}|, $\Arg{z}$
%    \begin{macrocode}
\newcommand{\Arg}[1]{ \arg\inp{#1} }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\Conjugate}
% \begin{macro}{\Conj}
% Complex Conjugate
%
% \begin{tabular}{ll}
% |\Conj{z}|		& $\Conj{z}$		\\
% |\Conjugate{z}|	& $\Conjugate{z}$	\\
% \end{tabular}
%    \begin{macrocode}
	\def\COOL@notation@Conjugate{star}
	\newcommand{\COOL@notation@ConjugateParen}{inv}
\newcommand{\Conjugate}[1]{\Conj{#1}}
\newcommand{\Conj}[1]{%
\ifthenelse{\equal{\COOL@notation@Conjugate}{bar}}%
	{%
	\bar{#1}%
	}%
% ElseIf
{ \ifthenelse{\equal{\COOL@notation@Conjugate}{overline}}%
	{%
	\overline{#1}%
	}%
% ElseIf
{ \ifthenelse{\equal{\COOL@notation@Conjugate}{star}}%
	{%
	\COOL@decide@paren{Conjugate}{#1}^*%
	}%
% Else
	{%
	\PackageError{cool}{Invalid Option Sent}%
		{`Conjugate' can only be set at `star', `bar', or `overline'}%
	}%
}}%
}
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\Real}
% Real Part, |\Real{z}|, $\Real{z}$
%    \begin{macrocode}
	\newcommand{\COOL@notation@RealParen}{none}
	\DeclareMathOperator{\RealSymb}{Re}
\newcommand{\Real}[1]{%
%    \end{macrocode}
% we put a space if there is no parentheses, or leave it out if there are
%    \begin{macrocode}
\ifthenelse{\equal{\COOL@notation@ImagParen}{none}}%
	{%
	\RealSymb{#1}%
	}%
% Else
	{%
	\RealSymb\COOL@decide@paren{Imag}{#1}%
	}%
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\Imag}
% Imaginary Part, |\Imag{z}|, $\Imag{z}$
%    \begin{macrocode}
	\newcommand{\COOL@notation@ImagParen}{none}
	\DeclareMathOperator{\ImagSymb}{Im}
\newcommand{\Imag}[1]{%
%    \end{macrocode}
% we put a space if there is no parentheses, or leave it out if there are
%    \begin{macrocode}
\ifthenelse{\equal{\COOL@notation@ImagParen}{none}}%
	{%
	\ImagSymb{#1}%
	}%
% Else
	{%
	\ImagSymb\COOL@decide@paren{Imag}{#1}%
	}%
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\Sign}
% Sign function, |\Sign{x}|, $\Sign{x}$
%    \begin{macrocode}
	\newcommand{\COOL@notation@SignParen}{p}
\newcommand{\Sign}[1]{\operatorname{sgn}\COOL@decide@paren{Sign}{#1}}
%    \end{macrocode}
% \end{macro}
%
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% %  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %
% \subsubsection{Number Theory Functions}
% %  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% \begin{macro}{\FactorInteger}
% \begin{macro}{\Factors}
% Prime decomposition, |\Factors{n}|, $\Factors{n}$
%    \begin{macrocode}
	\newcommand{\COOL@notation@FactorIntegerParen}{p}
	\DeclareMathOperator{\FactorIntegerSymb}{factors}
\newcommand{\FactorInteger}[1]%
	{\FactorIntegerSymb\COOL@decide@paren{FactorInteger}{#1}}
\newcommand{\Factors}[1]{\FactorInteger{#1}}
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\Divisors}
% Divisors, |\Divisors{n}|, $\Divisors{n}$
%    \begin{macrocode}
	\newcommand{\COOL@notation@DivisorsParen}{p}
	\DeclareMathOperator{\DivisorsSymb}{divisors}
\newcommand{\Divisors}[1]%
	{\mathord{\DivisorsSymb}\COOL@decide@paren{Divisors}{#1}}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\Prime}
% The $n$th Prime, |\Prime{n}|, $\Prime{n}$
%    \begin{macrocode}
	\newcommand{\COOL@notation@PrimeParen}{p}
	\DeclareMathOperator{\PrimeSymb}{prime}
\newcommand{\Prime}[1]%
	{\mathord{\PrimeSymb}\COOL@decide@paren{Prime}{#1}}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\PrimePi}
% Prime counting function, |\PrimePi{x}|, $\PrimePi{x}$
%    \begin{macrocode}
	\newcommand{\COOL@notation@PrimePiParen}{p}
\newcommand{\PrimePi}[1]{\pi\COOL@decide@paren{PrimePi}{#1}}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\DivisorSigma}
% Sum of divisor powers, |\DivisorSigma{k}{n}|, $\DivisorSigma{k}{n}$
%    \begin{macrocode}
	\newcommand{\COOL@notation@DivisorSigmaParen}{p}
\newcommand{\DivisorSigma}[2]%
	{\sigma_{#1}\COOL@decide@paren{DivisorSigma}{#2}}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\EulerPhi}
% Euler Totient Function, |\EulerPhi{x}|, $\EulerPhi{x}$
%    \begin{macrocode}
	\newcommand{\COOL@notation@EulerPhiParen}{p}
\newcommand{\EulerPhi}[1]{\varphi\COOL@decide@paren{EulerPhi}{#1}}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\MoebiusMu}
% Moebius Function, |\MoebiusMu{x}|, $\MoebiusMu{x}$
%    \begin{macrocode}
	\newcommand{\COOL@notation@MoebiusMuParen}{p}
\newcommand{\MoebiusMu}[1]{\mu\COOL@decide@paren{MoebiusMu}{#1}}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\JacobiSymbol}
% Jacobi Symbol, |\JacobiSymbol{n}{m}|, $\JacobiSymbol{n}{m}$
%    \begin{macrocode}
\newcommand{\JacobiSymbol}[2]{\inp{\frac{#1}{#2}}}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\CarmichaelLambda}
% Carmichael Lambda Function, |\CarmichaelLambda{x}|, $\CarmichaelLambda{x}$
%    \begin{macrocode}
	\newcommand{\COOL@notation@CarmichaelLambdaParen}{p}
\newcommand{\CarmichaelLambda}[1]%
	{\lambda\COOL@decide@paren{CarmichaelLambda}{#1}}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\DigitCount}
% Count the digits of an integer n for a given base b
%
% \begin{tabular}{c}
% |\DigitCount{n}{b}|		\\
% $\DigitCount{n}{b}$		\\
% \end{tabular}
%    \begin{macrocode}
\newcommand{\DigitCount}[2]{%
\isint{#2}{COOL@isint}%
\ifthenelse{\boolean{COOL@isint}}%
	{%
	\{%
	\setcounter{COOL@ct@}{#2}%
	\addtocounter{COOL@ct@}{-1}%
	\forLoop{1}{\arabic{COOL@ct@}}{COOL@ct}%
		{%
		s^{\arabic{COOL@ct}}_{#2}\inp{#1},
		}%
	s^{\inp{0}}_{#2}\inp{#1}%
	\}%
	}%
% else
	{%
	\{%
		s^{\inp{1}}_{#2}\inp{#1},%
		s^{\inp{2}}_{#2}\inp{#1},%
		\ldots,%
		s^{\inp{#2} - 1}_{#2}\inp{#1},%
		s^{\inp{0}}_{#2}\inp{#1}%
	\}%
	}%
}
%    \end{macrocode}
% \end{macro}
%
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% %  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %
% \subsubsection{Generalized Functions}
% %  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% \begin{macro}{\DiracDelta}
% Dirac Delta Function, |\DiracDelta{x}|, $\DiracDelta{x}$
%    \begin{macrocode}
	\newcommand{\COOL@notation@DiracDeltaParen}{p}
\newcommand{\DiracDelta}[1]{\delta\COOL@decide@paren{DiracDelta}{#1}}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\HeavisideStep}
% \begin{macro}{\UnitStep}
% Heaviside Step Function
%
% \begin{tabular}{ll}
% |\HeavisideStep{x}|		& $\HeavisideStep{x}$	\\
% |\UnitStep{x}|		& $\UnitStep{x}$	\\
% \end{tabular}
%    \begin{macrocode}
	\newcommand{\COOL@notation@HeavisideStepParen}{p}
\newcommand{\HeavisideStep}[1]%
	{\theta\COOL@decide@paren{HeavisideStep}{#1}}
\newcommand{\UnitStep}[1]{\HeavisideStep{#1}}
%    \end{macrocode}
% \end{macro}
% \end{macro}
% 
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %
% \subsubsection{Calculus}
% %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% \begin{macro}{\COOL@notation@DDisplayFunc}
% \begin{macro}{\COOL@notation@DShorten}
% Both |\D| and |\pderiv| are controlled by these keys.
%
% |DDisplayFunc| controls how the function is displayed, it can take the values:
%
% \begin{tabular}{ll}
% inset 	& Display as $\frac{d f}{d x}$		\\
% outset	& Display as $\frac{d}{d x} f$
% \end{tabular}
%
% |DShorten| is for multiple derivatives.  it can take the values
%
% \begin{tabular}{ll}
% true		& force derivatives to be consolidated, as in $\frac{d^2}{dx dy} f$		\\
% false		& expand derivatives as in $\frac{d}{dx} \frac{d}{dx} f$
% \end{tabular}
%
%    \begin{macrocode}
	\newcounter{COOL@multideriv}
	\newcommand{\COOL@notation@DDisplayFunc}{inset}
	\newcommand{\COOL@notation@DShorten}{true}
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\COOL@derivative}
% Both |\D| and |pderiv| have the same basic operation, so a macro is defined that does the internals
%
% |\COOL@derivative{|\meta{derivative power(s)}|}{|\meta{function}|}{|\meta{wrt}|}{|\meta{symbol}|}|
%
% \meta{wrt} is a comma separated list of length $\ge$ 1.
%
% \meta{symbol} is passed by |\D| or |\pderiv| and is |\COOL@notation@DSymb| or `$\partial$' respectively
%
% \begin{tabular}{ll}
% |\COOL@derivative{2,3}{f}{x,y,z}{d}| 		& \makeatletter 
%						  $\COOL@derivative{2,3}{f}{x,y,z}{d}$
%						  \makeatother
%						  \vspace{.15cm}
% \\
% |\COOL@derivative{2,3,4,5}{f}{x,y,z}{d}| 	& \makeatletter 
%						  $\COOL@derivative{2,3,4,5}{f}{x,y,z}{d}$
%						  \makeatother
%						  \vspace{.15cm}
% \\
% |\COOL@derivative{2,n,1}{f}{x,y,z}{d}| 	& \makeatletter
%						  $\COOL@derivative{2,n,1}{f}{x,y,z}{d}$
%						  \makeatother
%						  \vspace{.15cm}
% \\
% |\COOL@derivative{2,n}{f}{x,y,z}{d}| 		& \makeatletter
%						  $\COOL@derivative{2,n}{f}{x,y,z}{d}$
%						  \makeatother
% \\
% \\
% |\Style{DDisplayFunc=outset}| \Style{DDisplayFunc=outset}
% \\
% |\COOL@derivative{2,n}{f}{x,y,z}{d}|		& \makeatletter 
%						  $\COOL@derivative{2,n}{f}{x,y,z}{d}$
%						  \makeatother
% \\
% \\
% |\Style{DShorten=false,DDisplayFunc=inset}| \Style{DShorten=false}\Style{DDisplayFunc=inset}
% \\
% |\COOL@derivative{2,n}{f}{x,y,z}{d}| 		& \makeatletter
%						  $\COOL@derivative{2,n}{f}{x,y,z}{d}$
%						  \makeatother
%						  \vspace{.15cm}
% \\
% |\COOL@derivative{2,3,4,5}{f}{x,y,z}{d}|	& \makeatletter
%						  $\COOL@derivative{2,3,4,5}{f}{x,y,z}{d}$
%						  \makeatother
% \\
% \\
% |\Style{DShorten=false,DDisplayFunc=outset}| \Style{DShorten=false}\Style{DDisplayFunc=outset}
% \\
% |\COOL@derivative{2,n}{f}{x,y,z}{d}|		& \makeatletter
%						  $\COOL@derivative{2,n}{f}{x,y,z}{d}$
%						  \makeatother
% \end{tabular}
%    \begin{macrocode}
	\newcommand{\COOL@notation@DSymb}{d}
\newcommand{\COOL@derivative}[4]{%
%    \end{macrocode}
% Get the length of \meta{wrt} argument.
% |\listval{#3}{0}| gives the length of the list since lists begin indexing at 1.
%    \begin{macrocode}
\listval{#3}{0}%
\setcounter{COOL@listlen}{\value{COOL@listpointer}}%
%    \end{macrocode}
% Store the \meta{wrt} list and get the length of \meta{derivative power(s)}.
%    \begin{macrocode}
\liststore{#3}{COOL@deriv@wrt@}%
\listval{#1}{0}%
\setcounter{COOL@ct}{\value{COOL@listpointer}}%
\ifthenelse{\value{COOL@ct}>\value{COOL@listlen}}%
	{\setcounter{COOL@ct}{\value{COOL@listlen}}}{}%
\liststore{#1}{COOL@deriv@powers@}%
%    \end{macrocode}
% Check to see if all of the powers are integers---if they are, then we may sum them in the usual sense
%    \begin{macrocode}
\isint{\COOL@deriv@powers@i}{COOL@isint}%
\setcounter{COOL@multideriv}{2}%
\whiledo{	\boolean{COOL@isint} \AND 
		\NOT \value{COOL@multideriv}>\value{COOL@ct}	 }%
	{%
	\def\COOL@tempd%
		{\csname COOL@deriv@powers@\roman{COOL@multideriv}\endcsname}%
	\isint{\COOL@tempd}{COOL@isint}%
	\stepcounter{COOL@multideriv}%
	}%
%    \end{macrocode}
% If the length of \meta{derivative power(s)} is less than the length of \meta{wrt}, then we assume that 
% the last value applies to \emph{all} the remaining derivatives.
%
%^^A ==================================================================================================================
%^^A ============================================ BEGIN SHORTEN AND INSET =============================================
%^^A ==================================================================================================================
%    \begin{macrocode}
\ifthenelse{	\equal{\COOL@notation@DShorten}{true} \AND 
		\equal{\COOL@notation@DDisplayFunc}{inset}	}%
	{%
	\ifthenelse{ \boolean{COOL@isint} }%
		{%
		\def\COOL@temp@D@bot{}%
		\setcounter{COOL@ct@}{0}%
		\forLoop{1}{\value{COOL@ct}}{COOL@multideriv}%
			{%
			\edef\COOL@power@temp%
				{\csname COOL@deriv@powers@\roman{COOL@multideriv}\endcsname}%
			\edef\COOL@wrt@temp%
				{\csname COOL@deriv@wrt@\roman{COOL@multideriv}\endcsname}%
			\addtocounter{COOL@ct@}{\COOL@power@temp}%
			\ifthenelse{ \value{COOL@multideriv}=1 }{}%
				{\edef\COOL@temp@D@bot{\COOL@temp@D@bot \,}}%
			\ifthenelse{ \equal{\COOL@power@temp}{1} }%
				{%
				\edef\COOL@temp@D@bot%
					{\COOL@temp@D@bot {#4} \COOL@wrt@temp}%
				}%
			% Else
				{%
				\edef\COOL@temp@D@bot%
					{\COOL@temp@D@bot {#4} \COOL@wrt@temp^\COOL@power@temp}%
				}%
			}%
%    \end{macrocode}
% we're done with the length of the \meta{derivative power(s)} argument, and we want to start at it $+ \; 1$
% to add the remainders
%    \begin{macrocode}
		\ifthenelse{\value{COOL@ct}<\value{COOL@listlen}}%
			{%
			\edef\COOL@power@temp%
				{\csname COOL@deriv@powers@\roman{COOL@ct}\endcsname}%
			\stepcounter{COOL@ct}%
			\forLoop{\value{COOL@ct}}{\value{COOL@listlen}}{COOL@multideriv}%
				{%
				\edef\COOL@wrt@temp%
					{\csname COOL@deriv@wrt@\roman{COOL@multideriv}\endcsname}%
				\addtocounter{COOL@ct@}{\COOL@power@temp}%
				\ifthenelse{ \value{COOL@multideriv}=1 }{}%
					{\edef\COOL@temp@D@bot{\COOL@temp@D@bot \,}}%
				\ifthenelse{ \equal{\COOL@power@temp}{1} }%
					{%
					\edef\COOL@temp@D@bot%
						{\COOL@temp@D@bot {#4} \COOL@wrt@temp}%
					}%
				% Else
					{%
					\edef\COOL@temp@D@bot%
						{\COOL@temp@D@bot {#4} \COOL@wrt@temp^\COOL@power@temp}%
					}%
				}%
			}%
		% Else
			{}%
		\ifthenelse{\value{COOL@ct@}=1}%
			{%
			\frac{{#4} #2}{\COOL@temp@D@bot}%
			}%
		% Else
			{%
			\frac{{#4}^{\arabic{COOL@ct@}} #2}{\COOL@temp@D@bot}%
			}%
		}%
	% Else
		{%
%    \end{macrocode}
% Powers are not all Integers
%    \begin{macrocode}
		\edef\COOL@temp@D@bot{}%
		\def\COOL@temp@D@top@power{}%
		\forLoop{1}{\value{COOL@ct}}{COOL@multideriv}%
			{%
			\edef\COOL@power@temp%
				{\csname COOL@deriv@powers@\roman{COOL@multideriv}\endcsname}%
			\edef\COOL@wrt@temp%
				{\csname COOL@deriv@wrt@\roman{COOL@multideriv}\endcsname}%
			\ifthenelse{ \value{COOL@multideriv} = 1}%
				{%
				\edef\COOL@temp@D@top@power{\COOL@power@temp}%
				}%
			% Else
				{%
				\edef\COOL@temp@D@top@power%
					{\COOL@temp@D@top@power + \COOL@power@temp}%
				\edef\COOL@temp@D@bot{\COOL@temp@D@bot \,}%
				}%
			\ifthenelse{ \equal{\COOL@power@temp}{1} }%
				{%
				\edef\COOL@temp@D@bot%
					{\COOL@temp@D@bot {#4} \COOL@wrt@temp}%
				}%
			% Else
				{%
				\edef\COOL@temp@D@bot%
					{\COOL@temp@D@bot {#4} \COOL@wrt@temp^\COOL@power@temp}%
				}%
			}%
%    \end{macrocode}
% we're done with the length of the \meta{derivative power(s)} argument, and we want to start at it $+ \; 1$
% to add the remainders
%    \begin{macrocode}
		\ifthenelse{\value{COOL@ct}<\value{COOL@listlen}}%
			{%
			\edef\COOL@power@temp%
				{\csname COOL@deriv@powers@\roman{COOL@ct}\endcsname}%
			\stepcounter{COOL@ct}%
			\forLoop{\value{COOL@ct}}{\value{COOL@listlen}}{COOL@multideriv}%
				{%
				\edef\COOL@wrt@temp%
					{\csname COOL@deriv@wrt@\roman{COOL@multideriv}\endcsname}%
				\ifthenelse{ \value{COOL@multideriv} = 1}%
					{%
					\edef\COOL@temp@D@top@power{\COOL@power@temp}%
					}%
				% Else
					{%
					\edef\COOL@temp@D@top@power%
						{\COOL@temp@D@top@power + \COOL@power@temp}%
					\edef\COOL@temp@D@bot{\COOL@temp@D@bot \,}%
					}%
				\ifthenelse{ \equal{\COOL@power@temp}{1} }%
					{%
					\edef\COOL@temp@D@bot%
						{\COOL@temp@D@bot {#4} \COOL@wrt@temp}%
					}%
				% Else
					{%
					\edef\COOL@temp@D@bot%
						{\COOL@temp@D@bot {#4} \COOL@wrt@temp^\COOL@power@temp}%
					}%
				}%
			}%
		% Else
			{}%
		\frac{{#4}^{\COOL@temp@D@top@power} #2}{\COOL@temp@D@bot}%
		}%
	}%
%    \end{macrocode}
%^^A ==================================================================================================================
%^^A ============================================= END SHORTEN AND INSET ==============================================
%^^A ==================================================================================================================
%
%^^A ==================================================================================================================
%^^A ============================================ BEGIN SHORTEN AND OUTSET ============================================
%^^A ==================================================================================================================
%    \begin{macrocode}
% Else If
{ \ifthenelse{	\equal{\COOL@notation@DShorten}{true} \AND 
		\equal{\COOL@notation@DDisplayFunc}{outset}	 }%
	{%
	\ifthenelse{ \boolean{COOL@isint} }%
		{%
		\def\COOL@temp@D@bot{}%
		\setcounter{COOL@ct@}{0}%
		\forLoop{1}{\value{COOL@ct}}{COOL@multideriv}%
			{%
			\edef\COOL@power@temp%
				{\csname COOL@deriv@powers@\roman{COOL@multideriv}\endcsname}%
			\edef\COOL@wrt@temp%
				{\csname COOL@deriv@wrt@\roman{COOL@multideriv}\endcsname}%
			\addtocounter{COOL@ct@}{\COOL@power@temp}%
			\ifthenelse{ \value{COOL@multideriv}=1 }{}%
				{\edef\COOL@temp@D@bot{\COOL@temp@D@bot \,}}%
			\ifthenelse{ \equal{\COOL@power@temp}{1} }%
				{%
				\edef\COOL@temp@D@bot%
					{\COOL@temp@D@bot {#4} \COOL@wrt@temp}%
				}%
			% Else
				{%
				\edef\COOL@temp@D@bot%
					{\COOL@temp@D@bot {#4} \COOL@wrt@temp^\COOL@power@temp}%
				}%
			}%
%    \end{macrocode}
% we're done with the length of the \meta{derivative power(s)} argument, and we want to start at it $+ \; 1$
% to add the remainders
%    \begin{macrocode}
		\ifthenelse{\value{COOL@ct}<\value{COOL@listlen}}%
			{%
			\edef\COOL@power@temp%
				{\csname COOL@deriv@powers@\roman{COOL@ct}\endcsname}%
			\stepcounter{COOL@ct}%
			\forLoop{\value{COOL@ct}}{\value{COOL@listlen}}{COOL@multideriv}%
				{%
				\edef\COOL@wrt@temp%
					{\csname COOL@deriv@wrt@\roman{COOL@multideriv}\endcsname}%
				\addtocounter{COOL@ct@}{\COOL@power@temp}%
				\ifthenelse{ \value{COOL@multideriv}=1 }{}%
					{\edef\COOL@temp@D@bot{\COOL@temp@D@bot \,}}%
				\ifthenelse{ \equal{\COOL@power@temp}{1} }%
					{%
					\edef\COOL@temp@D@bot%
						{\COOL@temp@D@bot {#4} \COOL@wrt@temp}%
					}%
				% Else
					{%
					\edef\COOL@temp@D@bot%
						{\COOL@temp@D@bot {#4} \COOL@wrt@temp^\COOL@power@temp}%
					}%
				}%
			}%
		% Else
			{}%
		\ifthenelse{\value{COOL@ct@}=1}%
			{%
			\frac{#4}{\COOL@temp@D@bot} #2%
			}%
		% Else
			{%
			\frac{{#4}^{\arabic{COOL@ct@}}}{\COOL@temp@D@bot} #2%
			}%
		}%
	% Else
		{%
%    \end{macrocode}
% Powers are not all Integers
%    \begin{macrocode}
		\edef\COOL@temp@D@bot{}%
		\def\COOL@temp@D@top@power{}%
		\forLoop{1}{\value{COOL@ct}}{COOL@multideriv}%
			{%
			\edef\COOL@power@temp%
				{\csname COOL@deriv@powers@\roman{COOL@multideriv}\endcsname}%
			\edef\COOL@wrt@temp%
				{\csname COOL@deriv@wrt@\roman{COOL@multideriv}\endcsname}%
			\ifthenelse{ \value{COOL@multideriv} = 1}%
				{%
				\edef\COOL@temp@D@top@power{\COOL@power@temp}%
				}%
			% Else
				{%
				\edef\COOL@temp@D@top@power%
					{\COOL@temp@D@top@power + \COOL@power@temp}%
				\edef\COOL@temp@D@bot{\COOL@temp@D@bot \,}%
				}%
			\ifthenelse{ \equal{\COOL@power@temp}{1} }%
				{%
				\edef\COOL@temp@D@bot%
					{\COOL@temp@D@bot {#4} \COOL@wrt@temp}%
				}%
			% Else
				{%
				\edef\COOL@temp@D@bot%
					{\COOL@temp@D@bot {#4} \COOL@wrt@temp^\COOL@power@temp}%
				}%
			}%
%    \end{macrocode}
% we're done with the length of the \meta{derivative power(s)} argument, and we want to start at it $+ \; 1$
% to add the remainders
%    \begin{macrocode}
		\ifthenelse{\value{COOL@ct}<\value{COOL@listlen}}%
			{%
			\edef\COOL@power@temp%
				{\csname COOL@deriv@powers@\roman{COOL@ct}\endcsname}%
			\stepcounter{COOL@ct}%
			\forLoop{\value{COOL@ct}}{\value{COOL@listlen}}{COOL@multideriv}%
				{%
				\edef\COOL@wrt@temp%
					{\csname COOL@deriv@wrt@\roman{COOL@multideriv}\endcsname}%
				\ifthenelse{ \value{COOL@multideriv} = 1}%
					{%
					\edef\COOL@temp@D@top@power{\COOL@power@temp}%
					}%
				% Else
					{%
					\edef\COOL@temp@D@top@power%
						{\COOL@temp@D@top@power + \COOL@power@temp}%
					\edef\COOL@temp@D@bot{\COOL@temp@D@bot \,}%
					}%
				\ifthenelse{ \equal{\COOL@power@temp}{1} }%
					{%
					\edef\COOL@temp@D@bot%
						{\COOL@temp@D@bot {#4} \COOL@wrt@temp}%
					}%
				% Else
					{%
					\edef\COOL@temp@D@bot%
						{\COOL@temp@D@bot {#4} \COOL@wrt@temp^\COOL@power@temp}%
					}%
				}%
			}%
		% Else
			{}%
		\frac{{#4}^{\COOL@temp@D@top@power} }{\COOL@temp@D@bot} #2%
		}%
	}%
%    \end{macrocode}
%^^A ==================================================================================================================
%^^A ============================================= END SHORTEN AND OUTSET =============================================
%^^A ==================================================================================================================
%
%^^A ==================================================================================================================
%^^A =========================================== BEGIN NO SHORTEN AND INSET ===========================================
%^^A ==================================================================================================================
%    \begin{macrocode}
% Else If
{ \ifthenelse{	\equal{\COOL@notation@DShorten}{false} \AND
		\equal{\COOL@notation@DDisplayFunc}{inset}	}%
	{%
	\def\COOL@temp@D@result{}%
	\def\COOL@temp@D@bot{}%
	\def\COOL@temp@D@top{}%
	\setcounter{COOL@ct@}{\value{COOL@ct}}%
	\addtocounter{COOL@ct@}{-1}
	\forLoop{1}{\value{COOL@ct@}}{COOL@multideriv}%
		{%
		\edef\COOL@power@temp%
			{\csname COOL@deriv@powers@\roman{COOL@multideriv}\endcsname}%
		\edef\COOL@wrt@temp%
			{\csname COOL@deriv@wrt@\roman{COOL@multideriv}\endcsname}%
		\ifthenelse{ \equal{\COOL@power@temp}{1} }%
			{%
			\edef\COOL@temp@D@top{#4}%
			\edef\COOL@temp@D@bot{{#4} \COOL@wrt@temp}%
			}%
		% Else
			{%
			\edef\COOL@temp@D@top{{#4}^\COOL@power@temp}%
			\edef\COOL@temp@D@bot{{#4} \COOL@wrt@temp^\COOL@power@temp}%
			}%
		\edef\COOL@temp@D@result%
			{\COOL@temp@D@result \frac{\COOL@temp@D@top}{\COOL@temp@D@bot}}%
		}%
%    \end{macrocode}
% we're done with the length of the \meta{derivative power(s)} argument, and we want to start at it $+ \; 1$
% to add the remainders
%    \begin{macrocode}
	\ifthenelse{\value{COOL@ct}<\value{COOL@listlen}}%
		{%
%    \end{macrocode}
% Must pick up the one for |\value{COOL@ct}|
%    \begin{macrocode}
		\edef\COOL@power@temp%
			{\csname COOL@deriv@powers@\roman{COOL@ct}\endcsname}%
		\edef\COOL@wrt@temp%
			{\csname COOL@deriv@wrt@\roman{COOL@ct}\endcsname}%
		\ifthenelse{ \equal{\COOL@power@temp}{1} }%
			{%
			\edef\COOL@temp@D@top{#4}%
			\edef\COOL@temp@D@bot{{#4} \COOL@wrt@temp}%
			}%
		% Else
			{%
			\edef\COOL@temp@D@top{{#4}^\COOL@power@temp}%
			\edef\COOL@temp@D@bot{{#4} \COOL@wrt@temp^\COOL@power@temp}%
			}%
		\edef\COOL@temp@D@result%
			{\COOL@temp@D@result \frac{\COOL@temp@D@top}{\COOL@temp@D@bot}}%
%    \end{macrocode}
% Now add the ones beyond 
%    \begin{macrocode}
		\stepcounter{COOL@ct}%
		\setcounter{COOL@ct@}{\value{COOL@listlen}}%
		\addtocounter{COOL@ct@}{-1}%
		\forLoop{\value{COOL@ct}}{\value{COOL@ct@}}{COOL@multideriv}%
			{%
			\ifthenelse{ \equal{\COOL@power@temp}{1} }%
				{%
				\edef\COOL@temp@D@top{#4}%
				\edef\COOL@temp@D@bot{{#4} \COOL@wrt@temp}%
				}%
			% Else
				{%
				\edef\COOL@temp@D@top{{#4}^\COOL@power@temp}%
				\edef\COOL@temp@D@bot{{#4} \COOL@wrt@temp^\COOL@power@temp}%
				}%
			\edef\COOL@temp@D@result%
				{\COOL@temp@D@result \frac{\COOL@temp@D@top}{\COOL@temp@D@bot}}%
			}%
%    \end{macrocode}
% Must pick up the one for |\value{COOL@listlen}|
%    \begin{macrocode}
		\edef\COOL@wrt@temp%
			{\csname COOL@deriv@wrt@\roman{COOL@listlen}\endcsname}%
		\ifthenelse{ \equal{\COOL@power@temp}{1} }%
			{%
			\edef\COOL@temp@D@top{#4}%
			\edef\COOL@temp@D@bot{{#4} \COOL@wrt@temp}%
			}%
		% Else
			{%
			\edef\COOL@temp@D@top{{#4}^\COOL@power@temp}%
			\edef\COOL@temp@D@bot{{#4} \COOL@wrt@temp^\COOL@power@temp}%
			}%
		\edef\COOL@temp@D@result%
			{\COOL@temp@D@result \frac{\COOL@temp@D@top #2}{\COOL@temp@D@bot}}%
		}%
	% Else
		{%
%    \end{macrocode}
% Must pick up the one for |\value{COOL@ct}|
%    \begin{macrocode}
		\edef\COOL@power@temp%
			{\csname COOL@deriv@powers@\roman{COOL@ct}\endcsname}%
		\edef\COOL@wrt@temp%
			{\csname COOL@deriv@wrt@\roman{COOL@ct}\endcsname}%
		\ifthenelse{ \equal{\COOL@power@temp}{1} }%
			{%
			\edef\COOL@temp@D@top{#4}%
			\edef\COOL@temp@D@bot{{#4} \COOL@wrt@temp}%
			}%
		% Else
			{%
			\edef\COOL@temp@D@top{{#4}^\COOL@power@temp}%
			\edef\COOL@temp@D@bot{{#4} \COOL@wrt@temp^\COOL@power@temp}%
			}%
		\edef\COOL@temp@D@result%
			{\COOL@temp@D@result \frac{\COOL@temp@D@top #2}{\COOL@temp@D@bot}}%
		}%
	\COOL@temp@D@result%
	}%
%    \end{macrocode}
%^^A ==================================================================================================================
%^^A ============================================ END NO SHORTEN AND INSET ============================================
%^^A ==================================================================================================================
%
%^^A ==================================================================================================================
%^^A =========================================== BEGIN NO SHORTEN AND OUTSET ==========================================
%^^A ==================================================================================================================
%    \begin{macrocode}
% Else If
{ \ifthenelse{	\equal{\COOL@notation@DShorten}{false} \AND 
		\equal{\COOL@notation@DDisplayFunc}{outset}	}%
	{%
	\def\COOL@temp@D@result{}%
	\def\COOL@temp@D@bot{}%
	\def\COOL@temp@D@top{}%
	\forLoop{1}{\value{COOL@ct}}{COOL@multideriv}%
		{%
		\edef\COOL@power@temp%
			{\csname COOL@deriv@powers@\roman{COOL@multideriv}\endcsname}%
		\edef\COOL@wrt@temp%
			{\csname COOL@deriv@wrt@\roman{COOL@multideriv}\endcsname}%
		\ifthenelse{ \equal{\COOL@power@temp}{1} }%
			{%
			\edef\COOL@temp@D@top{#4}%
			\edef\COOL@temp@D@bot{{#4} \COOL@wrt@temp}%
			}%
		% Else
			{%
			\edef\COOL@temp@D@top{{#4}^\COOL@power@temp}%
			\edef\COOL@temp@D@bot{{#4} \COOL@wrt@temp^\COOL@power@temp}%
			}%
		\edef\COOL@temp@D@result%
			{\COOL@temp@D@result \frac{\COOL@temp@D@top}{\COOL@temp@D@bot}}%
		}%
%    \end{macrocode}
% we're done with the length of the \meta{derivative power(s)} argument, and we want to start at it $+ \; 1$
% to add the remainders
%    \begin{macrocode}
	\ifthenelse{\value{COOL@ct}<\value{COOL@listlen}}%
		{%
		\edef\COOL@power@temp%
			{\csname COOL@deriv@powers@\roman{COOL@ct}\endcsname}%
		\stepcounter{COOL@ct}%
		\forLoop{\value{COOL@ct}}{\value{COOL@listlen}}{COOL@multideriv}%
			{%
			\edef\COOL@wrt@temp%
				{\csname COOL@deriv@wrt@\roman{COOL@multideriv}\endcsname}%
			\ifthenelse{ \equal{\COOL@power@temp}{1} }%
				{%
				\edef\COOL@temp@D@top{#4}%
				\edef\COOL@temp@D@bot{{#4} \COOL@wrt@temp}%
				}%
			% Else
				{%
				\edef\COOL@temp@D@top{{#4}^\COOL@power@temp}%
				\edef\COOL@temp@D@bot{{#4} \COOL@wrt@temp^\COOL@power@temp}%
				}%
			\edef\COOL@temp@D@result%
				{\COOL@temp@D@result \frac{\COOL@temp@D@top}{\COOL@temp@D@bot}}%
			}%
		}%
	% Else
		{%
		}%
	\COOL@temp@D@result #2
	}%
%    \end{macrocode}
%^^A ==================================================================================================================
%^^A ============================================ END NO SHORTEN AND OUTSET ===========================================
%^^A ==================================================================================================================
%    \begin{macrocode}
% Else
	{%
	\PackageError{cool}{Invalid Option Sent}%
		{DShorten can only be `true' or `false';%
		 DDisplayFunc can only be `inset' or `outset'}%
	}%
}}}%
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\D}
% \begin{macro}{\pderiv}
% Derivatives
%
% \begin{tabular}{ll}
% |\Style{DSymb={\mathrm d}}|	\Style{DSymb={\mathrm d}}			\\
% |\D{f}{x}|			& \vspace{0.15cm}$\D{f}{x}$			\\
% |\D[n]{f}{x}|			& \vspace{0.15cm}$\D[n]{f}{x}$			\\
% |\D{f}{x,y,z}|		& \vspace{0.15cm}$\D{f}{x,y,z}$			\\
% |\D[1,2,1]{f}{x,y,z}|		& \vspace{0.15cm}$\D[1,2,1]{f}{x,y,z}$		\\
% |\pderiv{f}{x}|		& \vspace{0.15cm}$\pderiv{f}{x}$		\\
% |\pderiv[n]{f}{x}|		& \vspace{0.15cm}$\pderiv[n]{f}{x}$		\\
% |\pderiv{f}{x,y,z}|		& \vspace{0.15cm}$\pderiv{f}{x,y,z}$		\\
% |\pderiv[1,2,1]{f}{x,y,z}|	& \vspace{0.15cm}$\pderiv[1,2,1]{f}{x,y,z}$	\\
% \end{tabular}
%    \begin{macrocode}
\newcommand{\D}[3][1]{\COOL@derivative{#1}{#2}{#3}{{\COOL@notation@DSymb}}}
\newcommand{\pderiv}[3][1]{\COOL@derivative{#1}{#2}{#3}{\partial}}
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
%
%
% \begin{macro}{\Integrate}
% \begin{macro}{\Int}
% Integrate
%
% This has the option |IntegrateDisplayFunc| which can be |inset| or |outset|:
%
% \begin{tabular}{c}
% |\Style{IntegrateDisplayFunc=inset}| (Default)%
% \Style{IntegrateDisplayFunc=inset}						
% \\
% 	\begin{tabular}{ll}
%	|\Integrate{f}{x}|		& \vspace{0.15cm}$\Integrate{f}{x}$		\\
% 	|\Int{f}{x}|			& \vspace{0.15cm}$\Int{f}{x}$			\\
% 	|\Integrate{f}{x,A}|		& \vspace{0.15cm}$\Integrate{f}{x,A}$		\\
% 	|\Int{f}{x,A}|		& \vspace{0.15cm}$\Int{f}{x,A}$				\\
% 	|\Integrate{f}{x,a,b}|	& \vspace{0.15cm}$\Integrate{f}{x,a,b}$			\\
% 	|\Int{f}{x,a,b}|		& \vspace{0.15cm}$\Int{f}{x,a,b}$		\\
%	\end{tabular}
% \\
% \\
% |\Style{IntegrateDisplayFunc=outset,IntegrateDifferentialDSymb=\text{d}}|%
% \Style{IntegrateDisplayFunc=outset,IntegrateDifferentialDSymb=\text{d}}
% \\
%	\begin{tabular}{ll}
%	|\Integrate{f}{x}|		& \vspace{0.15cm}$\Integrate{f}{x}$		\\
%	|\Int{f}{x}|			& \vspace{0.15cm}$\Int{f}{x}$			\\
%	|\Integrate{f}{x,A}|		& \vspace{0.15cm}$\Integrate{f}{x,A}$		\\
%	|\Int{f}{x,A}|		& \vspace{0.15cm}$\Int{f}{x,A}$				\\
%	|\Integrate{f}{x,a,b}|	& \vspace{0.15cm}$\Integrate{f}{x,a,b}$			\\
%	|\Int{f}{x,a,b}|		& \vspace{0.15cm}$\Int{f}{x,a,b}$		\\
%	\end{tabular}
% \Style{IntegrateDisplayFunc=inset}
% \\
% \end{tabular}
%    \begin{macrocode}
	\newcommand{\COOL@notation@IntegrateDisplayFunc}{inset}
	\newcommand{\COOL@notation@IntegrateDifferentialDSymb}{d}
\newcommand{\Integrate}[2]{%
\listval{#2}{0}%
%    \end{macrocode}
% record the length of the list
%    \begin{macrocode}
\setcounter{COOL@listlen}{\value{COOL@listpointer}}%
\ifthenelse{ \value{COOL@listlen} = 1 }%
	{%
	\ifthenelse{\equal{\COOL@notation@IntegrateDisplayFunc}{outset}}%
		{%
		\int \! \COOL@notation@IntegrateDifferentialDSymb{}#2 \, #1%
		}%
	% ElseIf
	{ \ifthenelse{\equal{\COOL@notation@IntegrateDisplayFunc}{inset}}%
		{%
		\int #1 \, \COOL@notation@IntegrateDifferentialDSymb{}#2%
		}%
	% Else
		{%
		\PackageError{cool}{Invalid Option Sent}%
			{`DisplayFunc' can only be `inset' or `outset'}%
		}}%
	}%
% ElseIf
{ \ifthenelse{ \value{COOL@listlen} = 2 }%
	{%
	\ifthenelse{\equal{\COOL@notation@IntegrateDisplayFunc}{outset}}%
		{%
		\int_{\listval{#2}{2}} \! 
			\COOL@notation@IntegrateDifferentialDSymb{}{\listval{#2}{1}} \, #1%
		}%
	% ElseIf
	{ \ifthenelse{\equal{\COOL@notation@IntegrateDisplayFunc}{inset}}%
		{%
		\int_{\listval{#2}{2}} #1 \, 
			\COOL@notation@IntegrateDifferentialDSymb{}{\listval{#2}{1}}%
		}%
	% Else
		{%
		\PackageError{cool}{Invalid Option Sent}%
			{`DisplayFunc' can only be `inset' or `outset'}%
		}}%
	}%
% ElseIf
{ \ifthenelse{ \value{COOL@listlen} = 3 }%
	{%
	\ifthenelse{\equal{\COOL@notation@IntegrateDisplayFunc}{outset}}%
		{%
		\int_{\listval{#2}{2}}^{\listval{#2}{3}} \! 
			\COOL@notation@IntegrateDifferentialDSymb{}{\listval{#2}{1}} \, #1%
		}%
	% ElseIf
	{ \ifthenelse{\equal{\COOL@notation@IntegrateDisplayFunc}{inset}}%
		{%
		\int_{\listval{#2}{2}}^{\listval{#2}{3}} #1 \, 
			\COOL@notation@IntegrateDifferentialDSymb{}{\listval{#2}{1}}%
		}%
	% Else
		{%
		\PackageError{cool}{Invalid Option Sent}%
			{`DisplayFunc' can only be `inset' or `outset'}%
		}}%
	}%
% Else
	{%
	\PackageError{cool}{`Integrate' has invalid parameter list}%
		   {this happens when the second argument has more than two commas}%
	}}}%
}%
\newcommand{\Int}[2]{\Integrate{#1}{#2}}
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
%
%
% \begin{macro}{\Sum}
% Sum
%
% \begin{tabular}{ll}
% |\Sum{a_n}{n}|		& \vspace{0.1cm}$\Sum{a_n}{n}$			\\
% |\Sum{a_n}{n,1,N}|		& \vspace{0.1cm}$\Sum{a_n}{n,1,N}$		\\
% \end{tabular}
%    \begin{macrocode}
\newcommand{\Sum}[2]{%
\listval{#2}{0}%
%    \end{macrocode}
% record the length of the list
%    \begin{macrocode}
\setcounter{COOL@listlen}{\value{COOL@listpointer}}
\ifthenelse{ \value{COOL@listlen} = 1 }%
	{%
	\sum_{#2} #1%
	}%
% else
	{%
	\ifthenelse{ \value{COOL@listlen} = 3 }%
		{%
		\sum_{ \listval{#2}{1} = \listval{#2}{2} }^{ \listval{#2}{3} } #1
		}%
	% else
		{%
		\PackageError{cool}{Invalid list length for `Sum'}%
			{can only have none or two commas for second argument}%
		}%
	}%
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\Prod}
% Product
%
% \begin{tabular}{ll}
% |\Prod{a_n}{n}|		& \vspace{0.1cm}$\Prod{a_n}{n}$		\\
% |\Prod{a_n}{n,1,N}|		& \vspace{0.1cm}$\Prod{a_n}{n,1,N}$	\\
% \end{tabular}
%    \begin{macrocode}
\newcommand{\Prod}[2]{%
\listval{#2}{0}%
%    \end{macrocode}
% record the length of the list
%    \begin{macrocode}
\setcounter{COOL@listlen}{\value{COOL@listpointer}}
\ifthenelse{ \value{COOL@listlen} = 1 }%
	{%
	\prod_{#2} #1%
	}%
% else
	{%
	\ifthenelse{ \value{COOL@listlen} = 3 }%
		{%
		\prod_{ \listval{#2}{1} = \listval{#2}{2} }^{ \listval{#2}{3} } #1
		}%
	% else
		{%
		\PackageError{cool}{Invalid list length for `Prod'}%
			{can only have none or two commas for second argument}%
		}%
	}%
}
%    \end{macrocode}
% \end{macro}
%
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% %  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %
% \subsubsection{Vector Operators}
% %  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% \begin{macro}{\DotProduct}
% The dot product, |\DotProduct{\vec{A}}{\vec{B}}|, $\DotProduct{\vec{A}}{\vec{B}}$
%    \begin{macrocode}
\newcommand{\DotProduct}[2]{#1 \cdot #2}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\Cross}
% The cross product, |\Cross{\vec{A}}{\vec{B}}|, $\Cross{\vec{A}}{\vec{B}}$
%    \begin{macrocode}
\newcommand{\Cross}[2]{#1 \times #2}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\Div}
% the divergence, |\Div{\vec{A}}|, $\Div{\vec{A}}$
%    \begin{macrocode}
\newcommand{\Div}[1]{\nabla \cdot #1}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\Grad}
% The gradient, |\Grad{f}|, $\Grad{f}$
%    \begin{macrocode}
\newcommand{\Grad}[1]{\nabla #1}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\Curl}
% The curl, |\Curl{\vec{A}}|, $\Curl{\vec{A}}$
%    \begin{macrocode}
\newcommand{\Curl}[1]{\nabla \times #1}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\Laplacian}
% The laplacian, |\Laplacian{f}|, $\Laplacian{f}$
%    \begin{macrocode}
\newcommand{\Laplacian}[1]{\nabla^2 #1}
%    \end{macrocode}
% \end{macro}
%
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% %  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %
% \subsubsection{Matrix Operations}
% %  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% \begin{macro}{\Transpose}
% Transpose of a matrix, |\Transpose{A}|, $\Transpose{A}$
%    \begin{macrocode}
	\newcommand{\COOL@notation@TransposeParen}{inv}
\newcommand{\Transpose}[1]{ \COOL@decide@paren{Transpose}{#1}^T }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\Dagger}
% Conjugate Transpose of a matrix, |\Dagger{A}|, $\Dagger{A}$
%    \begin{macrocode}
	\newcommand{\COOL@notation@DaggerParen}{inv}
\newcommand{\Dagger}[1]{ \COOL@decide@paren{Dagger}{#1}^\dagger }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\Det}
% determinant of a matrix
%
% \begin{tabular}{ll}
% |\Style{DetDisplay=det}|%
% \Style{DetDisplay=det} (Default)		\\
% |\Det{A}|		& $\Det{A}$		\\
% |\Style{DetDisplay=barenc}|%
% \Style{DetDisplay=barenc}			\\
% |\Det{A}|		& $\Det{A}$		\\
% \end{tabular}
%    \begin{macrocode}
	\newcommand{\COOL@notation@DetParen}{none}
	\newcommand{\COOL@notation@DetDisplay}{det}
\newcommand{\Det}[1]{%
\ifthenelse{\equal{\COOL@notation@DetDisplay}{det}}%
	{%
	\det\COOL@decide@paren{Det}{#1}%
	}%
% ElseIf
{ \ifthenelse{\equal{\COOL@notation@DetDisplay}{barenc}}%
	{%
	\left|#1\right|%
	}%
% Else
	{%
	\PackageError{cool}{Invalid Option Sent}%
		{`DetDisplay' can only be `det' or `barenc'}%
	}}%
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\Tr}
% Trace of a Matrix, |\Tr{A}|, $\Tr{A}$
%    \begin{macrocode}
	\newcommand{\COOL@notation@TrParen}{none}
\newcommand{\Tr}[2][]{%
\ifthenelse{\equal{#1}{}}
	{%
	\operatorname{Tr}\COOL@decide@paren{Tr}{#2}%
	}%
% Else
	{%
	\operatorname{Tr}_{#1}\COOL@decide@paren{Tr}{#2}%
	}%
}
%    \end{macrocode}
% \end{macro}
%
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% %  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %
% \subsubsection{Matricies}
% %  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %%  %
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% \begin{macro}{\IdentityMatrix}
% The Identity Matrix
%
% \begin{tabular}{cc}
% |\IdentityMatrix|	& $\IdentityMatrix$	\\
% |\IdentityMatrix[2]|	& $\IdentityMatrix[2]$	\\
% \end{tabular}
%    \begin{macrocode}
	\newcommand{\COOL@notation@IdentityMatrixParen}{p}
		\newcounter{COOL@row}%
		\newcounter{COOL@col}%
	\newcommand{\COOL@notation@IdentityMatrixSymb}{\mathbbm{1}}
\newcommand{\IdentityMatrix}[1][0]{%
\isint{#1}{COOL@isint}%
\ifthenelse{\boolean{COOL@isint}}%
	{%
	\ifthenelse{ #1=0 }%
		{%
		\COOL@notation@IdentityMatrixSymb%
		}%
	% Else
		{%
		\setcounter{COOL@ct}{\value{MaxMatrixCols}}%
		\setcounter{MaxMatrixCols}{#1}%
		\ifthenelse{\equal{\COOL@notation@IdentityMatrixParen}{p}}%
			{%
			\begin{pmatrix}%
			}%
		% ElseIf
		{ \ifthenelse{\equal{\COOL@notation@IdentityMatrixParen}{b}}%
			{%
			\begin{bmatrix}%
			}%
		% ElseIf
		{ \ifthenelse{\equal{\COOL@notation@IdentityMatrixParen}{br}}%
			{%
			\begin{Bmatrix}%
			}%
		% Else
			{%
			\begin{matrix}%
			}}}%
		\forLoop{1}{#1}{COOL@row}%
			{%
			\ifthenelse{\NOT \value{COOL@row} = 1}{\\}{}%
			\forLoop{1}{#1}{COOL@col}%
				{%
				\ifthenelse{ \NOT \value{COOL@col} = 1 }{&}{}%
				\ifthenelse{ \value{COOL@row}=\value{COOL@col} }{1}{0}%
				}%
			}%
		\ifthenelse{\equal{\COOL@notation@IdentityMatrixParen}{p}}%
			{%
			\end{pmatrix}%
			}%
		% ElseIf
		{ \ifthenelse{\equal{\COOL@notation@IdentityMatrixParen}{b}}%
			{%
			\end{bmatrix}%
			}%
		% ElseIf
		{ \ifthenelse{\equal{\COOL@notation@IdentityMatrixParen}{br}}%
			{%
			\end{Bmatrix}%
			}%
		% Else
			{%
			\end{matrix}%
			}}}%
		\setcounter{MaxMatrixCols}{\value{COOL@ct}}%
		}%
	}%
% Else
	{%
	\COOL@notation@IdentityMatrixSymb%
	}%
}%
%    \end{macrocode}
% \end{macro}
%
%
%
%
% \Finale
\endinput
