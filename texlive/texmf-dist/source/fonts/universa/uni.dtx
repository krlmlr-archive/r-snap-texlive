%\iffalse
%<*driver>
\documentclass{ltxdoc}
\usepackage{unidoc,latexsym}
%\OnlyDescription %For short description of font and package.
\AlsoImplementation %For full description of font and package.
\title{The \universal{} Font\\ \normalsize{Version 2.0}}
\author{Christian Holm\thanks{Niels Bohr Institute of Physics, 
  Institute of Philosophy, Rethorics, and Education; University
   of Copenhagen; Denmark; E--mail: \texttt{<cholm@nbi.dk>}}}
\date{August 1 1998}
\begin{document}
\maketitle
\begin{abstract}
  This is my implementation of Herbert Bayer's ``universal'' font in
  \MF{} for \TeX{} and \LaTeX{}. Extensive support for \LaTeX{} is
  supplied. This font is in no way intended to be a correct, not to
  mention a comlpete implementation of Herbert Bayer's original
  design. This document describes how to use the font with \LaTeX{},
  and also the source code for the characters of the font.
\end{abstract}
\tableofcontents
\DocInput{uni.dtx}
\end{document}
%</driver>
%<*copyright>
		    GNU GENERAL PUBLIC LICENSE
		       Version 2, June 1991

 Copyright (C) 1989, 1991 Free Software Foundation, Inc.
                          675 Mass Ave, Cambridge, MA 02139, USA
 Everyone is permitted to copy and distribute verbatim copies
 of this license document, but changing it is not allowed.

			    Preamble

  The licenses for most software are designed to take away your
freedom to share and change it.  By contrast, the GNU General Public
License is intended to guarantee your freedom to share and change free
software--to make sure the software is free for all its users.  This
General Public License applies to most of the Free Software
Foundation's software and to any other program whose authors commit to
using it.  (Some other Free Software Foundation software is covered by
the GNU Library General Public License instead.)  You can apply it to
your programs, too.

  When we speak of free software, we are referring to freedom, not
price.  Our General Public Licenses are designed to make sure that you
have the freedom to distribute copies of free software (and charge for
this service if you wish), that you receive source code or can get it
if you want it, that you can change the software or use pieces of it
in new free programs; and that you know you can do these things.

  To protect your rights, we need to make restrictions that forbid
anyone to deny you these rights or to ask you to surrender the rights.
These restrictions translate to certain responsibilities for you if you
distribute copies of the software, or if you modify it.

  For example, if you distribute copies of such a program, whether
gratis or for a fee, you must give the recipients all the rights that
you have.  You must make sure that they, too, receive or can get the
source code.  And you must show them these terms so they know their
rights.

  We protect your rights with two steps: (1) copyright the software, and
(2) offer you this license which gives you legal permission to copy,
distribute and/or modify the software.

  Also, for each author's protection and ours, we want to make certain
that everyone understands that there is no warranty for this free
software.  If the software is modified by someone else and passed on, we
want its recipients to know that what they have is not the original, so
that any problems introduced by others will not reflect on the original
authors' reputations.

  Finally, any free program is threatened constantly by software
patents.  We wish to avoid the danger that redistributors of a free
program will individually obtain patent licenses, in effect making the
program proprietary.  To prevent this, we have made it clear that any
patent must be licensed for everyone's free use or not licensed at all.

  The precise terms and conditions for copying, distribution and
modification follow.

		    GNU GENERAL PUBLIC LICENSE
   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION

  0. This License applies to any program or other work which contains
a notice placed by the copyright holder saying it may be distributed
under the terms of this General Public License.  The "Program", below,
refers to any such program or work, and a "work based on the Program"
means either the Program or any derivative work under copyright law:
that is to say, a work containing the Program or a portion of it,
either verbatim or with modifications and/or translated into another
language.  (Hereinafter, translation is included without limitation in
the term "modification".)  Each licensee is addressed as "you".

Activities other than copying, distribution and modification are not
covered by this License; they are outside its scope.  The act of
running the Program is not restricted, and the output from the Program
is covered only if its contents constitute a work based on the
Program (independent of having been made by running the Program).
Whether that is true depends on what the Program does.

  1. You may copy and distribute verbatim copies of the Program's
source code as you receive it, in any medium, provided that you
conspicuously and appropriately publish on each copy an appropriate
copyright notice and disclaimer of warranty; keep intact all the
notices that refer to this License and to the absence of any warranty;
and give any other recipients of the Program a copy of this License
along with the Program.

You may charge a fee for the physical act of transferring a copy, and
you may at your option offer warranty protection in exchange for a fee.

  2. You may modify your copy or copies of the Program or any portion
of it, thus forming a work based on the Program, and copy and
distribute such modifications or work under the terms of Section 1
above, provided that you also meet all of these conditions:

    a) You must cause the modified files to carry prominent notices
    stating that you changed the files and the date of any change.

    b) You must cause any work that you distribute or publish, that in
    whole or in part contains or is derived from the Program or any
    part thereof, to be licensed as a whole at no charge to all third
    parties under the terms of this License.

    c) If the modified program normally reads commands interactively
    when run, you must cause it, when started running for such
    interactive use in the most ordinary way, to print or display an
    announcement including an appropriate copyright notice and a
    notice that there is no warranty (or else, saying that you provide
    a warranty) and that users may redistribute the program under
    these conditions, and telling the user how to view a copy of this
    License.  (Exception: if the Program itself is interactive but
    does not normally print such an announcement, your work based on
    the Program is not required to print an announcement.)

These requirements apply to the modified work as a whole.  If
identifiable sections of that work are not derived from the Program,
and can be reasonably considered independent and separate works in
themselves, then this License, and its terms, do not apply to those
sections when you distribute them as separate works.  But when you
distribute the same sections as part of a whole which is a work based
on the Program, the distribution of the whole must be on the terms of
this License, whose permissions for other licensees extend to the
entire whole, and thus to each and every part regardless of who wrote it.

Thus, it is not the intent of this section to claim rights or contest
your rights to work written entirely by you; rather, the intent is to
exercise the right to control the distribution of derivative or
collective works based on the Program.

In addition, mere aggregation of another work not based on the Program
with the Program (or with a work based on the Program) on a volume of
a storage or distribution medium does not bring the other work under
the scope of this License.

  3. You may copy and distribute the Program (or a work based on it,
under Section 2) in object code or executable form under the terms of
Sections 1 and 2 above provided that you also do one of the following:

    a) Accompany it with the complete corresponding machine-readable
    source code, which must be distributed under the terms of Sections
    1 and 2 above on a medium customarily used for software interchange; or,

    b) Accompany it with a written offer, valid for at least three
    years, to give any third party, for a charge no more than your
    cost of physically performing source distribution, a complete
    machine-readable copy of the corresponding source code, to be
    distributed under the terms of Sections 1 and 2 above on a medium
    customarily used for software interchange; or,

    c) Accompany it with the information you received as to the offer
    to distribute corresponding source code.  (This alternative is
    allowed only for noncommercial distribution and only if you
    received the program in object code or executable form with such
    an offer, in accord with Subsection b above.)

The source code for a work means the preferred form of the work for
making modifications to it.  For an executable work, complete source
code means all the source code for all modules it contains, plus any
associated interface definition files, plus the scripts used to
control compilation and installation of the executable.  However, as a
special exception, the source code distributed need not include
anything that is normally distributed (in either source or binary
form) with the major components (compiler, kernel, and so on) of the
operating system on which the executable runs, unless that component
itself accompanies the executable.

If distribution of executable or object code is made by offering
access to copy from a designated place, then offering equivalent
access to copy the source code from the same place counts as
distribution of the source code, even though third parties are not
compelled to copy the source along with the object code.

  4. You may not copy, modify, sublicense, or distribute the Program
except as expressly provided under this License.  Any attempt
otherwise to copy, modify, sublicense or distribute the Program is
void, and will automatically terminate your rights under this License.
However, parties who have received copies, or rights, from you under
this License will not have their licenses terminated so long as such
parties remain in full compliance.

  5. You are not required to accept this License, since you have not
signed it.  However, nothing else grants you permission to modify or
distribute the Program or its derivative works.  These actions are
prohibited by law if you do not accept this License.  Therefore, by
modifying or distributing the Program (or any work based on the
Program), you indicate your acceptance of this License to do so, and
all its terms and conditions for copying, distributing or modifying
the Program or works based on it.

  6. Each time you redistribute the Program (or any work based on the
Program), the recipient automatically receives a license from the
original licensor to copy, distribute or modify the Program subject to
these terms and conditions.  You may not impose any further
restrictions on the recipients' exercise of the rights granted herein.
You are not responsible for enforcing compliance by third parties to
this License.

  7. If, as a consequence of a court judgment or allegation of patent
infringement or for any other reason (not limited to patent issues),
conditions are imposed on you (whether by court order, agreement or
otherwise) that contradict the conditions of this License, they do not
excuse you from the conditions of this License.  If you cannot
distribute so as to satisfy simultaneously your obligations under this
License and any other pertinent obligations, then as a consequence you
may not distribute the Program at all.  For example, if a patent
license would not permit royalty-free redistribution of the Program by
all those who receive copies directly or indirectly through you, then
the only way you could satisfy both it and this License would be to
refrain entirely from distribution of the Program.

If any portion of this section is held invalid or unenforceable under
any particular circumstance, the balance of the section is intended to
apply and the section as a whole is intended to apply in other
circumstances.

It is not the purpose of this section to induce you to infringe any
patents or other property right claims or to contest validity of any
such claims; this section has the sole purpose of protecting the
integrity of the free software distribution system, which is
implemented by public license practices.  Many people have made
generous contributions to the wide range of software distributed
through that system in reliance on consistent application of that
system; it is up to the author/donor to decide if he or she is willing
to distribute software through any other system and a licensee cannot
impose that choice.

This section is intended to make thoroughly clear what is believed to
be a consequence of the rest of this License.

  8. If the distribution and/or use of the Program is restricted in
certain countries either by patents or by copyrighted interfaces, the
original copyright holder who places the Program under this License
may add an explicit geographical distribution limitation excluding
those countries, so that distribution is permitted only in or among
countries not thus excluded.  In such case, this License incorporates
the limitation as if written in the body of this License.

  9. The Free Software Foundation may publish revised and/or new versions
of the General Public License from time to time.  Such new versions will
be similar in spirit to the present version, but may differ in detail to
address new problems or concerns.

Each version is given a distinguishing version number.  If the Program
specifies a version number of this License which applies to it and "any
later version", you have the option of following the terms and conditions
either of that version or of any later version published by the Free
Software Foundation.  If the Program does not specify a version number of
this License, you may choose any version ever published by the Free Software
Foundation.

  10. If you wish to incorporate parts of the Program into other free
programs whose distribution conditions are different, write to the author
to ask for permission.  For software which is copyrighted by the Free
Software Foundation, write to the Free Software Foundation; we sometimes
make exceptions for this.  Our decision will be guided by the two goals
of preserving the free status of all derivatives of our free software and
of promoting the sharing and reuse of software generally.

			    NO WARRANTY

  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS
TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
REPAIR OR CORRECTION.

  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING
OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED
TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY
YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
POSSIBILITY OF SUCH DAMAGES.

		     END OF TERMS AND CONDITIONS

	    How to Apply These Terms to Your New Programs

  If you develop a new program, and you want it to be of the greatest
possible use to the public, the best way to achieve this is to make it
free software which everyone can redistribute and change under these terms.

  To do so, attach the following notices to the program.  It is safest
to attach them to the start of each source file to most effectively
convey the exclusion of warranty; and each file should have at least
the "copyright" line and a pointer to where the full notice is found.

    <one line to give the program's name and a brief idea of what it does.>
    Copyright (C) 19yy  <name of author>

    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.

Also add information on how to contact you by electronic and paper mail.

If the program is interactive, make it output a short notice like this
when it starts in an interactive mode:

    Gnomovision version 69, Copyright (C) 19yy name of author
    Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
    This is free software, and you are welcome to redistribute it
    under certain conditions; type `show c' for details.

The hypothetical commands `show w' and `show c' should show the appropriate
parts of the General Public License.  Of course, the commands you use may
be called something other than `show w' and `show c'; they could even be
mouse-clicks or menu items--whatever suits your program.

You should also get your employer (if you work as a programmer) or your
school, if any, to sign a "copyright disclaimer" for the program, if
necessary.  Here is a sample; alter the names:

  Yoyodyne, Inc., hereby disclaims all copyright interest in the program
  `Gnomovision' (which makes passes at compilers) written by James Hacker.

  <signature of Ty Coon>, 1 April 1989
  Ty Coon, President of Vice

This General Public License does not permit incorporating your program into
proprietary programs.  If your program is a subroutine library, you may
consider it more useful to permit linking proprietary applications with the
library.  If this is what you want to do, use the GNU Library General
Public License instead of this License.

%</copyright>
%\fi
% \CheckSum{1207}
% \CharacterTable
%  {Upper-case    \A\B\C\D\E\F\G\H\I\J\K\L\M\N\O\P\Q\R\S\T\U\V\W\X\Y\Z
%   Lower-case    \a\b\c\d\e\f\g\h\i\j\k\l\m\n\o\p\q\r\s\t\u\v\w\x\y\z
%   Digits        \0\1\2\3\4\5\6\7\8\9
%   Exclamation   \!     Double quote  \"     Hash (number) \#
%   Dollar        \$     Percent       \%     Ampersand     \&
%   Acute accent  \'     Left paren    \(     Right paren   \)
%   Asterisk      \*     Plus          \+     Comma         \,
%   Minus         \-     Point         \.     Solidus       \/
%   Colon         \:     Semicolon     \;     Less than     \<
%   Equals        \=     Greater than  \>     Question mark \?
%   Commercial at \@     Left bracket  \[     Backslash     \\
%   Right bracket \]     Circumflex    \^     Underscore    \_
%   Grave accent  \`     Left brace    \{     Vertical bar  \|
%   Right brace   \}     Tilde         \~}

% \CheckSum{1207}
% \CharacterTable
%  {Upper-case    \A\B\C\D\E\F\G\H\I\J\K\L\M\N\O\P\Q\R\S\T\U\V\W\X\Y\Z
%   Lower-case    \a\b\c\d\e\f\g\h\i\j\k\l\m\n\o\p\q\r\s\t\u\v\w\x\y\z
%   Digits        \0\1\2\3\4\5\6\7\8\9
%   Exclamation   \!     Double quote  \"     Hash (number) \#
%   Dollar        \$     Percent       \%     Ampersand     \&
%   Acute accent  \'     Left paren    \(     Right paren   \)
%   Asterisk      \*     Plus          \+     Comma         \,
%   Minus         \-     Point         \.     Solidus       \/
%   Colon         \:     Semicolon     \;     Less than     \<
%   Equals        \=     Greater than  \>     Question mark \?
%   Commercial at \@     Left bracket  \[     Backslash     \\
%   Right bracket \]     Circumflex    \^     Underscore    \_
%   Grave accent  \`     Left brace    \{     Vertical bar  \|
%   Right brace   \}     Tilde         \~}
% \def\fileversion{v2.0}
% \def\filedate{98/08/01}
% \section{Introduction}
% \changes{v1.0}{1997/17/24}{Creation of the \universal{} font}
%
% This package contains the \MF{} source and driver files for the 
% ``universal'' font, designed by Herbert Bayer, a teacher at the
% Bauhaus school in Weimar\index{Bayer, Herbert}, plus a \LaTeX{}
% package to utilize this font, along with a number of font definition
% files, as required by the New Font Selection Scheme (\NFSS{}).
%
% \subsubsection*{About the Documantation}
%
% The full documentation of this font is rather large, more then 80
% pages actually. Most of it is the programs for the characters for
% this font, so if you don't know the \MF{} language, or don't care
% how the charcters are created, you should insert
% \Lcs{OnlyDescription} into the preamble of \texttt{uni.dtx}.
%
% Notice, that \MF{} macros are \emph{not} indexed in this
% documentation. This is because it would take a \emph{major} rewrite
% of the \textsf{doc} package to do so, and I really didn't want to do
% that.
%
% Some of the macros of \textsf{doc} \emph{has} been redefined, and if
% you want to see which, or how I generally did the documentation,
% please refer to appendix~\ref{app:unidoc}.
% 
% If you in some way are unsatisfied with some of the characters of
% the font, do please read the documentation of that character. There
% may be some notes on why the character looks the way it does. Some
% of the comments, however are a bit silly and should be skipped at
% high speed (pretend there is a conditional that says \texttt{if not 
% silly ... fi}).
% 
% \subsubsection*{This Version}
% \changes{v2.0}{98/08/01}{Bug corrections, new font
% shapes, better font programs, new/improved macros for \LaTeX{}
% support, better conformation to \NFSS{}, using \textsf{fontname}
% filenaming scheme, etc.}
% 
% This new version of the \universal{} font, provides a number
% of new features and improvements, both to the font itself and to the
% \LaTeX{} support macros. Also, a number of corrections has been made
% to the font programs.
%
% The reason why I jumped one whole version number from 1.0 to 2.0, is
% that I have taken a whole new approach to the font programs and
% shapes of the \universal{} font, plus I decided to put some
% more effort into the \LaTeX{} support.
%
% \subsubsection*{Thanks and Other Stuff}
% 
% To those of you who have had the (mixed) pleasure of using version
% 1.0 of this font, one of the most notaticable changes are to the
% symbol \textuni{\bauforms}. In the old documenation, I complained
% that I couldn't find the exact solution to the problem this symbol
% possed. I also encourged people to send me any solution they may
% have had --- and guess what --- somebody did! Therefore I would like
% to thanck Joseph Collins for providing me with the solution. If you
% like Joseph Collins and I like Mathematical puzzles take a look in
% Appendix~\ref{app:solu} to learn more about this problem and it's
% solution.
%
% I also direct your attention to Appendix~\ref{app:ggpl} for the
% copyright notice on the \universal{} package (it's the
% \textsl{Gnu General Public Lisence} to those of you who know it).
% 
% If you in any way have gotten tempted to design your own font, or to
% implement some font into \MF{}, I feel obligated to bring you a
% warning, taken from the \MF{}book by Donald E.\ Knuth:
% \begin{quote}
%   \uni
%   \textsc{Warning:} Type design can be hazardous to your other
%   interests. Once you get hooked, you will develop intense feelings
%   about letterforms; the medium will intrude the message that you
%   read. And you will perpetually be thincking of improvements to the
%   fonts that you see everywhere, especially those of your own
%   design.
% \end{quote}
%
% \section{The Font and it's History}
%
% \subsubsection*{Bauhaus}
% The Bauhaus school in germany originally located at Dessau, was a
% school for any kind of design, ranging from potery to furniture,
% from painting to --- what was considered the prime form of design
% --- architecture. Many famous designers came from, or taught at
% Bauhaus, for example Mies van der Rhoe\index{Rhoe, Mies van der},
% Herbert Bayer\index{Bayer, Herbert}, Kandinsky\index{Kandinsky},
% Walter Gropius\index{Gropius, Walter} and Gerrit
% Rietveld\index{Rietveld, Gerrit}. The style ``die stiil''
% \index{die stiil} was explored here, and painters like
% Mondrian\index{Mondrian} made large contributions to what today is
% known as
% ``the Bauhaus style''\index{Bauhaus style=\textuni{Bauhaus style}}. 
%
% The basic idea of the Bauhaus school, was to design items, which
% along with it's aesthethic value, also had a high degree of
% functionallity. Houses were meant to be suited for all kinds of
% living, while still keeping the beauty that make people glad to see
% thier house. Chairs should be comfortable for thier use, as well be
% able to fit--in in a normal house. All this should be done at a
% price that made it possible for everybody to own
% designer--furniture, houses, etc.
%
% The political idea of Bauhaus, was that of a socialist one. Houses
% are for the people --- they have to live in them, and that living
% should be a good as possible. Therefore the Bauhaus school saw it
% has its task to provide functional, beautiful everyday items that
% anybody could affort. Paintings and tapestery shouldn't hang on
% museums or art galleries, but in peoples homes, where they would
% inrich thier everyday life.
% 
% \subsubsection*{Herbert Bayer and the ``universal'' Font}
% 
% At Bauhaus typography was also studied, not just how written text
% should be typeset, and how printed characters should look like, but
% also what the essence of writting is, in it's pratical and
% design--wise sense. This led Herbert Bayer\index{Bayer, Herbert} to
% formulate some principles of writting:
%
% \begin{quote}
%   {\uni experiment with simplified way of writing:
%     \begin{enumerate}
%       \item this way of writing is recommended by all typographic
%         designers as the future way of writing.
%       \item by writing in minuscules our writing looses nothing, 
%         but is easier to read, considerably more economical. 
%       \item why must you for one sound have two tokens, e.g.\ 
%         A and a? why two alphabets for one word, why this double 
%         set of signs, when the half is enough.  
%     \end{enumerate}
%     \begin{flushright}
%       herbert bayer 1925
%     \end{flushright}}
% \end{quote}
%
% On this principles, Herbert Bayer designed a font, which should have
% no majuscles (upper case letters), easy to print, and easy to read
% since it didn't have any unusefull decoration, but communicated the
% bare meaning of characters through the simplest forms needed to
% reconigise a character. This font he called ``universal''.
%
% This font contained abolutly no majuscles, since Bayer believed them
% to be superflous, as it is clear form the quote above.
%
% At the time Herbert Bayer formulated these principles and designed
% the ``universal'' font, most printers used Gothic letters, which is
% allmost overly decorated, so his font ofcourse made
% contraversy.
%
% Later on, in the 1930'ies, the Bauhaus school drew the
% attention of \emph{Gestapo}\footnote{Gehemligche Stats Polizi} of
% Nazi\footnote{Nationalsocializmus} Germany. The school was finally
% closed in 1936 by Gestapo, because they believed they were promoters
% of Jewish and Communist culture and propaganda.
%
% In the aftermatch of the closing of the school, most of it's ideas
% were shundend by other designers, and the Bauhaus way of thinking
% died out. This is properly the reason why Herbert Bayers
% ``universal'' font is so little known today.
% 
% However, the ``universal'' font still stands as one of the most
% compelling developments in font designing. It represents an approach
% to designing where the functionallity is as vital as the expression,
% and as such I believ it to be one of the most important fonts in the
% world today.
% 
% \section{This \MF{} Implementation}
%
% This implementation of Herbert Bayers ``universal'' font, is not
% supposed to look \emph{exactly} like the original design. Ofcourse I
% have tried to the best of my ability to mimic his design as far as I
% could. However, it is not an easy matter to find a complete, not to
% mention exact, sample or account of Bayers design.
%
% This implementation is bassed on the samples I \emph{could} find,
% and other implementations of the ``universal'' font. Many of these
% other implementations do differ from the original samples, and
% include characters I couldn't find in any of the original. So
% whenever I found disparities, I mainly leened on the original
% samples and my understanding of the original design.
%
% \subsection{The \MF{} version versus the Original}
%
% As mentioned above, Bayer never did design any majuscles for this
% font, but nonetheless, I have included them into this
% implementation. This I did, because I think most people will have a
% hard time writting in minuscles (lowercase letters) alone. Ofcorse,
% if you agree with Bayer, you should simple not use them.
%
% There are also some other differences, mostly due to the fact, that
% I never found a complete sample of the original font. The major
% differences between the originalk font and this implementation is
% summerized below:
%
% \begin{description}
%   \item[Majuscles:] Majuscles are present, even though they weren't
%     in the original design.
%   \item[Digigts:] These are based on other implementations, and my
%     general conception of the original design.
%   \item[Punctuations:] As above.
%   \item[Accents:] As above.
%   \item[Symbols:] As above.
%   \item[Bauhaus Symbols:] I have added some various symbols I have
%     found in connection with Bauhaus to the font. The reason is I
%     find them beautiful, and I had some space to fill.
%   \item[Numerous Shapes and Weights:] I don't think Bayer ever
%     design slanted characters, a bold face version of the font, and
%     he could never have design a small caps version of the
%     font. However, these are present in this implementation. I
%     included these features, because I believ them to be of general
%     utility, and it makes the font conform more to the Computer
%     Modern Roman font, and \NFSS{}. 
% \end{description}
%
% \subsection{Features of the font}
%
% Rather then using \texttt{cmbase.mf}\footnote{Computer Modern Roman
% base file}, and then redefine some macros, I chose to make a new
% base file myself, i.e.,
% \texttt{unibase.mf}\index{unibase.mf=\texttt{unibase.mf}}. This file
% contains a number of macros\footnote{A better name for `base' would
% be `library', and then the file would be \texttt{libuni.mf}, but to
% conform to CM, I used `base'.} I have used in the character
% programs.
%
% The macros of \texttt{unibase.mf} actually reflects my conception of
% the font. There are three basic drawing macroes:
% \begin{description}
%   \item[\texttt{unicir}] which draws a circle,
%   \item[\texttt{uniarc}] which draws a segment (arc) of a circle, and
%   \item[\texttt{unilne}] which draws a straight line.
% \end{description}
% I believe, that Bayer intended the font to be made of these two
% basic shapes: the arc, and the line. Also, to keep things simple,
% and therefore easy to print, all shapes should be of the same
% thickness, i.e.,as if drawn with a pen of equal thickness. I have
% made one diviation from this, however. All majuscles are drawn with
% a thicker `pen', which makes the output nicer, I think.
%
% Incidently, this made the programs of the characters much simpler,
% and shorter.
%
% \subsubsection{Series, Shapes, Sizes, and Special Characters}
% 
% \Newestchanges{v2.0}{98/08/01}{Added `small caps' shape to the font.}
% \changes{v2.0}{98/08/01}{Added non--standard `strict' shape to the
% font.} 
% \changes{v2.0}{98/08/01}{Added `slanted' shape to the font.}
% \changes{v2.0}{98/08/01}{Default series is changed to `medium'
% to the font, `bold face' support included.}
% 
% Below is a sample of each series/shape combination avaliable in this
% implementation of the font, along with the \LaTeX{} commands that
% drive them: 
% 
% \begin{description}
%   \item[\rm Medium upright (\Lcs{textuni}):]
%     \textuni{The dazed brown fox quickly gave 1234-567890 jumps!} 
%   \item[\rm Medium slanted (\Lcs{textunisl}):]
%     \textunisl{The dazed brown fox quickly gave 1234-567890 jumps!}
%   \item[\rm Medium small caps (\Lcs{textunisc}):]
%     \textunisc{The dazed brown fox quickly gave 1234-567890 jumps!} 
%   \item[\rm Medium strict (\Lcs{textunist}):]
%     \textunist{The dazed brown fox quickly gave 1234-567890 jumps!} 
%   \item[\rm Bold face upright (\Lcs{textunibf}):]
%     \textunibf{The dazed brown fox quickly gave 1234-567890 jumps!} 
%   \item[\rm Bold face slanted (\Lcs{textunibsl}):]
%     \textunibsl{The dazed brown fox quickly gave 1234-567890 jumps!} 
%   \item[\rm Bold face small caps (\Lcs{textunibsc}):]
%     \textunibsc{The dazed brown fox quickly gave 1234-567890 jumps!}
%   \item[\rm Bold face strict (\Lcs{textunibst}):]
%     \textunibst{The dazed brown fox quickly gave 1234-567890 jumps!}
% \end{description}
% 
% Everyone of these shapes are avaliable in size 8, 9, 10, 12, 17
% \texttt{pt}, and \MF{} can ofcourse create others.
%
% \Newestchanges{v2.0}{98/08/01}{Some of the \textunibf{bauhaus} symbols
% that where avaliable in v1.0, has been taken out.}
% Also a number of non--standard characters are avaliable in the
% font. Below is a table of these characters along with the \LaTeX{}
% commands that drive them.
%
% Notice that \textunibf{``} and \textunibf{''} is present in the
% table. This is because these characters are not directly defined,
% but is supplied as \emph{ligatures}. This can be done, because they
% are simple doubles of \textunibf{`} and \textunibf{'}.
%
% A quick look on the table will also reveal some characters that
% generally isn't present in the standard \texttt{OT1}
% encoding\footnote{The \texttt{OT1} encoding is the 7 bit encoding of
% the Computer Modern fonts by Donald E.\ Knuth. 7 bit means it
% contain 128 ($=2^7$) characters.}, but generally present in the
% \texttt{T1} encoding\footnote{The \texttt{T1} encoding is an
% encoding especially designed for the (western) European
% languages. It was founded by the \TeX{} User's Group, on a seminar
% in Cork, and is the basis of the \texttt{dc} fonts. \texttt{T1} is
% an 8 bit encoding, which means it has 256 ($=2^8$) characters.}. I
% have done this, both to provide an (almost) complete font for the
% European languages, but also because I anticipate the \universal{}
% font some time in the future will shift, or a least be avaliable, in
% the \texttt{T1} encoding\footnote{\texttt{T1} is generally
% considered \emph{the} encoding of the future, and in the long term,
% it is most likely the encoding of \LaTeX3.}.
% \begin{table}[htbp]
%   \centering
%   \begin{tabular}{%
%   @{\vline\extracolsep{1em}\space}ll%
%   @{\extracolsep{1em}}ll%
%   @{\space\vline\extracolsep{1em}}}\hline
%     \textuni{\bausquare}&\Lcs{bausquare}&
%     \textuni{\baucircle}&\Lcs{baucircle}\\
%     \textuni{\bautriangle}&\Lcs{bautriangle}&
%     \textuni{\bauhead}&\Lcs{bauhead}\\
%     \textuni{\bauforms}&\Lcs{bauforms}&
%     \textuni{\dh}&\Lcs{dh}\\
%     \textuni{\dj}&\Lcs{dj}&
%     \textuni{\ng}&\Lcs{ng}\\
%     \textuni{\th}&\Lcs{th}&
%     \textuni{\varQ}&\Lcs{varQ}\\
%     \textuni{\DH}&\Lcs{DH}&
%     \textuni{\DJ}&\Lcs{DJ}\\
%     \textuni{\NG}&\Lcs{NG}&
%     \textuni{\TH}&\Lcs{TH}\\
%     \textuni{\textsection}&\Lcs{textsection} or \Lcs{S}&
%     \textuni{\textbraceleft}&\Lcs{textbraceleft} or \Lcs{\char"7B}\\
%     \textuni{\textbraceright}&\Lcs{textbracerigth} or \Lcs{\char"7D}&
%     \textuni{\textbar}&\Lcs{textbar}\\
%     \textuni{\guilsinglleft}&\Lcs{guilsinglleft}&
%     \textuni{\guilsinglright}&\Lcs{guilsinglright}\\
%     \textuni{\guillemoleft}&\Lcs{guillemoleft}&
%     \textuni{\guillemoright}&\Lcs{guillemoright}\\
%     \textuni{\quotesinglbase}&\Lcs{quotesinglbase}&
%     \textuni{\quotedblbase}&\Lcs{quotedblbase}\\
%     \textuni{\textquotedblleft}&\Lcs{textquotedblleft}&
%     \textuni{\textquotedblright}&\Lcs{textquotedblright}\\
%     \textuni{\textogonek}&\Lcs{textogonek}&
%     \textuni{\textunderscore}&\Lcs{textunderscore}\\
%     \hline
%   \end{tabular}
%   \caption{Non--standard characters in the {universal} font}
%   \label{tab:characters}
% \end{table}
% Please note, that in the small caps shaped fonts, \Lcs{dh} does not
% give {\small\textuni{\DH}}, but a \textunibsc{\dh}, that is a small
% caps shaped version of \Lcs{varQ}. Also there is no command
% \Lcs{varq} defined.
%
% In appendix~\ref{app:charts} is some charts showing the font in
% different series and shapes.
% 
% \subsubsection{File Names for the \MF{} files}
%
% \paragraph{Base File and Source Files}
% The base file and the files containg the code for the characters of
% the \universal{} font, all starts with \texttt{uni}, to reflect the
% connection of the files. The next five possible letters reflects
% what kind of code is contained within the file, e.g., the base file
% ends in \texttt{base}, the file containing the code for the
% minuscles (lower case letters) end in \texttt{lower}, and so forth.
%
% \paragraph{Font Driver Files}
% The font driver filenames has been chosen to conform to the
% \texttt{fontname} scheme, because this scheme is used by most
% \TeX{}, \LaTeX{}, and \MF{} systems (anyway those that use
% \texttt{kpathsea}, which is the most).
%
% The filename all contain the three characters \texttt{ful}, where
% the \texttt{f} stands for \textit{public} and \texttt{ul} for
% \textit{universal}.
%
% Next comes a letter which is one of \texttt{m} (\textit{medium}) or
% \texttt{b}  (\textit{bold}), which represents the series of the
% font.
%
% Then comes one or two letters, which are \texttt{r}
% (\textit{upright} or roman), \texttt{o} (\textit{slanted}, or
% oblique), \texttt{c} (\textit{small caps}), or \texttt{st}
% (\textit{strict}), which represent the shape of the font.
%
% Finally the filename ends with the designsize in points.
%
% Thus the complete syntax for the font driver file names is:
% \begin{table}[htbp]
% \centering
% \begin{tabular}{rcl}
%   \meta{filename}&:=&
%   \meta{supplier}\meta{face}\meta{series}\meta{shape}\meta{size}\texttt{.mf}\\
%   \meta{supplier}&:=&\texttt{f}\\
%   \meta{face}&:=&\texttt{ul}\\
%   \meta{series}&:=&\texttt{m \char"7C\ b}\\
%   \meta{shape}&:=&\texttt{r \char"7C o \char"7C c \char"7C st}\\
%   \meta{size}&:=&\texttt{\char"7C\ 8 \char"7C\ 9 \char"7C\ 10
%     \char"7C\ 12 \char"7C\ 17}
% \end{tabular}
% \end{table}
% The \texttt{fontname} scheme actually says to put \meta{encoding} 
% information after the \meta{shape}, but since this is \texttt{8r}
% for \TeX{} Text, it would make filenames longer then 8 characters in
% the cases of \meta{size} of 10, 12, and 17, so this information is
% left out (which is permisable in \texttt{fontname}, but
% unfortunate).
%
% This way of naming the font driver files will, if you use
% \texttt{kpathsea}, put the \texttt{ful*.*pk} files in\newline
% \indent\meta{pk--base--dir}\texttt{/public/universa/}\newline  
% and the \texttt{ful*.tfm} files in\newline
% \indent\meta{tfm--base--dir}\texttt{/public/universa/}\newline  
% which I think is the intuitivly correct place to put them. This also
% means, that the \texttt{*.mf} files provided with this package,
% should be placed in\newline
% \indent\meta{mf--source--base--dir}\texttt{/public/universa/}\newline
% again very intuitive.
%
% Below is a table of the usual directory names under
% \textsf{Unix}--like and \textsf{MSDOS}--like (including Windows95)
% systems.\meta{mode} is \textsf{dvips}'s name for your printer.
% \begin{table}[htbp]
%   \begin{tabular}{%
%   @{\vline\extracolsep{1em}\space}l%
%   @{\space\vline\extracolsep{1em}\space}l%
%   @{\space\vline\extracolsep{1em}\space}l%
%   @{\space\vline\extracolsep{1em}}}
%     \hline
%     Varibale&\textsf{Unix}--like systems&\textsf{MSDOS}--like systems\\
%     \hline
%     \meta{tfm--base--dir}&
%     \texttt{/var/spool/texmf/pk/}\meta{mode}\texttt{/}&
%     \texttt{C:\Lcs{}FONTS\Lcs{}PK\Lcs{}}\meta{mode}\Lcs{}\\
%     \meta{tfm--base--dir}&
%     \texttt{/var/spool/texmf/tfm/}&
%     \texttt{C:\Lcs{}FONTS\Lcs{}TFM\Lcs{}}\\
%     \meta{tfm--base--dir}&
%     \texttt{/usr/local/lib/texmf/fonts/source/}&
%     \texttt{C:\Lcs{}TEX\Lcs{}MFINPUTS\Lcs{}}\\
%     \hline
%   \end{tabular}
%   \caption{Common directory names.}
% \end{table}
% 
% \subsection{The \LaTeX\ and \NFSS\ Support}
%
% To use the \universal{} font with \LaTeXe{}\footnote{I have made
% \emph{no} attempt to provide support for \LaTeX2.09, since this
% format is obsolete, and those who \emph{do} use it, will proberly
% never bother to look at CTAN for new fonts anyway.}, you should load
% the package \textsf{uni} with the command
% \begin{quote}
%   \Lcs{usepackage}\oarg{options}\marg{uni}
% \end{quote}
% in your preamble (i.e., after \Lcs{documentclass} and before
% \Lcs{begin\{document\}}). \meta{options} can be any of the options
% described below, but no other.
% 
% \subsubsection{Options to \textsf{uni}}
% 
% \marginpar{\raggedright\texttt{strict}}
% \index{strict=\texttt{strict}\space(Option)}
% \Newestchanges{v2.0}{98/08/01}{Added option \texttt{strict}.}
% The \texttt{srict} option is intended to fassilitate typesetiing of
% the \universal{} font in a \emph{strict} \textunibf{bauhaus}
% fashion, that is \emph{only} in minuscules.
%
% In this font, only the series may be variated, that is, there is a
% bold series strict shaped font of any size, and a medium series
% strict shaped font of any size, in the \universal{} family.
%
% This option can be used in conjuntion with options \texttt{medium}
% and \texttt{bold}. Please notice, that it doesn't make any sense to
% ask for a small caps or slanted shaped font, while using this option.
% 
% Notice that only \Lcs{textuni} and \Lcs{uni} is defined if option
% \texttt{strict} was given to \textsf{uni} package.
% 
% \marginpar{\raggedright\texttt{default}}
% \index{default=\texttt{default}\space(Option)}
% \Newestchanges{v2.0}{98/08/01}{Added option \texttt{default}.}
% If you give the \texttt{default} option to the \textsf{uni} package,
% the default font of the document will be \textunirm{universal}.
%
% If you also used the option \texttt{bold} the default font will be
% the \universal{} font in \textbf{bold} series. Otherwise it will be
% in medium series.
%
% With this option, \Lcs{textit}, \Lcs{it}, and \Lcs{itshape} shifts
% to \textunisl{universal slanted} font, i.e., there is no
% \textit{italic} font avaliable.
%
% \DescribeMacro{\textcmr}
% \DescribeMacro{\cmr}
% To make it possible to change back to Donald E.\ Knuth's Computer
% Modern Roman font, even when the \texttt{default} option is given,
% we define macros \Lcs{textcmr} and \Lcs{cmr}, which switches the
% \Lcs{fontfamily} to \texttt{cmr} locally and gobally respecivly.
% 
% You should use this option with some care, since the \universal{}
% font isn't very suited for longer texts, but rather for short
% letters, quotes, and other pieces of text where the graphical
% apperance is important.
% 
% \marginpar{\raggedright\texttt{medium}}
% \index{medium=\texttt{medium}\space(Option)}
% \Newestchanges{v2.0}{98/08/01}{Added option \texttt{medium}.}
% When this option is given, command \Lcs{textuni} switches to
% \textunirm{medium series universal font}, as do \Lcs{uni}. The other
% font selection commands behave as always (see below). This is the
% default option to \textsf{uni}, i.e., not normally needed.
% 
% \marginpar{\raggedright\texttt{bold}}
% \index{bold=\texttt{bold}\space(Option)}
% \Newestchanges{v2.0}{98/08/01}{Added options \texttt{bold}.}
% If this option is given, commands \Lcs{textuni} and \Lcs{uni}
% switches to \textunibf{bold series universal font}. Other font
% selection commands behave as always (see below). Notice that it 
% makes no sense to give both option \texttt{medium} and option
% \texttt{bold} to the \textsf{uni} package. 
% 
% \subsubsection{Font Selection Commands}
%
% \DescribeMacro{\textuni}\DescribeMacro{\uni}
% These two commands only change the current font family to
% \texttt{uni} \emph{and nothing else}. That means, that if you say
% for example
% \begin{verbatim}
%   {\sl Hello \textuni{world}}
% \end{verbatim}
% you get \emph{both} `Hello' and `world' in slanted shape, and the
% output would be 
% \begin{quote}
%   {\sl Hello \textuni{world}}
% \end{quote}
% To put it in another way: Font encoding, shape, size, and
% baselineskip is preserved under \Lcs{textuni} and \Lcs{uni}, while
% font family is not.
%
% \textbf{Execptions:} If you gave the \texttt{bold} option to the
% \textsf{uni} package, then this command will always give you a bold
% series font. If you gave the \texttt{strict} option, then this
% command will always give you a strict shaped font. 
%
% These commands can be used in conjuntion with \LaTeX{} commands
% \Lcs{textbf}, \Lcs{textsl}, and even \Lcs{sc}, or \Lcs{rm} to give
% different  series and shapes.
%
% \DescribeMacro{\textunirm}\DescribeMacro{\unirm}
% If you in the previous example intended to shift to
% \textunirm{medium upright universal} font you could instead have
% used \Lcs{textunirm}, since this command \emph{does not} preserve
% font shape, i.e., the shape is always changed to upright, regardless
% of the prevouis shape. So if you said
% \begin{verbatim}
%   {\sl Hello \textunirm{world}}
% \end{verbatim}
% you would get
% \begin{quote}
%   {\sl Hello \textunirm{world}}
% \end{quote}
% 
% \DescribeMacro{\textunisl}\DescribeMacro{\unisl}
% \DescribeMacro{\textunisc}\DescribeMacro{\unisc}
% \DescribeMacro{\textunist}\DescribeMacro{\unist}
% \label{expl:cmds}
% Actually \Lcs{textunirm} and \Lcs{unirm} isn't the only commands
% that aggresively changes most of the font
% parameters. \Lcs{textunisl}, \Lcs{textunisc}, and \Lcs{textunist},
% \emph{always} gives you \textunisl{medium slanted}, 
% \textunisc{medium small caps}, and \textunist{medium strict}
% respecitivly no matter what the values of \Lcs{f@shape} was before. 
%
% \DescribeMacro{\textunibf}\DescribeMacro{\unibf}
% \DescribeMacro{\textunibsl}\DescribeMacro{\unibsl}
% \DescribeMacro{\textunibsc}\DescribeMacro{\unibsc}
% \DescribeMacro{\textunibst}\DescribeMacro{\unibst}
% In the same category is \Lcs{textunibf}, \Lcs{textunibsl},
% \Lcs{textunibsc}, and \Lcs{textunist} which always changes the font
% series to \textbf{bold}, along with change in shape (upright,
% slanted, small caps, and strict in that order).
%
% All of the `aggresive' commands, \emph{do not} however change the
% \emph{size} and \emph{baselineskip} of the font. This should be done
% by using \LaTeX{} commands such as \Lcs{small}, \Lcs{Large},
% \Lcs{fontsize}\marg{size}\marg{lineskip},
% etc. 
%
% Notice that the `aggresive' commands always changes to the
% appropiate font series. That is, even if you gave the \texttt{bold}
% option to \textsf{uni}, \Lcs{textunirm} will still give you
% \textunirm{medium upright universal} font. This particular instance
% illustrates the use of the aggresive commands quite well I think.
%
% To summerize: The `aggresive' commands \emph{doesn't} preserve
% fammily, series and shapes, but \emph{does} preserve encoding, size,
% and baslineskip.
%
% \textbf{Warning:} The  font shifting commands \Lcs{textuni...} and
% \Lcs{uni...} in this section is \emph{not} defined if you gave the
% \texttt{strict} option to the \textsf{uni} package.
% 
% \DescribeMacro{\unifamily}
% \Newestchanges{v2.0}{98/08/01}{Defined \Lcs{unifamily} to
% fasilitate easier and stronger font loading.}
% One can also use the rather primitive command \Lcs{unifamily} in
% conjunction with \Lcs{selectfont} as described in \ftnguide{}, to
% change the font family to \universal{} if absolute control is
% preferd.
%
% \Lcs{unifamily} is used by all the other font switching commands, so
% if you redefine it, or \Lcs{unifamilydefault}, you could get strange
% resault.
%
% \DescribeMacro{\unifamilydefault}
% This command normally expands to \texttt{uni}, which is the `family'
% name of the \universal{} package. If you redefine this command to be
% something else, e.g., \texttt{cmr}, \Lcs{unifamily} will load
% another font.
% 
% \DescribeMacro{\uniseries}
% \Newestchanges{v2.0}{98/08/01}{Defined \Lcs{uniseries} to
% fasilitate easier and stronger font loading.}
% If the \texttt{bold} option to \textsf{uni} is used this command
% will select the default series of the \universal{} font, defined in
% \Lcs{uniseriesdefault}, which ofcourse defaults to \texttt{b}, i.e.,
% bold series. if you redefine \Lcs{uniseriesdefault} to be
% \texttt{m}, then \Lcs{uniseries} will select medium series
% fonts.
%
% If \texttt{bold} option wasn't given, then this expands to nothing,
% as do \Lcs{uniseriesdefault}.
%
% This command is used by \Lcs{textuni} and \Lcs{uni}.
% 
% \DescribeMacro{\unishape}
% \Newestchanges{v2.0}{98/08/01}{Defined \Lcs{unishape} to
% fasilitate easier and stronger font loading.}
% If the \texttt{strict} option to \textsf{uni} is used this command
% will select the default shape of the \universal{} font, defined in
% \Lcs{unishapedefault}, which ofcourse defaults to \texttt{st}, i.e.,
% strict shape. If you redefine \Lcs{unishapedefault} to be
% \texttt{n}, then \Lcs{uniseries} will select upright shaped fonts.
%
% If \texttt{strict} option wasn't given, then this expands to nothing,
% as do \Lcs{unishapedefault}.
%
% This command is used by \Lcs{textuni} and \Lcs{uni}.
% 
%
% \DescribeMacro{\stshape}
% \Newestchanges{v2.0}{98/08/01}{Defined \Lcs{stshape} to make package
% conform to \LaTeXe{} better.}
% This command switches to \emph{strict} shape, i.e., all majuscules
% will be typeset as minuscles. This makes it possible in a simple way
% to typeset text in the way Herbert Bayer thought it should, as
% evident from the citation above.
%
% This command uses the command \Lcs{stdefault}, which defaults to
% \texttt{st}. If you redefine this to something alse, e.g.,
% \texttt{sl} you will get a \textsl{slanted} font.
%
% This command is used by \Lcs{textunist}, \Lcs{textunibst},
% \Lcs{unibst} and \Lcs{unist}, and is defined no matter waht options
% you gave to the \textsf{uni} package. 
%
% \textbf{Warning:} Since \emph{strict} is a non--standard shape, this
% command should not be used outside the \universal{} font, since this
% may give you unexpected resaults.  
% 
% \subsubsection{Special Character Commands}
%
% For the individual commands that makes various special characters,
% please consult table~\ref{tab:characters} above.
% 
% \subsubsection{Other Commands}
%
% \DescribeMacro{\k}
% The macro \Lcs{k} used in the \universal{} font gives the accent
% ogenek, that is a reversed cidelia accent. It takes one argument,
% which shuold be a single letter, under which it puts the accent. For
% example, you could say \Lcs{textuni\{}\Lcs{k\{a\}\}} and get
% \textuni{\k{a}}.
%
% \DescribeMacro{\DeclareUniChar}
% \Newestchanges{v2.0}{98/08/01}{Configuration of \textsf{uni} package
% provided via the commands \Lcs{DeclareUniChar} and
% \Lcs{DeclareUniCommand}.} 
% Now you can configure the special character commands of the font,
% via the commands \Lcs{DeclareUniChar} and
% \Lcs{DeclareUniCommand}. The commands defined via these commands
% will only work in accordence with it's definition inside the 
% \universal{} font, and if defined elsewhere according to it's
% definition there, else it will give an error message.
% 
% \Lcs{DeclareUniChar} is used to define a command sequence
% representing a single character in the \universal{} font, much like
% \Lcs{DeclareTextSymbol}, or in \TeX{} \Lcs{chardef}, though the
% control sequence will produce an error message outside the
% \universal{} font, and properle unexpected resaults outside the
% \texttt{OT1} encoding\footnote{This should not be a problem.}. 
%
% \Lcs{DeclareUniCommand} is used to define control sequences inside
% the \universal{} font, representing many characters or doing complex
% manuvers on characters and stuff. The optional argument to
% \Lcs{DeclareUniCommand} can be used to say how many arguments the
% control sequence should have, just like \Lcs{newcommand}. However,
% it is not possible to give a default first argument.
% 
% The below defintion uses the \textsf{color} package to typeset a
% square, circle, and triangle in different colours\footnote{Since the
% documentation should be avaliable to all, I can not provide you with
% the outcome of this example, since it needs the \textsf{color}
% package wich may not be avaliable on all sites. I suggest you try
% it out, or something similar, if you can.}.
% \begin{verbatim}
%   \DeclareUniCommand{\mybauforms}{%
%     \lower.5ex\hbox{\color{blue}\bautriangle}%
%     \kern-.5em\raise.5ex\hbox{\color{read}\baucircle}%
%     \kern-.5em\lower.5ex\hbox{\color{yellow}\bausquare}}
%  \end{verbatim}
%  Yet another example, using arguments could be
%  \begin{verbatim}
%    \DeclareUniCommand{\mybaulogo}[1]{\bauhead\ {\Large #1}}
%  \end{verbatim}
%  so you could say \verb+\mybaulogo{Christian Holm}+ and get:
%  \begin{quote}
%    {\uni \bauhead {\Large Christian Holm}}
%  \end{quote}
%  and I bet you can come up with some even more useful and complex
%  commands. 
%  
% The syntax of \Lcs{DeclareUniChar} and \Lcs{DeclareUniCommand} is 
% \begin{quote}
%   \Lcs{DeclareUniChar}\marg{cmd}\marg{slot}\newline
%   \Lcs{DeclareUniCommand}\marg{cmd}\oarg{arg}\marg{definition}
% \end{quote}
% where \meta{cmd} is the user command defined, \meta{slot} is the
% number of the character in the font, \meta{arg} is the number of
% arguments and \meta{definition} is what \meta{cmd} does.
% 
% \subsubsection{File Names for the \LaTeX{} files}
%
% All the \LaTeX{} files contain the three letters \texttt{uni}, to
% reflect the connectedness of the files. The font definition files
% all start with the letter code appropiate for the encodeing.
%
% To follow the scheme of the \MF{} files, it would be appropiate to
% place all \LaTeX{} files in\newline
% \indent\meta{tex--base--dir}\footnote{On \textsf{Unix}--like systems
%   \meta{tex--base--dir} is usually something like
%   \texttt{/usr/local/lib/texmf/}, and on \textsf{MSDOS}--like systems
%   something like \texttt{C:\Lcs{}TEX}\Lcs{}
% .}\texttt{/tex/latex/universa/} 
% 
% \subsection{The Major differences between version 1.0 and 2.0}
%
% \paragraph{First of:} \emph{a lot} of bugs and errors has been
% corrected. In version~1.0, I had made the (stupid) mistake of
% calling the macro \textuni{mode\_setup} before I defined the
% unsharped units. Ofcourse a quick look in the \MFbook{} showed be
% just how stupid this is. This made the font very vunerable to mode
% specifications, which ofcourse isn't the idea.
%
% \paragraph{Secondly:} I chose a completly new approach to the
% character programs, which resaultet in \texttt{unibase.mf}. The idea
% is to define a few macros, and then utilize those in the character
% programs, so that these programs can be kept simple, efficient, and
% intuitive.
%
% A quick look at \texttt{unibase.mf} will also reveal that I chose a
% new way of adjusting the characters. This means that the macros
% \texttt{bauhaus...} present in version~1.0 no longer is needed, and
% since they only tended to ubscure things rather then simplify them,
% I went back to the plain \MF{} macro \texttt{beginchar}, which is
% much stronger.
%
% All in all, \texttt{unibase.mf} provides a much stronger and uniform
% frame work for character design, then did the old
% \texttt{universal.mf}.
%
% \paragraph{Thirdly:} The file names have been keept inside
% \textsc{msdos} conventions, that is first name of maximum 8
% charcaters, and last name of maximum 3 characters. This does mean,
% however, that some file names are not intutive, but I have tried to
% make them as much as I could.
%
% Also, every file associated with this font, execpt the font
% definition files (\texttt{*uni.fd}), and font driver files
% (\texttt{ful*.mf}) begins with the three letters \texttt{uni}, to
% emphasize the connection.
%
% \paragraph{Fouthly:} Some new font shapes are avaliable, as
% explained above. I found out, during the design of the characters,
% that new the base file \texttt{unibase.mf} kept showing new
% potentiality, and the extension of the font to include more shapes
% was very easy inside the frame of this base, so I thought ``What the
% heck!''
%
% \paragraph{Fifthly:} Some of the \textuni{bauhaus} symbols avaliable
% in version~1.0, has been taken out, and some new, more general
% characters have been added. Most of the absent symbols where not
% really of general use, so I decided to take them out, since I was
% never really satisfied with those anyway. This also made the font
% contain exactly 128 characters, just like a normal Computer Modern
% Roman font.
%
% \paragraph{Sixthly:} I improved the \LaTeX{} and \NFSS{} support
% considerably. The changes are legion, but let me sum up the most
% important here.
% \begin{enumerate}
%   \item Stronger font selection commands.
%   \item Command names that should be more intuitive.
%   \item Preperations for \texttt{T1} encoding.
%   \item Conformation to \LaTeXe{} style, and therefore a better
%     chance to conform with the future \LaTeX3 format.
%   \item More and better options.
% \end{enumerate}
% 
% \StopEventually{\AtEndDocument{\PrintIndex\PrintChanges}}
% 
%\iffalse
%<*package>
%\fi
% \section{\LaTeX\ Support Files}
%
% \subsection{The style file --- \texttt{uni.sty}}
% \file{uni.sty}
%
% In version~2.0, the commands in this file has been redefined using
% the macros recommended in \ftnguide{} and \clsguide{}. This should
% make the commands and macros more portable, and secure. Further, it
% should make it upward--compatiable with future releases of other
% packages and in the end \LaTeX3.
% 
% \subsubsection{Intilalizing}
%
% First we need to identify the package, its version and release 
% date, etc.
%    \begin{macrocode}
\def\fileversion{v2.0}
\def\filedate{98/08/01}
\ProvidesPackage{uni}[\filedate\space\fileversion\space universal
                          package.]
%    \end{macrocode}
% Then we setup some new \Lcs{if} commands, to help in different 
% sitations, depending on options passed to the package etc.
%    \begin{macrocode}
\newif\if@uni\@unifalse
\newif\ifstri@t\stri@tfalse
\newif\ifdef@ult\def@ultfalse
\newif\ifm@dium\m@diumfalse

%    \end{macrocode}
%
% \subsubsection{Options}
%    
% We define some options that can be passed to the package.
% Option \texttt{strict} is intended to make it possible to do
% \emph{strict} Herbert Bayer typesetting, that is only in
% minuscles. Option \texttt{default} will make the \emph{default} font
% \universal{} of the entire document, while option
% \texttt{medium} and \texttt{bold} decides wether the default font
% used by \Lcs{textuni} is normal or bold series. Finally option
% \texttt{medium} is declared default.
%    \begin{macrocode}
\DeclareOption{strict}{\stri@ttrue}
\DeclareOption{default}{\def@ulttrue}
\DeclareOption{medium}{\m@diumtrue}
\DeclareOption{bold}{\m@diumfalse}
\ExecuteOptions{medium}
\ProcessOptions\relax

%    \end{macrocode}
%
% \subsubsection{Special Characters}
%
% \begin{macro}{\uni@init}
% \begin{macro}{\DeclareUniChar}
% \Newestchanges{v2.0}{98/08/01}{Added for faster and more stable
% loading of special charactes.}
% \begin{macro}{\DeclareUniCommand}
% \Newestchanges{v2.0}{98/08/01}{Added for faster and more stable
% decleration of \universal{} commands.}
% \begin{macro}{\Declare@Uni}
% \begin{macro}{\DeclareUni@xarg}
% \begin{macro}{\DeclareUni@narg}
% \begin{macro}{\UniError}
% To facilitate the special character positions of the \universal{}
% font, we define the internal commands \Lcs{uni@init}, and the user
% commands \Lcs{DeclareUniChar} and \Lcs{DeclareUniCommand}.
%
% \Lcs{DeclareUniChar} and \Lcs{DeclareUniCommand} is very much like
% the \LaTeX{} commands \Lcs{DeclareTextSymbol} and
% \Lcs{DeclareTextCommand}, execpt we have to take into account, that
% the commands may very well be defined in \texttt{ot1enc.def} or the
% like. Since some of the characters provided with this font, is
% usually  part of an 8 bit font, I can't just use the character
% numbers straight of (this is a 7 bit font), and I have some very
% non--standard characters as well.
%
% Though the two commands differ a bit, the main mechanism is the
% same, so I will explain them together, and note the
% differences\footnote{The syntax of the macroes are explanied on
% page~\pageref{expl:cmds}.} .
% \begin{enumerate}
% \item When either of the commands is used, we first call the macro
%   \Lcs{Declare@uni}, which sets up 2 or 3 commands.
% \item Inside \Lcs{Declare@Uni}, we define \Lcs{temp@a} to be
%   \Lcs{uni@}\meta{cmd-name}, where \meta{cmd-name} is \meta{cmd}
%   stripped of the escape character (\Lcs{}).
% \item Then we check wether \Lcs{cmd} is defined.
%   \begin{itemize}
%   \item If \meta{cmd} \emph{isn't} defined, then we define
%     \Lcs{temp@c} to give \Lcs{uni@}\meta{cmd-name} (which isn't
%     defined yet) inside the \universal{} font, otherwise an error
%     message (\Lcs{UniError}).
%   \item If \meta{cmd} \emph{is} defined, we define \Lcs{temp@b} to
%     be \Lcs{no@uni@}\meta{cmd-name}, \Lcs{temp@c} to give
%     \Lcs{uni@}\meta{cmd-name} inside the \universal{} font, and
%     \Lcs{no@uni@}\meta{cmd-name} (which isn't defined yet)
%     elsewhere. Then we define \Lcs{no@uni@}\meta{cmd-name} to be
%     what \meta{cmd} currently is.
%   \end{itemize}
%   This finishes \Lcs{Declare@Uni} off.
% \item The next step depends a bit on which of the macros that is
%   utiliezed. What is coomon is that \Lcs{uni@}\meta{cmd-name} (hold
%   in \Lcs{temp@a}) is defined to be the last argument of the command. 
%   \begin{itemize}
%   \item In \Lcs{DeclareUniChar}, we define \Lcs{uni@}\meta{cmd-name}
%     via the \TeX{} command \Lcs{chardef} to be \meta{slot}, which
%     should be a number (decimal, octal, or hexal) between 0 and
%     127. Using the \TeX{} primitive will make \LaTeX{} think of
%     \meta{cmd} as a single character.
%   \item If \Lcs{DeclareUniCommand} was given an optional argument,
%     we use the command \Lcs{DeclareUni@xarg} to define
%     \Lcs{uni@}\meta{cmd-name} --- which uses \Lcs{newcommand} with
%     \emph{one} optinal argument --- to be
%     \meta{definition}. Otherwise we use \Lcs{DeclareUni@narg} ---
%     which uses \Lcs{newcommand} with \emph{no} optinal arguments ---
%     to do the trick.
%     Using the \LaTeX{} complex \Lcs{newcommand}, makes \meta{cmd} a
%     strong command.
%   \end{itemize}
% \item Finally we define \meta{cmd} to be \Lcs{temp@d}, which was the
%   conditional command defined in step 2.
% \end{enumerate}
%
% Notice the use of \Lcs{aftergroup}. This means that \meta{cmd-name}
% shouldn't be too long, i.e., $>300$ characters, which isn't a real
% limitation, but now I said it. This macro, together with the group
% in \Lcs{temp@c} is what made it possible to give arguments to
% \meta{cmd} defined by \Lcs{DeclareUniCommand}.
% 
% This way of doing things has a number of benefiets. 1) First of I
% makes it very simple to redefine the behaviour of the \universal{} 
% speciffic character commands. All you have to do is to use
% \Lcs{DeclareUniChar} or \Lcs{DeclareUniChar} in your preamble (and
% \emph{only} there). 2) Since \TeX{} are faster at evaluating
% \Lcs{if...}'s, switching to \universal{} commands should take a 
% minimum amount of time. 3) From a portability point of view, this
% way of shifting meanings of commands such as \Lcs{textquotedblleft},
% according to context, doesn't screw up older documents where the
% \textsf{uni} package is added to.
%
% There are some disadvantage. 1) Most noticably there is \emph{no} 
% conformation to \emph{any} existing encoding, which however is a
% problem of the in the font, not the \textsf{uni} package. 2)
% The heavy use of \Lcs{def}, \Lcs{edef}, and \Lcs{let}, is not
% exactly \LaTeX3 policy, but is needed here. 3) The definition of the
% commands may slow \TeX{} down a bit, but should be bearable.
%    \begin{macrocode}
\newcommand{\uni@init}{\@unitrue}
\DeclareRobustCommand{\Declare@Uni}[1]{%
  \edef\temp@{\expandafter\@gobble\string#1}
  \edef\temp@a{\csname uni@\temp@\endcsname}
  \@ifundefined{\temp@}{%
    \edef\temp@c{{%
        \noexpand\if@uni\noexpand\aftergroup\temp@a\noexpand%
        \else\noexpand\UniError{#1}\noexpand\fi}}}{%
    \edef\temp@b{\csname no@uni@\temp@\endcsname}
    \edef\temp@c{{%
      \noexpand\if@uni\noexpand\aftergroup\temp@a\noexpand%
      \else\noexpand\aftergroup\temp@b\noexpand\fi}}
    \expandafter\let\temp@b#1}}
\DeclareRobustCommand{\DeclareUniChar}[2]{%
  \Declare@Uni{#1}
  \expandafter\chardef\temp@a=#2
  \let#1\temp@c}
\def\DeclareUniCommand#1{%
  \@ifnextchar[{\DeclareUni@xarg#1}{\DeclareUni@narg#1}}
\def\DeclareUni@xarg#1[#2]#3{%
  \Declare@Uni{#1}
  \expandafter\DeclareRobustCommand\temp@a[#2]{#3}
  \let#1\temp@c}
\def\DeclareUni@narg#1#2{%
  \Declare@Uni{#1}
  \expandafter\DeclareRobustCommand\temp@a{#2}
  \let#1\temp@c}
\@onlypreamble\DeclareUniChar\relax
\@onlypreamble\DeclareUniCommand\relax
\DeclareRobustCommand{\UniError}[1]{%
  \PackageError{uni}{%
    Command \string#1 not defined outside universal font.}{%
    Correct your source file, so that \string#1 doesn't appear^^J%
    ouside of universal font, then run LaTeX again.^^J%
    Prepare your self for some gastly output.}}
%  \expandafter\show\csname no@uni@\temp@\endcsname
%  \expandafter\show\csname uni@\temp@\endcsname
%  \expandafter\show\csname \temp@\endcsname

%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% 
% \begin{macro}{\bausquare}
% \Newestchanges{v2.0}{98/08/01}{\universal{} specific
% characters declared by seperate macro.}
% \begin{macro}{\baucircle}
% \begin{macro}{\bautriangle}
% \begin{macro}{\bauhead}
% \begin{macro}{\bauforms}
% \begin{macro}{\dh}
% \begin{macro}{\ng}
% \begin{macro}{\th}
% \begin{macro}{\varQ}
% \begin{macro}{\NG}
% \begin{macro}{\TH}
% \begin{macro}{\textogonek}
% \begin{macro}{\textbraceleft}
% \begin{macro}{\textbraceright}
% \begin{macro}{\textsection}
% \begin{macro}{\textbar}
% \begin{macro}{\guilsinglleft}
% \begin{macro}{\guilsinglright}
% \begin{macro}{\textquotedblleft}
% \begin{macro}{\textquotedblright}
% \begin{macro}{\quotesinglbase}
% \begin{macro}{\quotedblbase}
% \begin{macro}{\guillemoleft}
% \begin{macro}{\guillemoright}
% \begin{macro}{\k}
% \begin{macro}{\DH}
% \begin{macro}{\DJ}
% \begin{macro}{\dj}
% \begin{macro}{\textunderscore}
% This command takes care of commands for non--standard placement, and
% symbols in the \universal{} font, while using standard \LaTeXe{}
% encodings, such as \texttt{OT1}.
%
% For instance, the symbols \textunibf{\}}, \textunibf{\{} isn't
% present in Computer Modern fonts, but is accesiable through the
% command \Lcs{}\texttt{\{}, and \Lcs{}\texttt{\}} in the \universal{}
% font. On the other hand \char"00{} isn't present in this font, but
% is replaced by \textunibf{\char"00}.
%
% Some of the commands avaliable are well--known to the \texttt{T1}
% encodeing, and are provided with the same commmand names as in that
% encoding.
%
% The decleration of these commands use my (slick) macros
% \Lcs{DcelareUniChar} and \Lcs{DcelareUniCommand} --- very neat I
% think. 
%
%    \begin{macrocode}
\DeclareUniChar{\bausquare}{"00}
\DeclareUniChar{\baucircle}{"01}
\DeclareUniChar{\bautriangle}{"02}
\DeclareUniChar{\bauhead}{"03}
\DeclareUniChar{\bauforms}{"04}
\DeclareUniChar{\dh}{"05}
\DeclareUniChar{\ng}{"06}
\DeclareUniChar{\th}{"07}
\DeclareUniChar{\varQ}{"08}
\DeclareUniChar{\NG}{"09}
\DeclareUniChar{\TH}{"0A}
\DeclareUniChar{\textogonek}{"0B}
\DeclareUniChar{\textbraceleft}{"0C}
\DeclareUniChar{\textbraceright}{"0D}
\DeclareUniChar{\textsection}{"0E}
\DeclareUniChar{\textbar}{"0F}
\DeclareUniChar{\guilsinglleft}{"22}
\DeclareUniChar{\guilsinglright}{"5C}
\DeclareUniChar{\quotesinglbase}{"2C}
\DeclareUniCommand{\quotedblbase}{\char"2C\kern-.3em\char"2C}
\DeclareUniCommand{\textquotedblleft}{``}
\DeclareUniCommand{\textquotedblright}{''}
\DeclareUniCommand{\guillemoleft}{\char"22\char"22}
\DeclareUniCommand{\guillemoright}{\char"5C\char"5C}
\DeclareUniCommand{\DH}{\raise.5ex\hbox{\char"2D}\kern-.5em D}
\DeclareUniCommand{\DJ}{\raise.5ex\hbox{\char"2D}\kern-.5em D}
\DeclareUniCommand{\dj}{\raise.75ex\hbox{\char"2D}\kern-1em d}
\DeclareUniCommand{\textunderscore}{\lower.5ex\hbox{\char"7B}}
\DeclareUniCommand{\k}[1]{%
    \leavevmode\setbox\z@\hbox{#1}\ifdim\ht\z@=1ex\accent11 #1%
    \else{\ooalign{\unhbox\z@\crcr\hidewidth\char11\hidewidth}}\fi}

%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \subsubsection{Font Selection}
% 
% \begin{macro}{\unifamily}
% \Newestchanges{v2.0}{98/08/01}{Defined \Lcs{unifamily} to
% fasilitate easier and stronger font loading.}
% The real command. This switches to \universal{} font, and can
% be used by authors in conjunction with \LaTeXe{} primitive
% \Lcs{selectfont}. \Lcs{unifamily} is used below in \Lcs{textuni...},
% and \Lcs{uni...}.
% 
% \begin{macro}{\unifamilydefault}
% \changes{v2.0}{98/08/01}{Defined to make package conform to
% \LaTeXe{} better.}
% Here \Lcs{unifamilydefault} is by default defined to be
% \texttt{uni}, but could ofcourse expand to something
% different. However, the expnasion should be a font family (like
% \texttt{cmr}) or the like.
% 
%    \begin{macrocode}
\DeclareRobustCommand\unifamily{%
  \not@math@alphabet\unifamily\relax%
  \fontfamily\unifamilydefault\selectfont}
\newcommand{\unifamilydefault}{uni}

%    \end{macrocode}
% \end{macro}
% \end{macro}
% 
% \begin{macro}{\uniseries}
% \Newestchanges{v2.0}{98/08/01}{Defined \Lcs{uniseries} to
% fasilitate easier and stronger font loading.}
% If the \texttt{bold} option is used with the \textsf{uni} package,
% then this command switches to whatever series is defined via
% \Lcs{uniseriesdefault} (default is \textbf{bold} series), otherwise
% it does nothing. Since this command is used in \Lcs{textuni} and
% \Lcs{uni}, this way will not allow anyother series if \texttt{bold}
% option is given, expect \textbf{bold}. However, if \texttt{bold}
% isn't given, then \emph{any} series is possible.
% 
% \begin{macro}{\uniseriesdefault}
% \changes{v2.0}{98/08/01}{Defined to make package conform to
% \LaTeXe{} better.}
% Here \Lcs{uniseriesdefault} is defined to be \texttt{b}
% (\textbf{medium}) if the \texttt{bold} option \emph{was} given to 
% \textsf{uni} package. Otherwise it expans to nothing
% (\Lcs{relax}). This macro is used by \Lcs{uniseries}.
%    \begin{macrocode}
\ifm@dium
  \let\uniseries\relax
  \let\uniseriesdefault\relax
\else
  \DeclareRobustCommand\uniseries{%
    \not@math@alphabet\uniseries\relax%
    \fontseries\uniseriesdefault\selectfont}
  \newcommand{\uniseriesdefault}{b}
\fi

%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\unishape}
% \Newestchanges{v2.0}{98/08/01}{Defined \Lcs{unishape} to
% fasilitate easier and stronger font loading.}
% If the \texttt{strict} option is used with the \textsf{uni} package,
% then this command switches to whatever shape is defined via
% \Lcs{unishapedefault} (default is \emph{strict} shape), otherwise
% it does nothing. Since this command is used in \Lcs{textuni} and
% \Lcs{uni}, this way will not allow anyother shape if \texttt{strict}
% option is given, expect \emph{strict}. However, if \texttt{strict}
% isn't given, then \emph{any} series is possible.
% 
% \begin{macro}{\unishapedefault}
% \changes{v2.0}{98/08/01}{Defined to make package conform to
% \LaTeXe{} better.} 
% Here \Lcs{unishapedefault} is defined to be \texttt{st}
% (\emph{strict}) if the \texttt{strict} option \emph{was} given to 
% \textsf{uni} package. Otherwise it expans to nothing
% (\Lcs{relax}). This macro is used by \Lcs{unishape}.
%    \begin{macrocode}
\ifstri@t
  \DeclareRobustCommand\unishape{%
    \not@math@alphabet\unishape\relax%
    \fontseries\unishapedefault\selectfont}
  \newcommand{\unishapedefault}{st}
\else
  \let\unishape\relax
  \let\unishapedefault\relax
\fi
%    \end{macrocode}
% \end{macro}
% \end{macro}
% 
% \begin{macro}{\stshape}
% \changes{v2.0}{98/08/01}{Defined \Lcs{stshape} to make package
% conform to \LaTeXe{} better.}
% This command selects the shape holded by \Lcs{stdefault} (defaults
% to \texttt{st} --- strict) in any family or series. This is used by
% commands \Lcs{textunist}, \Lcs{textunibst}, \Lcs{unist}, and
% \Lcs{unibst}.
% 
% \begin{macro}{\stdefault}
% \changes{v2.0}{98/08/01}{Defined to make package conform to
% \LaTeXe{} better.}
% The shape selected by \Lcs{stshape}.
%    \begin{macrocode}
\DeclareRobustCommand\stshape{%
  \not@math@alphabet\stshape\relax%
  \fontshape\stdefault\selectfont}
\newcommand{\stdefault}{st}
  
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \paragraph{Local Font Selection}
% \begin{macro}{\textuni}
% \Newestchanges{v2.0}{98/08/01}{\Lcs{textbayer} changed to
% \Lcs{textuni}, and defined using \LaTeXe{} scheme.}
% \begin{macro}{\textunirm}
% \begin{macro}{\textunibf}
% \begin{macro}{\textunisl}
% \begin{macro}{\textunisc}
% \begin{macro}{\textunibsl}
% \begin{macro}{\textunibsc}
% These are the macros that switches to \universal{} font, 
% locally, i.e., for a few words, in various series and shapes. The
% names are pretty selfexplanetory, I think. These macros will
% \emph{always} change the font series and shape accroding to it's
% definiton, nothing more, and nothing less, exepct \Lcs{textuni},
% which only changes the cuurent family to \texttt{uni}. Notice it
% simply uses the \Lcs{unifamily} command to do the trick.
%
% The second argument to \Lcs{DeclareTextFontCommand} should not
% normally contain commands that typeset, or commands not relevant to
% the selection of fonts, but to make up for the non--default
% characeters and character placements, we \emph{do} include
% \Lcs{uni@init} in the argument.
%
% Notice that only \Lcs{textuni} is defined if option \texttt{strict}
% was given to \textsf{uni} package.
%    \begin{macrocode}
\DeclareTextFontCommand{\textuni}{%
  \uni@init\unifamily\uniseries\unishape}
\ifstri@t
\else
  \DeclareTextFontCommand{\textunirm}{%
    \uni@init\unifamily\mdseries\upshape}
  \DeclareTextFontCommand{\textunibf}{%
    \uni@init\unifamily\bfseries\upshape}
  \DeclareTextFontCommand{\textunisl}{%
    \uni@init\unifamily\mdseries\slshape}
  \DeclareTextFontCommand{\textunisc}{%
    \uni@init\unifamily\mdseries\scshape}
  \DeclareTextFontCommand{\textunist}{%
    \uni@init\unifamily\mdseries\stshape}
  \DeclareTextFontCommand{\textunibsl}{%
    \uni@init\unifamily\bfseries\slshape}
  \DeclareTextFontCommand{\textunibsc}{%
    \uni@init\unifamily\bfseries\scshape}
  \DeclareTextFontCommand{\textunibst}{%
    \uni@init\unifamily\bfseries\stshape}
\fi
  
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \paragraph{Global Font Selection}
% \begin{macro}{\uni}
% \Newestchanges{v2.0}{98/08/01}{\Lcs{bayer} changed to \Lcs{uni}}
% \begin{macro}{\unibf}
% \begin{macro}{\unibf}
% \begin{macro}{\unisl}
% \begin{macro}{\unisc}
% \begin{macro}{\unibsl}
% \begin{macro}{\unibsc}
% These macros works as \Lcs{textuni...} above, execpt the take effect
% from the point used, to the end of the current group. Again font
% selection is \emph{exactly} as given in the command name, execpt for
% \Lcs{uni} which only changes the family.
%
% Notice that only \Lcs{uni} is defined if option \texttt{strict}
% was given to \textsf{uni} package.
%    \begin{macrocode}
\DeclareOldFontCommand{\uni}{%
  \uni@init\unifamily\uniseries\unishape}{}
\ifstri@t
\else
  \DeclareOldFontCommand{\unirm}{%
    \uni@init\unifamily\mdseries\upshape}{}
  \DeclareOldFontCommand{\unibf}{%
    \uni@init\unifamily\bfseries\upshape}{}
  \DeclareOldFontCommand{\unisl}{%
    \uni@init\unifamily\mdseries\slshape}{}
  \DeclareOldFontCommand{\unisc}{%
    \uni@init\unifamily\mdseries\scshape}{}
  \DeclareOldFontCommand{\unist}{%
    \uni@init\unifamily\mdseries\stshape}{}
  \DeclareOldFontCommand{\unibsl}{%
    \uni@init\unifamily\bfseries\slshape}{}
  \DeclareOldFontCommand{\unibsc}{%
    \uni@init\unifamily\bfseries\scshape}{} 
  \DeclareOldFontCommand{\unibst}{%
    \uni@init\unifamily\bfseries\stshape}{} 
\fi

%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \paragraph{\texttt{default} Option Font} 
% Now if you gave the \texttt{default} option to the package,
% \Lcs{ifdef@ult} evaluates to true, and so we setup the default font
% to be \universal{}, in the medium or bold version, depending
% on wether you gave the \texttt{medium} option or not.
%    \begin{macrocode}
\ifdef@ult
  \renewcommand{\familydefault}{uni}
  \ifm@dium\renewcommand{\seriesdefault}{m}
  \else\renewcommand{\seriesdefault}{b}\fi
  \renewcommand{\itdefault}{sl}
%    \end{macrocode}
% \begin{macro}{\cmrfamily}
% \begin{macro}{\cmrdefault}
% \begin{macro}{\textcmr}
% \begin{macro}{\cmr}
% We define \Lcs{cmrfamily} and \Lcs{cmrdefault} to change back to
% Computer Modern Roman font, if so wanted. The macros \Lcs{textcmr}
% and \Lcs{cmr} are the logical extensions of \Lcs{cmrfamily}.
%    \begin{macrocode}
  \DeclareRobustCommand\cmrfamily{%
    \not@math@alphabet\cmrfamily\relax%
    \fontencoding\cmrenc\fontfamily\cmrdefault\selectfont}
  \newcommand{\cmrdefault}{cmr}
  \newcommand{\cmrenc}{OT1}
  \DeclareTextFontCommand{\textcmr}{\cmrfamily}
  \DeclareOldFontCommand{\cmr}{\cmrfamily}{}
\fi

%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
%\iffalse
%</package>
%\fi
% \subsection{The Font Definition Files --- \texttt{*uni.fd}}
%
% These files is needed in the New Font Selection Scheme, used by
% \LaTeXe{}, but really isn't nessecary for pure \TeX{} or \LaTeX2.09
% users, but since those are treathned races, I did put in the extra
% effort and made the files.
%
% What they really do, is to speciffy what font driver file should be
% loaded when the user swichtes font. Notice, alot of the font shapes
% etc.\ avaliable in the Computer Modern Roman scheme isn't avaliable
% in the \universal{} font, so we substitute with whatever is
% closest, something from the \universal{} or Computer Modern
% Roman scheme.
%
% The reason why the file names may look a bit wierd, is to make the
% font conform to the standard set by \texttt{fontname} used by
% \texttt{kpathsea} in most \TeX{}, \LaTeX{}, and \MF{} systems.
% 
% \paragraph*{Math Encoding}\file{oml.fd}
% First comes the the font definition file for \emph{math}, but since
% no math characters is  defined in the \universal{} font, we
% substitute with the relevant fonts from Computer Modern Roman.
%\iffalse
%<*oml>
%\fi
%    \begin{macrocode}
\ProvidesFile{omluni.fd}
        [1998/08/01 v2.0 Non Standard LaTeX font definitions]
\DeclareFontFamily{OML}{uni}{\skewchar\font127 }
\DeclareFontShape{OML}{uni}{m}{n}{<-> ssub * cmm/m/it}{}
\DeclareFontShape{OML}{uni}{m}{it}{<-> ssub * cmm/m/it}{}
\DeclareFontShape{OML}{uni}{m}{sl}{<-> ssub * cmm/m/it}{}
\DeclareFontShape{OML}{uni}{m}{sc}{<-> ssub * cmm/m/it}{}
\DeclareFontShape{OML}{uni}{bx}{n}{<-> ssub * cmm/b/it}{}
\DeclareFontShape{OML}{uni}{bx}{it}{<-> ssub * cmm/b/it}{}
\DeclareFontShape{OML}{uni}{bx}{sl}{<-> ssub * cmm/b/it}{}
\DeclareFontShape{OML}{uni}{bx}{sc}{<-> ssub * cmm/b/it}{}

%    \end{macrocode}
%\iffalse
%</oml>
%\fi
%
% \paragraph*{Symbols Encoding}\file{omsuni.fd}
% Next is the definitions for \emph{symbols} fonts, but as above,
% there is no seperate symbol font defined for the \universal{}
% font, so we substitute for default.
%\iffalse
%<*oms>
%\fi
%    \begin{macrocode}
\ProvidesFile{omsuni.fd}
        [1998/08/01 v2.0 Non Standard LaTeX font definitions]
\DeclareFontFamily{OMS}{uni}{\skewchar\font48 }
\DeclareFontShape{OMS}{uni}{m}{n}{<-> ssub * cmsy/m/n}{}
\DeclareFontShape{OMS}{uni}{m}{it}{<-> ssub * cmsy/m/n}{}
\DeclareFontShape{OMS}{uni}{m}{sl}{<-> ssub * cmsy/m/n}{}
\DeclareFontShape{OMS}{uni}{m}{sc}{<-> ssub * cmsy/m/n}{}
\DeclareFontShape{OMS}{uni}{bx}{n}{<-> ssub * cmsy/b/n}{}
\DeclareFontShape{OMS}{uni}{bx}{it}{<-> ssub * cmsy/b/n}{}
\DeclareFontShape{OMS}{uni}{bx}{sl}{<-> ssub * cmsy/b/n}{}
\DeclareFontShape{OMS}{uni}{bx}{sc}{<-> ssub * cmsy/b/n}{}

%    \end{macrocode}
%\iffalse
%</oms>
%\fi
% 
% \paragraph*{Normal Encoding}\file{ot1uni.fd}
% Now the definitions for the normal font. This \emph{is} ofcourse
% defined, anything else would be ludicruis. It is very straight
% forward most of the way. However, notice the substitutions at the
% end of the file.
%
%\iffalse
%<*ot1>
%\fi
%    \begin{macrocode}
\ProvidesFile{ot1uni.fd}%
  [1998/08/01 v2.0 Non standard LaTeX font definitions]
\DeclareFontFamily{OT1}{uni}{\hyphenchar\font45 }
  
%    \end{macrocode}
% Next comes the specifications of what to load in \textunirm{normal
% upright shape}
%    \begin{macrocode}
\DeclareFontShape{OT1}{uni}{m}{n}{
  <5><6><7><8>fulmr8
  <9>fulmr9
  <10><10.95>fulmr10
  <12><14.4>fulmr12
  <17.28><20.74><24.88>fulmr17
  }{}
  
%    \end{macrocode}
% Next comes the specifications of what to load in \textunisl{normal
% slanted shape}
%    \begin{macrocode}
\DeclareFontShape{OT1}{uni}{m}{sl}{
  <5><6><7><8>fulmo8
  <9>fulmo9
  <10><10.95>fulmo10
  <12><14.4>fulmo12
  <17.28><20.74><24.88>fulmo17
  }{}
  
%    \end{macrocode}
% Now for \textunisc{small caps medium} definitions.
%    \begin{macrocode}
\DeclareFontShape{OT1}{uni}{m}{sc}{
  <5><6><7><8>fulmc8
  <9>fulmc9
  <10><10.95>fulmc10
  <12><14.4>fulmc12
  <17.28><20.74><24.88>fulmc17
  }{}

%    \end{macrocode}
% Now for \textunist{strict medium} definitions.
%    \begin{macrocode}
\DeclareFontShape{OT1}{uni}{m}{st}{
  <5><6><7><8>fulmst8
  <9>fulmst9
  <10><10.95>fulmst10
  <12><14.4>fulmst12
  <17.28><20.74><24.88>fulmst17
  }{}

%    \end{macrocode}
% Next comes the specifications of what to load in \textunibf{bold
% face upright shape}
%    \begin{macrocode}
\DeclareFontShape{OT1}{uni}{b}{n}{
  <5><6><7><8>fulbr8
  <9>fulbr9
  <10><10.95>fulbr10
  <12><14.4>fulbr12
  <17.28><20.74><24.88>fulbr17
  }{}
  
%    \end{macrocode}
% Next comes the specifications of what to load in
% \textunibsl{bold face slanted shape}
%    \begin{macrocode}
\DeclareFontShape{OT1}{uni}{b}{sl}{
  <5><6><7><8>fulbo8
  <9>fulbo9
  <10><10.95>fulbo10
  <12><14.4>fulbo12
  <17.28><20.74><24.88>fulbo17
  }{}
    
%    \end{macrocode}
% And \textunibsc{small caps bold face} definitions.
%    \begin{macrocode}
\DeclareFontShape{OT1}{uni}{b}{sc}{
  <5><6><7><8>fulbc8
  <9>fulbc9
  <10><10.95>fulbc10
  <12><14.4>fulbc12
  <17.28><20.74><24.88>fulbc17
  }{}
    
%    \end{macrocode}
% And \textunibst{strict bold face} definitions.
%    \begin{macrocode}
\DeclareFontShape{OT1}{uni}{b}{st}{
  <5><6><7><8>fulbst8
  <9>fulbst9
  <10><10.95>fulbst10
  <12><14.4>fulbst12
  <17.28><20.74><24.88>fulbst17
  }{}
    
%    \end{macrocode}
%
% Now for the substitutions. This is straight forward, that
% is, upright slanted is substituted by upright; bold face condensed,
% and bold face extra is substituted by boldface; and italic by
% slanted\footnote{As mentioned earlier, one of the characteristics
% of this dont, is that it has no serifs, so it would be strange
% to include italics in this font.}.
%     \begin{macrocode}
\DeclareFontShape{OT1}{uni}{m}{it}{<->ssub*uni/m/sl}{}
\DeclareFontShape{OT1}{uni}{m}{ui}{<->ssub*uni/m/n}{}
\DeclareFontShape{OT1}{uni}{b}{it}{<->ssub*uni/b/sl}{}
\DeclareFontShape{OT1}{uni}{bx}{n}{<->ssub*uni/b/n}{}
\DeclareFontShape{OT1}{uni}{bx}{sl}{<->ssub*uni/b/sl}{}
\DeclareFontShape{OT1}{uni}{bx}{sc}{<->ssub*uni/b/sc}{}
\DeclareFontShape{OT1}{uni}{bx}{st}{<->ssub*uni/b/st}{}
\DeclareFontShape{OT1}{uni}{bx}{it}{<->ssub*uni/b/sl}{}
\DeclareFontShape{OT1}{uni}{bc}{ui}{<->ssub*uni/b/n}{}
\DeclareFontShape{OT1}{uni}{sbc}{n}{<->ssub*uni/b/n}{}

%    \end{macrocode}
%\iffalse
%</ot1>
%\fi
%
% \paragraph*{T1 encoding}\file{t1uni.fd}
% Since the T1 encoding relies on the font scheme of \texttt{exbase}
% (EC fonts), and \texttt{dxbase} (DC fonts), by J\"org Knappen and
% Nobert Schwartz, which is a whole new way of making fonts, that
% requires some special messaures that I couldn't incorporate into the
% \universal{} font without a whole lot of work, I chose not to
% make support for the T1 scheme. Therefore this file issues a warning
% and then exists the whole \LaTeX{} run. This may seem a bit drastic,
% but it ensures that you don't get screwed up resuats.
%\iffalse
%<*t1>
%\fi
%    \begin{macrocode}
\ProvidesFile{t1uni.fd}
        [1998/08/01 v2.0 Non Standard LaTeX font definitions]
\typeout{WARNING: universal font not avaliable in t1 definition.}
\typeout{WARNING: exiting, correct your source.}
\stop

%    \end{macrocode}
%\iffalse
%</t1>
%\fi
%
% \paragraph*{U Encoding}\file{uuni.fd}
% This is similar to the normal encoding above, execpt encoding is U. 
%\iffalse
%<*u>
%\fi
%    \begin{macrocode}
\ProvidesFile{uuni.fd}
        [1998/08/01 v2.0 Non Standard LaTeX font definitions]
\DeclareFontFamiliy{U}{uni}{\hyphenchar\font45}
\DeclareFontShape{U}{uni}{m}{n}{
  <5><6><7><8>fulmr8
  <9>fulmr9
  <10><10.95>fulmr10
  <12><14.4>fulmr12
  <17.28><20.74><24.88>fulmr17
  }{}
\DeclareFontShape{U}{uni}{m}{sl}{
  <5><6><7><8>fulmo8
  <9>fulmo9
  <10><10.95>fulmo10
  <12><14.4>fulmo12
  <17.28><20.74><24.88>fulmo17
  }{}
\DeclareFontShape{U}{uni}{m}{sc}{
  <5><6><7><8>fulmc8
  <9>fulmc9
  <10><10.95>fulmc10
  <12><14.4>fulmc12
  <17.28><20.74><24.88>fulmc17
  }{}
\DeclareFontShape{U}{uni}{m}{st}{
  <5><6><7><8>fulmst8
  <9>fulmst9
  <10><10.95>fulmst10
  <12><14.4>fulmst12
  <17.28><20.74><24.88>fulmst17
  }{}
\DeclareFontShape{U}{uni}{b}{n}{
  <5><6><7><8>fulbr8
  <9>fulbr9
  <10><10.95>fulbr10
  <12><14.4>fulbf12
  <17.28><20.74><24.88>fulbr17
  }{}
\DeclareFontShape{U}{uni}{b}{sl}{
  <5><6><7><8>fulbo8
  <9>fulbo9
  <10><10.95>fulbo10
  <12><14.4>fulbo12
  <17.28><20.74><24.88>fulbo17
  }{}
\DeclareFontShape{U}{uni}{b}{sc}{
  <5><6><7><8>fulbc8
  <9>fulbc9
  <10><10.95>fulbc10
  <12><14.4>fulbc12
  <17.28><20.74><24.88>fulbc17
  }{}
\DeclareFontShape{U}{uni}{b}{st}{
  <5><6><7><8>fulbst8
  <9>fulbst9
  <10><10.95>fulbst10
  <12><14.4>fulbst12
  <17.28><20.74><24.88>fulbst17
  }{}
\DeclareFontShape{U}{uni}{m}{it}{<->ssub*uni/m/sl}{}
\DeclareFontShape{U}{uni}{m}{ui}{<->ssub*uni/m/n}{}
\DeclareFontShape{U}{uni}{b}{it}{<->ssub*uni/b/sl}{}
\DeclareFontShape{U}{uni}{bx}{n}{<->ssub*uni/b/n}{}
\DeclareFontShape{U}{uni}{bx}{sl}{<->ssub*uni/b/sl}{}
\DeclareFontShape{U}{uni}{bx}{sc}{<->ssub*uni/b/sc}{}
\DeclareFontShape{U}{uni}{bx}{st}{<->ssub*uni/b/st}{}
\DeclareFontShape{U}{uni}{bx}{it}{<->ssub*uni/b/sl}{}
\DeclareFontShape{U}{uni}{bc}{ui}{<->ssub*uni/b/n}{}
\DeclareFontShape{U}{uni}{sbc}{n}{<->ssub*uni/b/n}{}
        
%    \end{macrocode}
%\iffalse
%</u>
%\fi

%\iffalse
%<*unibase>
%\fi
%
% \section{The Font Macros and Programs}
%
% \subsection{Base file --- \texttt{unibase.mf}}
% \file{unibase.mf}
% \Newestchanges{v2.0}{98/08/01}{Base file \texttt{unibase.mf} swa the
% light of day, providing many driver, font control, and drawing
% macros.} 
%
% This file defines all the macroes used in the source programs
% for the font. I could have chosen to use \texttt{cmbase}, but
% rather then defining a lot of variables that isn't used, I chose
% to make a base file myself. Also, some af the drawing macros
% presented here still needed to be defined. This file could be
% made into a binary file, but I think that would be a bit to
% much.
%
% First we define the variable \texttt{unibase}, to check later if
% this file has been loaded.
%    \begin{macrocode}
unibase := 1 ;
string univer ;
univer = "2.0" ;
if proofing > 1 :
  message "Base file for font `universal', version " & univer ;
fi
%    \end{macrocode}
% Secondly, we define the variables \texttt{medium} and \texttt{bold}
% to control the font serie to be produced. If \texttt{medium} is set
% to \textsl{true} in the driver file, then a medium series
% (\Lcs{mdseries}) font will be produced, while \texttt{bold} ofcourse
% generates a boldface font. The medium serie may very well be
% more suitiable for long texts then the default font.  In $10pt$
% the default thickness of the pen is $\frac{5}{6}pt\approx 0.8pt$
% wide for the minuscles, and a bit wider for the majuscules. If
% \texttt{medium} is \texttt{true} then it is $\frac{5}{9}pt\approx
%   0.6pt$ wide.
%
% Booleans \texttt{slant} and \texttt{caps} is used to control the
% shape of the font. If both is \textsl{false} a normal (upright)
% shaped font (\Lcs{upshape}) font is generated. If \texttt{slant} or
% \texttt{caps} is true, either a slanted (\Lcs{slshape}) or small
% caps (\Lcs{scshape}) shaped font is generated. The values of these
% booleans should be set in the driver file, \emph{before} any call to
% \texttt{start\_font}.
%    \begin{macrocode}
boolean medium , slant , bold , caps , strict ;
medium := false ; slant := false  ; bold := false ;
caps := false   ; strict := false ;
%    \end{macrocode}
% And then the font is identified as \texttt{"universal"}.
%    \begin{macrocode}
font_identifier:="universal"; 

%    \end{macrocode}
%
% \subsubsection{Font macros}
%
% These macroes have to do with the general initialization and 
% production of the font. The macros needed later on is
% \texttt{start\_font}, and \texttt{end\_font}.
%
% The general idea is, that as little as possible should be 
% defined in the driver file, so that the font will have a uniform
% look in all series, shapes, and sizes.  All that is needed in the
% driver file is to  define some of the above booleans to true, call
% the macro \texttt{start\_font} giving it the size (in \texttt{pt\#})
% of the font as argument, include of source files, and call the macro
% \texttt{end\_font}. 
%
% \begin{fontmacro}{start\_font}
% This is the macro for setting up the needed dimensions and 
% variables. First we take into acount the \textit{mode} used, by
% calling \texttt{mode\_setup}, then we define the correct,
% \textit{sharped} units, bassed on the argument to the macro, wich
% should be the size of the font in \texttt{pt\#}.
%    \begin{macrocode}
def start_font(expr size) =	
  u# := size/18 ;	
  mode_setup;
  x_h# :=  8u# ; x_w# := 8u#   ; m_w# := 11u# ; l_h# := 13u# ;
  p_d# :=  5u# ; l_s# := 2u#   ; r_s# :=  2u# ; A_w# := 10u# ;
  M_w# := 14u# ; c_d# := 3u#/2 ; C_d# :=  2u# ;
%    \end{macrocode}
% We test to see, if any of the above booleans is set to
% \textsl{true}, and if so, takes appropiate action. If
% \texttt{medium} is set, the pens gets thinner, thereby producing  
% a lighter font. If \texttt{bold} the pens gets thicker, and so a
% heavier font is produced. If \texttt{slant} is set, then the
% inclination (\texttt{slantratio}) of the font is assigned.
%
% No other dimensions then the pen thickness should be differ among
% the \emph{medium} and \emph{bold} font. However, two dimension
% \texttt{c\_d} and \texttt{C\_d} is always set to the same value as
% the pens would be in the current size, if the font to be made was
% \emph{bold}.
%
% Also notice, that two different pens thicknesses is defined
% \texttt{p\_t} and \texttt{P\_t}, so that the majuscules may come out
% a bit thicker then the minuscles. Ofcourse this adds to the
% complexity of the drawing macroes defined below, but in a very
% straight forward way, so I dont't think it will be a problem.
%
% Then we set \texttt{currenttransform} to take into account the
% varibale \texttt{slantratio}. 
%    \begin{macrocode}
  if (medium and bold) :
    message "Font can't be both medium and bold, making medium font." ;
    medium := true ;
  fi;
  if medium : p_t# := 2u#/3 ; P_t# := u#    ; P_T# := u#  ; fi ; 
  if bold :   P_T# := 3u#/2 ; p_t# := 3u#/2 ; P_t# := 2u# ; fi ; 
  a_h# := x_h#+p_t#/2 ;
  if (slant and (caps or strict)) : double_shape := 1 ; fi ;
  if (caps and (slant or strict)) : double_shape := 1 ; fi ;
  if (strict and (caps or slant)) : double_shape := 1 ; fi ;
  if known double_shape :
    message "Font cannot be two shapes, doing upright shape." ;
    slant := false ; caps := false ; strict := false ;
  fi ;
  if slant : slantratio := 1/6 ; else: slantratio := 0 ; fi ;
  currenttransform := identity slanted slantratio ;
%    \end{macrocode}
% We need to set some paramteres for the Font Metric File
% (\texttt{*.tfm}), so that \TeX{} knows how to typeset the characters
% of the font. This is pretty straight, as desribed in the \MFbook{}.
%    \begin{macrocode}
  font_x_height 8u#                 ; font_quad 12u#+2u#       ;
  font_normal_space 8u#             ; font_normal_stretch 3u# ; 
  font_normal_shrink 2u#            ; font_extra_space 2u#    ; 
  font_coding_scheme:="TeX text"    ; font_size 18u#        ;
%    \end{macrocode}
% Next we assigns some variables we need later on, defines the
% \emph{un\/}sharped (mode dependent) units, declares some variables
% for later use, and call the macro \texttt{do\_pens} to save the pens
% needed by the font.
%    \begin{macrocode}
  spanish_shriek:=hex"3C"           ; spanish_query:=hex"3E";
  define_pixels(u,x_h,x_w,m_w,l_h,p_d,A_w,M_w,c_d,C_d,a_h);
  define_blacker_pixels(p_t,P_t,P_T);
  picture e_pic, a_pic ;
  do_pens ;
%    \end{macrocode}
% The definitions of \texttt{extra\_beginchar} and 
% \texttt{extra\_endchar} is responsible for the extra stem width
% of the font. Since this font is pretty uniform in width, we 
% can easily do this globally. I got the trick from \texttt{cmbase},
% where you instead use \texttt{adjust\_fit} after \texttt{beginchar}.
% However, for the above reasons, and because it lessens the source
% programs considerably, I chose to do it this way.
%
% The inclusion of the assignement
% \begin{verbatim}
%   charcode := charcode + code_offset ;
% \end{verbatim}
% is for the small caps font, so that characters may be placed at
% non--standard positions in the font. When we are not making a small
% caps font, \texttt{code\_offset} should ofcourse be set to 0 (zero).
%    \begin{macrocode}
  extra_beginchar := extra_beginchar&"fit_font;" ;
  extra_endchar   := extra_endchar&
    "end_fit_font;extra_proof_rules;charcode:=charcode+code_offset;" ; 
  code_offset := 0 ;
enddef;

%    \end{macrocode}
% \end{fontmacro}
% 
% \begin{fontmacro}{do\_pens}
% This macro is used to set up the pens needed in this font. It is
% called every time one of the dimensions \texttt{p\_t\#} or
% \texttt{P\_t\#} is changed, since those are the \texttt{p/P}en
% \texttt{t/T}hicknesses.
%
% Apart from saving a lot of time, as explained in the \MFbook{}, this
% also garanties, that all pens are transformed correctly when the
% font shape is \textsl{slanted}.
%    \begin{macrocode}
def do_pens =
  clear_pen_memory ;
  pickup pencircle scaled P_T slanted slantratio ;
  UniPencir := savepen ;
  pickup pencircle scaled p_t slanted slantratio ;
  unipencir := savepen ;
  pickup pencircle scaled P_t slanted slantratio ;
  Unipencir := savepen ; 
  pickup pensquare scaled P_T slanted slantratio ;
  UniPensqu := savepen ;
  pickup pensquare scaled p_t slanted slantratio ;
  unipensqu := savepen ;
  pickup pensquare scaled P_t slanted slantratio ;
  Unipensqu := savepen ; 
enddef ;

%    \end{macrocode}
% \end{fontmacro}
%
% \begin{fontmacro}{fit\_font}
% This is the macro that changes the width of the font. It is
% derived from \texttt{cmbase}s \texttt{normal\_adjust\_fit}, though
% used in a slightly different way here. As explained in the \MFbook,
% this is a very nice macro, since it is essesially an add--on 
% feature. We still specify the width of character in 
% \texttt{beginchar}, and \texttt{w} is still this dimension. However,
% extra space is added to the character at both the left and right,
% so that characters don't get too close.
%    \begin{macrocode}
def fit_font =
  l := -hround(l_s#*hppp) ; interim xoffset := -l ; 
  charwd := charwd+l_s#+r_s# ; r := l+hround(charwd*hppp) ; 
  w := r-hround(r_s#*hppp) ;
  italcorr charht*slantratio ;
enddef;

%    \end{macrocode}
% \end{fontmacro}
% \begin{fontmacro}{end\_fit\_font}
% Again, this is taken from \texttt{cmbase}, so that extra space is
% added on the sides of the character.
%    \begin{macrocode}
def end_fit_font =
  w := r+l ;
enddef;

%    \end{macrocode}
% \end{fontmacro}
%
% \begin{fontmacro}{extra\_proof\_rules}
% When doing proofing, it is nice to have some extra rules on the
% proofs, so that errors and mistakes are easiler seen. This macro
% does just that. A verticatal rule is produced at the left and 
% right edge, and through the middle of the character. Horizontal
% rules are produced at one quarter, half, and three quarters of the
% character height. Also, if the charcter extence below the baseline,
% a rule is produced at one half the depth.
%    \begin{macrocode}
def extra_proof_rules =
  if proofing > 1 :
    for xa = l,r,w/2: proofrule((xa,-d), (xa,h)) ; endfor ;
    for ya = 0,h/4,h/2,3h/4,h: proofrule((l,ya), (r,ya)) ; endfor ;
    if d > 0 :
      proofrule((l,-d/2), (r,-d/2)) ;
      proofrule((l,-d), (r,-d)) ;
    fi
  fi
enddef ;

%    \end{macrocode}
% \end{fontmacro}
% \begin{fontmacro}{end\_font}
% \texttt{end\_font} is used at the end of the driver file, to set
% ligatures, and end of the file. There is nothing fancy here. Do,
% however, notice no `f' ligatures is defined, as in the Computer
% Modern Roman. This is because they are not meant to be there, 
% because `ff' shouldn't come out as `\textunibf{f\kern-.25ex f}', 
% which looks bad, but rather as `\textunibf{ff}'.
%
% Also notice, that we haven't defined any characters \textunibf{``}
% or \textunibf{''}, since we make these up of two \textunibf{`} or
% \textunibf{'}. This gives us two more slots we can put other
% characters into.
%    \begin{macrocode}
inner bye;  % so we can use it inside a macro
def end_font =
  ligtable "u" : "h" kern u# ;
  ligtable "f" : "f" kern 0 , "l" kern 0 , "i" kern 0 ;
  ligtable "o" : "l" kern u# ; 
  ligtable "?" : "`" =: spanish_query ;
  ligtable "!" : "`" =: spanish_shriek ;
  ligtable "`" : "`" kern -l_s#-r_s#+p_t# ;
  ligtable "'" : "'" kern -l_s#-r_s#+p_t# ,
    "?" kern 2u#, "!" kern 2u# ;
  ligtable "-"     : "-" =: hex"7B" ;
  ligtable hex"7B" : "-" =: hex"7C" ;
  ligtable hex"22" : hex"22" kern -l_s#-r_s# ;
  ligtable hex"5C" : hex"5C" kern -l_s#-r_s# ;
  ligtable hex"20" :
    "l" kern -3c_d#*cosd(15)-p_t#*sind(15)-l_s#-r_s# ,
    "L" kern -3c_d#*cosd(15)-p_t#*sind(15)-l_s#-r_s# ;
  bye
enddef;

%    \end{macrocode}
% \end{fontmacro}
% \begin{fontmacro}{do\_caps}
% This next macro is for the \textunisc{small caps} version of the
% font. Most of it is taken from \texttt{csc.mf} of the Computer
% Modern Font, though not as many dimensions have been redefined in
% this macro. The idea is to utilize this macro whenever you want to
% make a small caps version of majuscles. This macro is used in both
% \texttt{unilow.mf} and \texttt{unilig.mf}.
%
% The argument to \texttt{do\_caps} is the number the new characters
% should be offset from it's original position in the font.
% 
% The last \texttt{do\_pens} is needed, since the programs uses saved
% pens, and we have just redefined the dimensions for the pens.
%     \begin{macrocode}
def do_caps(expr offset) =
  sc_shrink := x_h#/l_h# ;
  P_t# := sc_shrink*P_t# ; l_h# := sc_shrink*l_h# ;
  A_w# := sc_shrink*A_w# ; M_w# := sc_shrink*M_w# ;
  C_d# := sc_shrink*C_d# ;
  code_offset := offset ;
  define_pixels(l_h,A_w,M_w,C_d) ;
  define_blacker_pixels(P_t) ;
  do_pens ;
enddef ;

%    \end{macrocode}
% \end{fontmacro}
% \begin{fontmacro}{end\_do\_caps}
% When ever we need to get back to the default setting of dimensions,
% after the use of \texttt{do\_caps}, we call on this macro to do the
% job. The idea is to multiply by \texttt{no\_shrink} which is the
% reciprocal of \texttt{sc\_shrink}.
%     \begin{macrocode}
def end_do_caps =
  no_shrink := 1/sc_shrink ;
  P_t# := no_shrink*P_t# ; l_h# := no_shrink*l_h# ;
  A_w# := no_shrink*A_w# ; M_w# := no_shrink*M_w# ;
  C_d# := no_shrink*C_d# ;
  code_offset := 0 ;
  define_pixels(l_h,A_w,M_w,C_d) ;
  define_blacker_pixels(P_t) ;
  do_pens ;
enddef ;

%    \end{macrocode}
% \end{fontmacro}
%
% \subsubsection{Control macroes}
%
% These macroes are designed to ease the control of individual
% characters.
%
% \begin{fontmacro}{no\_adjust}
% If a character is not supposed to have extra space on either side
% you can say \texttt{no\_adjust} just before
% \begin{quote}
%   \texttt{extra\_beginchar := extra\_beginchar\&"}
%     \meta{your begin char stuff}\texttt{";}\\
%   \texttt{extra\_endchar := extra\_endchar\&"}
%     \meta{your stuff endchar stuff}\texttt{";}\\
%   \texttt{beginchar(}\meta{usual arguments}\texttt{);}
% \end{quote}
% where the two string assigments are optional.
%    \begin{macrocode}
def no_adjust=
  old_begin_adjust := extra_beginchar ;
  old_end_adjust   := extra_endchar   ;
  extra_beginchar  := " "             ;
  extra_endchar    :=
  "extra_proof_rules;charcode:=charcode+code_offset" ; 
enddef;

%    \end{macrocode}
% \end{fontmacro}
%
% \begin{fontmacro}{restore\_adjust}
% Use this command to restore automaticly adding extra space around
% the characters. Must be used between a \texttt{endchar} and 
% \texttt{beginchar}.
%    \begin{macrocode}
def restore_adjust=
  extra_beginchar  := old_begin_adjust   ;
  extra_endchar    := old_end_adjust     ;
enddef;
string old_begin_adjust, old_end_adjust ;

%    \end{macrocode}
% \end{fontmacro}
%
% \subsubsection{Drawing macroes}
%
% I have made this macros for drawing, to ease up the writing of 
% source programs. They all simulate a pen of breadth \textit{thick}
% always moving perpendecular to the current path. This is needed
% in the \universal{} font, since all pen breadths are supposed
% to be equal anywhere (at least within a paricular `group'), in any
% direction.  
%
% All of the macros heavely use \texttt{penpos}, so the use
% is pretty reliant on the appropiate use of this macro. This
% put some restrictions on the arguments, since \texttt{penpos}
% deals with angles of all sorts.
%
% In the macroes, we use vectors with number $m$, as assigened in the
% last argument of the macros. $m$ should be assigend so that the
% vectors $m,m+1,\ldots,m+4$ does not conflict with already assigned
% vectors, or vectors to be assigend in the current picture.
%
% Though it may seem a somewhat \textit{ad hoc} solution, it is the
% best way I could think of. Ofcourse I could check to see what
% vectors are defined, and then use some others, but that would
% complicate the code unessecary, and since the idea is to hide the
% actual vector operations in the macros, I descided to use the
% course. 
%
% (No labels are produced on the proofsheets by this macroes,
% since they use very  high numbers, which is rather destracting.)
%
% \begin{fontmacro}{unicir}
% Draws a circle of outer radius \texttt{rad}, and centered at 
% \texttt{center}, which shoud be a pair. Notice, no effort is
% made to keep the circle within the character, so the use of
% this macro, should be governed with some caution.
%
% The second argument is the \emph{thickness} of the pen drawing the
% segment.
%
% The last argument \texttt{m} is to insure the uniqueness of
% all pairs. That is, if you need more then one circle in a letter,
% then \texttt{m} should take different values for each circle, so that
% $m_{i}-m_{i+1}>4$. Also \texttt{m} should not take any value
% corrosponing to vectors already defined. This is most easily done if
% \texttt{m} is asigned a large value, like say a multipla of 10, or
% even 100. 
%    \begin{macrocode}
def unicir(expr rad, thick, center, m)=
  pickup pensquare scaled thick;
  top z[m]   = (0,rad)  + center ; penpos[m](thick,90) ;
  lft z[m+1] = (-rad,0) + center ; penpos[m+1](thick,180) ;
  bot z[m+2] = (0,-rad) + center ; penpos[m+2](thick,270) ;
  rt  z[m+3] = (rad,0)  + center ; penpos[m+3](thick,0) ;
  penstroke z[m]e{left}..z[m+1]e{down}..
    z[m+2]e{right}..z[m+3]e{up}..cycle ; 
  penlabels(range m thru m+3);
enddef;

%    \end{macrocode}
% \end{fontmacro}
%
% \begin{fontmacro}{uniarc}
% Produce a segment of a circle, with radius \texttt{rad}, and
% centered at \texttt{center}.
%
% The size of the segment is determind by the arguments
% \texttt{ang\_a} and \texttt{ang\_b}, consider as angles from a
% horizontal linesegment from \texttt{center} traveling right. That
% means you should specify the angles in at counter--clockwise way,
% and between -360 and 360. \texttt{ang\_b} \emph{must} be bigger then
% \texttt{ang\_a}, otherwise the output is totally unpredictiable.
%
% The second argument is the \emph{thickness} of the pen drawing the
% segment, Again the last argument \texttt{m} is to insure the
% uniqueness of the vectors. The comments above on the argument also
% applies here. 
%    \begin{macrocode}
def uniarc(expr rad, thick, center, ang_a, ang_b, m)=
  pickup pensquare scaled thick ;
  path arc.l, arc.r, arc.e ; n:=m ; ang_c := abs(ang_b-ang_a) ;
%    \end{macrocode}
% First we check to see, if the user somehow requested an arc of more
% then $360^\circ$. If so, we just call \texttt{unicir}, since this is
% properly intended. If not, we go on to define relevant vectors.
%    \begin{macrocode}
  if ang_c >= 360 :
    unicir(rad,center,n) ;
  else:
%    \end{macrocode}
% We acctualy define the vectors as if we started in the arc on the
% positiv $x$--axis, considering \texttt{center} as origo, an then
% latter on turn the arc the appropiate angle. Notice the heavy use of
% \texttt{penpos} and \texttt{[ ]} to evaluate variable \texttt{m}.
%    \begin{macrocode}
    top z[n] = (0,rad) + center ; penpos[n](thick,90) ;
    arc.r := z[n]r{left} ;
    arc.l := z[n]l{left} ;
%    \end{macrocode}
% The next \texttt{if...fi} loop ensures we don't define a
% whole lot of useless vectors. The \MF{} primitiv path macro
% \texttt{...} does a very good job at approching a segment of a
% circle even if only two points are defined in an interval of
% $90^\circ$, if we at the same time utilizes the direction mechanisme
% of \MF{}.
%    \begin{macrocode}
    if ang_c > 90 :
      n := n+1 ; lft z[n] = (-rad,0) + center ; penpos[n](thick,180) ;
      arc.r := arc.r&z[n-1]r..z[n]r{down} ; 
      arc.l := arc.l&z[n-1]l..z[n]l{down} ;
      if ang_c > 180 : 
	n := n+1 ; bot z[n] = (0,-rad) + center ; penpos[n](thick,270) ;
	arc.r := arc.r&z[n-1]r..z[n]r{right} ;
	arc.l := arc.l&z[n-1]l..z[n]l{right} ;
	if ang_c > 270 :
	  n := n+1 ; rt  z[n] = (rad,0) + center ; penpos[n](thick,0) ;
	  arc.r := arc.r&z[n-1]r..z[n]r{up} ;
	  arc.l := arc.l&z[n-1]l..z[n]l{up} ;
	fi ;
      fi ;
    fi ;
%    \end{macrocode}
% After the \texttt{if} loop, we define the final point, make the
% complete path, and finishes off by drawing the arc, turned the
% appropiate angle.
%    \begin{macrocode}
    n:=n+1 ; z[n] = z[m] rotatedabout(center,ang_c) ;
    penpos[n](thick,90+ang_c) ;
    arc.r := arc.r&z[n-1]r..z[n]r{dir(180+ang_c)} ; 
    arc.l := arc.l&z[n-1]l..z[n]l{dir(180+ang_c)} ;
    arc.e := arc.l--reverse arc.r--cycle; 
    fill (arc.e rotatedabout(center,-90+ang_a));
  fi;
  penlabels(range m thru n);
enddef;

%    \end{macrocode}
% Notice the use of two paths, and reversal of one. This is 
% essentially what the \texttt{plain.mf} macro \texttt{penstroke}
% does. However, that macro couldn't be used here, since we are 
% building a path on the fly, so every step is needed to be fully
% known, and \texttt{penstroke} makes new variables to do the job.
%
% Also, we use the integer \texttt{n} for surfixes, since this
% limits the creation of vectors, and eases the path building.
% \end{fontmacro}
%
% \begin{fontmacro}{uniend}
% This macro is somewhat similar to \texttt{uniarc} above, but has a
% different use. Where \texttt{uniarc} is intended for arcs with a
% radius bigger then the pen thickness, this macro is intended for
% arcs with a radius of exactly same size as the pen thickness, hence 
% this macro produces a \emph{filled} segment of a circle with a
% radius of the current pen thickness.
%
% This macro, like \texttt{uniarc}, takes 5 arguments: the radius of
% the arc; the center of the arc, which should be of type
% \texttt{pair}; the starting and ending angle; plus the first number
% of the vectors needed to draw this figure. The considerations above
% in \texttt{uniarc} conserning the angles also apply here.
%
% Notice once again the use of \texttt{if..fi} loops to define the
% relevant vectors and paths.
%    \begin{macrocode}
def uniend(expr rad, center, ang_a, ang_b, m)=
  path arc ; n:=m ; ang_c := abs(ang_b-ang_a) ;
  if ang_c >= 360 :
    Rad := 2*rad ;
    pickup pencircle scaled Rad ; z[n]=center ; drawdot z[n] ;
  else:
    z[n] = (0,rad) + center ; arc := center{up}--z[n]{left} ;
    if ang_c > 90 :
      n := n+1 ; z[n] = (-rad,0) + center ;
      arc := arc&z[n-1]..z[n]{down} ;
      if ang_c > 180 :
	n := n+1 ; z[n] = (0,-rad) + center ;
	arc := arc&z[n-1]..z[n]{right} ;
	if ang_c > 270 :
	  n := n+1 ; z[n] = (rad,0) + center ;
	  arc := arc&z[n-1]..z[n]{up} ;
	fi ;
      fi ;
    fi ;
    n := n+1 ; z[n] = z[m] rotatedabout(center,ang_c) ;
    arc := arc&z[n-1]..z[n]{dir(180+ang_c)}--cycle ;
    fill (arc rotatedabout(center,-90+ang_a));
  fi;
  penlabels(range m thru n);
enddef;

%    \end{macrocode}
% Notice, once more we are building a path on the fly, so some caution
% was used here. Again the \texttt{plain.mf} macro \texttt{penstroke}
% doesn't do the job here. This is because only a part of a stroke is
% actually wanted. You might think then, that the  \texttt{plain.mf}
% macro \texttt{cutoff} then would do the job, but in my experience
% that macro has some serious flaws\footnote{A quick use of the Unix
%   command \texttt{grep} on most of the Computer Modern Fonts reveals
%   that \texttt{cutoff} is \emph{never} used, which I take to
%   indicate its weakness.}. 
% \end{fontmacro}
%
% \begin{fontmacro}{unilne}
% This macro is intended for drawing non--vertical or horizontal
% lines, since this is easily done with \texttt{draw}. It takes
% six arguments, the thickness of the pen drawing the line, the
% starting point of the line (\texttt{start}),  the ending point of
% line (\texttt{stop}), which should be higher and more to the right
% then the starting point, and  the cutoff--style
% (\texttt{endcutstart, endcutstop}).

% If \texttt{endcut}$x$ is positiv, then, the line is cut off
% horizontally at the relevant point $x$.
%
% If \texttt{endcut}$x$  is negativ, then, the line is cut off
% vertically at $x$.
%
% If it is zero,  then the  line is cut off perpendicular to the slant
% of the line at $x$.
%
% Also, if \texttt{endcut}$x$ is zero, the starting point is the
% point corrosponding to the lowest height and leftmost width, and the
% ending point corrosponds to the heighest height and rightmost width
% of the line. Again \texttt{m} insures unique vectors. 
%    \begin{macrocode}
def unilne(expr thick, start, stop, endcutstart, endcutstop, m)=
  pickup pensquare scaled thick;
  if endcutstart = endcutstop :
    if endcutstart = 0 :
      lft bot z[m] = start ; rt top z[m+1] = stop ;
      ang_c := angle(z[m+1]-z[m]) ;
      penpos[m](thick,-90+ang_c)  ;
      penpos[m+1](thick,-90+ang_c) ;
    elseif endcutstart > 0 :
      lft     z[m] = start ; rt     z[m+1] = stop ;
      ang_c := angle(z[m+1]-z[m]) ;
      penpos[m](thick/sind(ang_c),0) ;
      penpos[m+1](thick/sind(ang_c),0)  ;
    elseif endcutstart < 0:
      bot     z[m] = start ; top    z[m+1] = stop ;
      ang_c := angle(z[m+1]-z[m]) ;
      penpos[m](thick/cosd(ang_c),90) ;
      penpos[m+1](thick/cosd(ang_c),90) ;
    fi;
    penstroke z[m]e--z[m+1]e ;
  else :
    message "Different endcuts on unilne not implemented yet.";
  fi;
  n := m + 1 ;
  penlabels(range m thru n);
enddef;

%    \end{macrocode}
% \end{fontmacro}
%
%\iffalse
%</unibase>
%\fi
%
%\iffalse
%<*low>
%\fi
% \subsection{The Minuscles (lowercase letters) --- \texttt{unilow.mf}}
% \file{unilow.mf}
%
% \Newestchanges{v2.0}{98/08/01}{All of \texttt{unilow.mf} is defined
% within a conditional, to ease the generation of the small caps
% shaped fonts.}
% This whole file is loaded only conditionally to make the generation
% of small caps font easier. 
%    \begin{macrocode}
if not caps :

%    \end{macrocode}  
% \begin{fontcode}{a}
% The letter \textunibf{a} is interresting in the sense, that the bottom
% part of the curve, is \emph{not} a segement of an arc. The exact
% curvature of this part, is controversial; some font designers have
% chosen to make it a segement of an arc, making all of the curve, a
% circle; while others have chosen to make it a straight line. I
% decided to take the middleroad, since it appeals more to me
% aestheticly, even though it deviates from the principle of building
% all characters from the two simple forms: the cirle and the line.
%
% The \textuni{a} is also saved in the picture variable
% \texttt{a\_pic}, for use in \texttt{unilig.mf}.
%    \begin{macrocode}
  beginchar("a",x_w#,x_h#,0); "The letter a";
    uniarc(w/2,p_t,(w/2,h/2),0,290,10);
    pickup unipensqu ;
    z1 = ((cosd(290)*(w-p_t)+w)/2,(sind(290)*(w-p_t)+w)/2); 
    z2 = (w-p_t/2,2h/5) ; penpos1(p_t,-70); penpos2(p_t,-45);
    fill z1l{dir(20)}..z2l{dir(45)}--
      z2r{dir(225)}..z1r{dir(200)}--cycle;
    top rt z3 = (w,.5h) ; bot rt z4 = (w,0) ; draw z3{down}--z4 ;
    penlabels(1,2,3,4);
    a_pic := currentpicture ;
  endchar;

%    \end{macrocode}
% \end{fontcode}
% \begin{fontcode}{b}
% There is not much to say about this letter, only that it is a
% \textunibf{d} reflected through the vertical center axis.
%    \begin{macrocode}
  beginchar("b",x_w#,l_h#,0); "The letter b";
    unicir(w/2,p_t,(w/2,w/2),10); 
    pickup unipensqu ;
    lft bot z1 = (0,w/2) ; lft top z2 = (0,h) ; draw z1{up}--z2 ;
    penlabels(1,2);
  endchar;

%    \end{macrocode}
% \end{fontcode}
% \begin{fontcode}{c}
% This is a rather short program, but is interresting, since some care
% has to be taken, when assigning the width. Since a \textunibf{c} is not
% a full cirle, but only a segment opening towards the right, it would
% look wrong, if the letter was as wide, as it is tall.
%    \begin{macrocode}
  beginchar("c",x_w#*(1+cosd(30))/2,x_h#,0); "The letter c";
    uniarc(h/2,p_t,(h/2,h/2),30,330,10);
  endchar;

%    \end{macrocode}
% \end{fontcode}
% \begin{fontcode}{d}
% A flipped \textunibf{b} --- that's it!
%    \begin{macrocode}
  beginchar("d",x_w#,l_h#,0); "The letter d";
    unicir(w/2,p_t,(w/2,w/2),10); 
    pickup unipensqu ;
    rt bot z1 = (w,w/2) ; rt top z2 = (w,h) ; draw z1{up}--z2 ;
    penlabels(1,2);
  endchar;

%    \end{macrocode}
% \end{fontcode}
% \begin{fontcode}{e}
% Notice the middle bar. The arc can not go all the way down to the
% bar, because then the \textunibf{e} would end in a arc, on the right
% side. We want a flat end, so an extra dot has to be made.
%
% The \textuni{e} is also saved in the picture variable
% \texttt{e\_pic}, for use in \texttt{unilig.mf}.
%    \begin{macrocode}
  beginchar("e",x_w#,x_h#,0); "The letter e";
    uniarc(w/2,p_t,(w/2,h/2),0,330,10);
    temp := p_t/2 ;
    pickup pensquare xscaled p_t yscaled temp slanted slantratio ;
    top rt z1 = (w,h/2) ; drawdot z1 ;
    pickup unipensqu ;
    z2 = (p_t,h/2) ; z3 = (w-p_t,h/2) ; draw z2--z3 ;
    penlabels(1,2,3);
    e_pic := currentpicture ;
  endchar;

%    \end{macrocode}
% \end{fontcode}
% \begin{fontcode}{f}
% The horizontal placement of the bar is somewhat controversial. I
% think it looks best if it is placed, so that the top of the bar, is
% at the same height, as the top of an \textunibf{x}, that is $1ex$.
%    \begin{macrocode}
  beginchar("f",4p_t#,l_h#,0); "The letter f";
    uniarc(3/4w,p_t,(3/4w,h-3/4w),90,180,10);
    pickup unipensqu ;
    top rt z1 = (w,h) ; drawdot z1 ;
    lft top z2 = (0,h-3/4w) ; bot lft z3 = (0,0)   ; draw z2--z3 ;
    top lft z4 = (0,x_h)    ; top rt  z5 = (w,x_h) ; draw z4--z5 ;
    penlabels(1,2,3,4,5);
  endchar;

%    \end{macrocode}
% \end{fontcode}
% \begin{fontcode}{g}
% The \textunibf{g} is a very good measure of how low ascenders should
% go. Some might want to add a square on top of the ascender, so that
% the letter ended in flat to the right, but I found it displeacing,
% and therefore left it out.
%    \begin{macrocode}
  beginchar("g",x_w#,x_h#,p_d#); "The letter g" ;
    uniarc(w/2,p_t,(w/2,h/2),30,360,10) ;
    pickup unipensqu ;
    top rt z1 = (w,h/2) ; bot rt z2 = (w,-d) ; draw z1--z2;
    penlabels(1,2);
  endchar;

%    \end{macrocode}
% \end{fontcode}
% \begin{fontcode}{h}
% It can be argued, that this letter is too wide. However, I decieded
% to weight the concept of homongeious circles higher in this case.
%    \begin{macrocode}
  beginchar("h",x_w#,l_h#,0); "The letter h" ;
    uniarc(w/2,p_t,(w/2,w/2),0,180,10) ;
    pickup unipensqu ;
    top lft z1 = (0,h)       ; bot lft z2 = (0,0) ; draw z1--z2 ;
    top rt  z3 = (w,x_h-w/2) ; bot rt  z4 = (w,0) ; draw z3--z4 ;
    penlabels(1,2,3,4) ;
  endchar;

%    \end{macrocode}
% \end{fontcode}
% \begin{fontcode}{i}
% Quite a simple letter, though it can be argued wether the dot should
% be square, or as here circular.
%    \begin{macrocode}
  beginchar("i",p_t#,l_h#,0) ; "The letter i" ;
    pickup unipensqu ;
    top lft z1 = (0,x_h) ; bot lft z2 = (0,0) ; draw z1--z2 ;
    pickup unipencir ;
    top lft z3 = (0,h) ; drawdot z3 ;
    penlabels(1,2,3) ;
  endchar;

%    \end{macrocode}
% \end{fontcode}
% \begin{fontcode}{j}
% No left stem is added at the bottom, since it isn't needed!
%    \begin{macrocode}
  beginchar("j",p_t#,l_h#,p_d#); "The letter j" ;
    pickup unipensqu ;
    top lft z1 = (0,x_h) ; bot lft z2 = (0,-d) ; draw z1--z2 ;
    pickup unipencir ;
    top lft z3 = (0,h) ; drawdot z3 ;
    penlabels(1,2,3) ;
  endchar;

%    \end{macrocode}
% \end{fontcode}
% \begin{fontcode}{k}
% Again, this letter is narrower then most of the letters. This is
% because, the to arcs isn't full halfarcs, but rather quarterarcs.
%    \begin{macrocode}
  beginchar("k",(x_h#+3p_t#)/2,x_h#,0) ; "The letter k" ;
    uniarc((h+p_t)/2,p_t,(p_t,h),270,360,10) ;
    uniarc((h+p_t)/2,p_t,(p_t,0),0,90,20) ;
    pickup unipensqu ;
    top lft z1 = (0,h) ; bot lft z2 = (0,0) ; draw z1--z2 ;
    penlabels(1,2);
  endchar;

%    \end{macrocode}
% \end{fontcode}
% \begin{fontcode}{l}
% What is a line, but a line! Well right now it is an `l'. You may
% wonder why no stems are added, to destingish an `l' from a vertical
% bar, as in math mode. Well, how often will you put a math vertical
% bar next to an text `l'.
%    \begin{macrocode}
  beginchar("l",p_t#,l_h#,0) ; "The letter l" ;
    pickup unipensqu ;
    top lft z1 = (0,h) ; bot lft z2 = (0,0) ; draw z1--z2;
    penlabels(1,2);
  endchar;

%    \end{macrocode}
% \end{fontcode}
% \begin{fontcode}{m}
% This proved more tricky then I thought. Originally, I wanted the arc
% of the \textunibf{n} to be as high as those of the \textunibf{m}. This
% meant, that either the \textunibf{n} should be very narrow, or the
% \textunibf{m} very wide; either way it wouldn't look good. So after a
% few experiments, I decided for the current form.
%    \begin{macrocode}
  beginchar("m",m_w#,x_h#,0) ; "The letter m" ;
    temp := .25*(w+p_t);
    uniarc(temp,p_t,(temp,h-temp),0,180,10) ;
    uniarc(temp,p_t,(w-temp,h-temp),0,180,20) ;
    pickup unipensqu ;
    top lft z1 = (0,h-temp)   ; bot lft z2 = (0,0)   ; draw z1--z2 ;
    top     z3 = (w/2,h-temp) ; bot     z4 = (w/2,0) ; draw z3--z4 ;
    top rt z5 = (w,h-temp)    ; bot rt  z6 = (w,0)   ; draw z5--z6 ;
    penlabels(1,2,3,4,5,6);
  endchar;

%    \end{macrocode}
% \end{fontcode}
% \begin{fontcode}{n}
% Tricky because of the \textunibf{m} (see above).
%    \begin{macrocode}
  beginchar("n",x_w#,x_h#,0); "The letter n" ;
    uniarc(w/2,p_t,(w/2,h-w/2),0,180,10) ;
    pickup unipensqu ;
    top lft z1 = (0,h-w/2) ; bot lft z2 = (0,0) ; draw z1--z2 ;
    top rt  z3 = (w,h-w/2) ; bot rt  z4 = (w,0) ; draw z3--z4 ;
    penlabels(1,2,3,4) ;
  endchar;

%    \end{macrocode}
% \end{fontcode}
% \begin{fontcode}{o}
% Well, this is just a circle, nothing fancy. Why not make it oval,
% you say. I say, listen --- Herbert Bayer just turned in his grave!
%    \begin{macrocode}
  beginchar("o",x_w#,x_h#,0) ; "The letter o";
    unicir(w/2,p_t,(w/2,h/2),10);
  endchar;

%    \end{macrocode}
% \end{fontcode}
% \begin{fontcode}{p}
% Try to flip the \textunibf{b} horizontally, and tell me what you get?
%    \begin{macrocode}
  beginchar("p",x_w#,x_h#,p_d#) ; "The letter p" ;
    unicir(w/2,p_t,(w/2,w/2),10); 
    pickup unipensqu ;
    lft top z1 = (0,h/2) ; lft bot z2 = (0,-d) ; draw z1--z2 ;
    penlabels(1,2);
  endchar;

%    \end{macrocode}
% \end{fontcode}
% \begin{fontcode}{q}
% Why not try to destingish the \textunibf{q} more from the \textunibf{g}?
% Well if you look at the two letters, I think, you will get the
% answer. Also, my intuition of a \textunibf{q} is that of a reflected
% \textunibf{p}, but that is just \emph{my} intuition!
%    \begin{macrocode}
  beginchar("q",x_w#,x_h#,p_d#) ; "The letter q" ;
    unicir(w/2,p_t,(w/2,w/2),10); 
    pickup unipensqu ;
    rt top z1 = (w,h/2) ; rt bot z2 = (w,-d) ; draw z1--z2 ;
    penlabels(1,2);
  endchar;

%    \end{macrocode}
% \end{fontcode}
% \begin{fontcode}{r}
% Well that is really simplle, but illustrates a fine point --- why
% use more strokes, when fewer is needed?
%    \begin{macrocode}
  beginchar("r",3p_t#,x_h#,0) ; "The letter r" ;
    uniarc(w,p_t,(w,h-w),90,180,10) ;
    pickup unipensqu ;
    top lft z1 = (0,h-w) ; bot lft z2 = (0,0) ; draw z1--z2;
    penlabels(1,2);
  endchar;

%    \end{macrocode}
% \end{fontcode}
% \begin{fontcode}{s}
% \Newestchanges{v2.0}{98/08/01}{Considerable simplifications.}
% This is a `slow' letter, i.e.\ it takes \MF{} quite some time to
% compute. The reason is simple --- a \emph{lot} of curves is drawn.
%    \begin{macrocode}
  beginchar("s",x_w#,x_h#,0) ; "The letter s" ;
    temp := (h+p_t)/4 ;
    uniarc(temp,p_t,(temp,temp),180,270,10) ;
    uniarc(temp,p_t,(w-temp,temp),270,450,20) ;
    uniarc(temp,p_t,(temp,h-temp),90,270,30) ;
    uniarc(temp,p_t,(w-temp,h-temp),0,90,40) ;
    pickup unipensqu ;
    bot lft z1 = (temp,0)   ; bot rt z2 = (w-temp,0)   ; draw z1--z2 ;
    lft     z3 = (temp,h/2) ; rt     z4 = (w-temp,h/2) ; draw z3--z4 ;
    top lft z5 = (temp,h)   ; top rt z6 = (w-temp,h)   ; draw z5--z6 ; 
    penlabels(1,2,3,4,5,6) ;
  endchar;

%    \end{macrocode}
% \end{fontcode}
% \begin{fontcode}{t}
% As I argued before, the placement of the bar in the \textunibf{f} and
% \textunibf{t} is controversial.
%    \begin{macrocode}
  beginchar("t",p_t#+2c_d#,l_h#,0); "The letter t" ;
    pickup unipensqu ;
    top     z1 =  (w/2,h) ; bot    z2 = (w/2,0) ; draw z1--z2 ;
    top lft z3 = (0,x_h)  ; top rt z4 = (w,x_h) ; draw z3--z4 ;
    penlabels(1,2,3,4);
  endchar;

%    \end{macrocode}
% \end{fontcode}
% \begin{fontcode}{u}
% Flip a letter here, and flip a letter there --- all in a days work
% of a font designer!
%    \begin{macrocode}
  beginchar("u",x_w#,x_h#,0); "The letter u" ;
    uniarc(w/2,p_t,(w/2,w/2),180,360,10) ;
    pickup unipensqu ;
    top lft z1 = (0,h) ; bot lft z2 = (0,w/2) ; draw z1--z2 ;
    top rt  z3 = (w,h) ; bot rt  z4 = (w,w/2) ; draw z3--z4 ;
    penlabels(1,2,3,4) ;
  endchar;

%    \end{macrocode}
% \end{fontcode}
% \begin{fontcode}{v}
% The lines and the arc doesn't intersect in a flowing way, but the
% error is so small it will not be seen in normal use. However, if
% the font is maginified to, say $70pt$, it might be a problem. I
% hope to get into this, some time in the future. For now, make  do.
%    \begin{macrocode}
  beginchar("v",x_w#,x_h#,0); "The letter v" ;
    unilne(p_t,(0,h),(w/2,p_t),1,1,10);
    unilne(p_t,(w/2,p_t),(w,h),1,1,20);
    uniarc(p_t,p_t,(w/2,p_t),180,360,30);
  endchar;

%    \end{macrocode}
% \end{fontcode}
% \begin{fontcode}{w}
% Flippedy--flop.
%    \begin{macrocode}
  beginchar("w",m_w#,x_h#,0) ; "The letter w" ;
    temp := .25*(w+p_t);
    uniarc(temp,p_t,(temp,temp),180,360,10) ;
    uniarc(temp,p_t,(w-temp,temp),180,360,20) ;
    pickup unipensqu ;
    top lft z1 = (0,h)   ; bot lft z2 = (0,temp)   ; draw z1--z2 ;
    top     z3 = (w/2,h) ; bot     z4 = (w/2,temp) ; draw z3--z4 ;
    top rt  z5 = (w,h)   ; bot rt  z6 = (w,temp)   ; draw z5--z6 ;
    penlabels(1,2,3,4,5,6);
  endchar;

%    \end{macrocode}
% \end{fontcode}
% \begin{fontcode}{x}
% This is a bit tricky --- the two arces are each half the width wide,
% but since they share middle part, they leave the width of the
% strokes uncoverd. To remedy this problem, four dots are drawn. It
% would be silly, if the \textunibf{x} wasn't as wide as it is tall,
% namely \texttt{x\_w}.
%    \begin{macrocode}
  beginchar("x",x_w#,x_h#,0) ; "The letter x" ;
    uniarc(h/2,p_t,(p_t/2,h/2),270,90,10);
    uniarc(h/2,p_t,(w-p_t/2,h/2),90,270,20);
    temp := (w-h+p_t)/2 ;
    pickup pensquare xscaled temp yscaled p_t slanted slantratio ;
    lft top z1 = (0,h) ; drawdot z1 ;
    lft bot z2 = (0,0) ; drawdot z2 ;
    rt  top z3 = (w,h) ; drawdot z3 ;
    rt  bot z4 = (w,0) ; drawdot z4 ;
    penlabels(1,2,3,4);
  endchar;

%    \end{macrocode}
% \end{fontcode}
% \begin{fontcode}{y}
% Flip an reflect, or just turn, it's all the same, it will still be a
% transformation of an \textunibf{h}
%    \begin{macrocode}
  beginchar("y",x_w#,x_h#,p_d#); "The letter y" ;
    uniarc(w/2,p_t,(w/2,w/2),180,360,10) ;
    pickup unipensqu ;
    top lft z1 = (0,h) ; bot lft z2 = (0,w/2); draw z1--z2 ;
    top  rt z3 = (w,h) ; bot rt  z4 = (w,-d) ; draw z3--z4 ;
    penlabels(1,2,3,4) ;
  endchar;

%    \end{macrocode}
% \end{fontcode}
% \begin{fontcode}{z}
% This is a bit tricky letter, since what I wanted was for middle line
% to have an inclination such that its edges would be tangents to the
% circle segments at the endpoints of the horizontal lines. I tried to
% solve this problem analytically, but gave up. I also tried to use
% some of \texttt{plain.mf}'s macros, but none of them gave me the
% resulat I wanted. So I finally made the approximation seen below. 
% If you can come up with a good solution to this problem, please let
% me know. 
%    \begin{macrocode}
  beginchar("z",x_w#,x_h#,0) ; "The letter z" ;
    pickup unipensqu ;
    top lft z1 = (0,h)   ; top rt z2 = (w-p_t,h) ; draw z1--z2 ;
    bot lft z3 = (p_t,0) ; bot rt z4 = (w,0)     ; draw z3--z4 ;
    phi := angle((w,h-p_t)-(0,p_t)) ; % Uuuuupps !?!!!!!!
    z5 = (p_t,p_t)     ; z6 = z5 + p_t*(-sind(phi),cosd(phi)) ;
    z7 = (w-p_t,h-p_t) ; z8 = z7 + p_t*(sind(phi),-cosd(phi)) ;
    uniend(p_t,z5,90+phi,270,10);
    uniend(p_t,z7,-90+phi,90,20);
    fill z5--z6--z7--z8--cycle ;
    penlabels(range 1 thru 8);
  endchar;

%    \end{macrocode}
% \end{fontcode}
% As explain in the begining of the section, this file is one big
% \texttt{if...else...fi} loop to mak the generation of the small caps
% font easier.
%
% The idea is, that if \texttt{caps} is
% \texttt{true}, then the main part of this file shouldn't be used,
% but rather \texttt{uniupp.mf} should be loaded again, but with
% different diffintions of dimensions for uppercase letters, so that
% they come out as small as lowercase letters, hence --- small
% caps.
% 
% This is done by the macro \texttt{do\_caps}, which we utilies
% inside a group, so that the changes made by \texttt{do\_caps} will be
% undone after the group, and hence not affect the rest of the font.
% 
%    \begin{macrocode}
else :
  do_caps(ASCII"a" - ASCII"A") ;
  input uniupp ;
  end_do_caps ;
fi ;

%    \end{macrocode}
%\iffalse
%</low>
%\fi
%\iffalse
%<*upp>
%\fi
% \subsection{The Majuscles (uppercase letters) --- \texttt{uniupp.mf}}
% \file{uniupp.mf}
%
% As noted earlier, Herbert Bayer never did design any majuscles,
% since he considered them useless. However, majuscles are avaliable
% in the current implentation and are to be used at your lesuire. Of
% course, if you agree with the Bauhaus school, and think uppercase
% letters are useless, you shouldn't use them. Then, perhaps, you
% should also refrain from using non--standard letters shuch as German
% double s, Scandinavian ligatures, Spanish schriek, and perhaps even
% accents of any kind. This may seem a little drastic, but the
% train--of--tought should be clear: Why use letters and symbols that
% are in the best case obsolete, and in the worst useless or without
% significans?  
%
% \Newestchanges{v2.0}{98/08/01}{All of \texttt{unilow.mf} is defined
% within a conditional, to ease the generation of the strict shaped
% fonts.}
%
% To facilitate a use of the \universal{} font conforming to Bayers'
% original idea, that is without majusceles this file is loaded only
% under the condition that \texttt{strict} is \emph{false}.
%    \begin{macrocode}
if not strict :

%    \end{macrocode}  
% \begin{fontcode}{A}
% It can be argued where the bar should be placed. I choose place it
% the middle, since most of the majuscles tend to have a symmetry axis
% long this line, so I thought it apropiate to follow this line of
% thought. Ofcourse, I'm the only one to blane for this, since Herbert
% Bayer \emph{never} designed any majuscles! (So flame me for
% guessing).
%    \begin{macrocode}
  beginchar("A",A_w#,l_h#,0); "The letter A";
    uniarc(w/2,P_t,(w/2,h-w/2),0,180,10);
    pickup Unipensqu ;
    top lft z1 = (0,h-w/2) ; bot lft z2 = (0,0)   ; draw z1--z2 ;
    top rt  z3 = (w,h-w/2) ; bot rt  z4 = (w,0)   ; draw z3--z4 ;
    lft z5     = (0,h/2)   ; rt      z6 = (w,h/2) ; draw z5--z6 ;
    penlabels(1,2,3,4,5,6);
  endchar;

%    \end{macrocode}
% \end{fontcode}
% \begin{fontcode}{B}
% This letter is somewhat tricky, since it is not clear wether the
% arces should be placed directly on the left down stoke, or there
% should be some distance filled with horizontal bars. I chose the
% second solution, even though it isn't the most simple, and hence in
% better  agrement with the concept of this font design. However, the
% first solution does make the letter very narrow compared with some
% of the other letters.
%    \begin{macrocode}
  beginchar("B",A_w#,l_h#,0) ; "The letter B" ;
    rad := 1/4(h+P_t) ;
    uniarc(rad,P_t,(w-rad,h-rad),-90,90,10) ;
    uniarc(rad,P_t,(w-rad,rad),-90,90,20) ;
    uniend(P_t,(P_t,h-P_t),90,180,30) ;
    uniend(P_t,(P_t,P_t),180,270,40) ;
    pickup Unipensqu ;
    top lft z1 = (0,h-P_t) ; bot lft z2 = (0,P_t)      ; draw z1--z2 ;
    top lft z3 = (P_t,h)   ; top rt  z4 = (w-rad,h)    ; draw z3--z4 ;
    lft     z5 = (P_t,h/2) ; rt      z6 = (w-rad,1/2h) ; draw z5--z6 ;
    bot lft z7 = (P_t,0)   ; bot rt  z8 = (w-rad,0)    ; draw z7--z8 ;
    penlabels(range 1 thru 8);
  endchar;

%    \end{macrocode}
% \end{fontcode}
% \begin{fontcode}{C}
% This is really simple, since it is just an enlargement of the
% corresponding minuscule, so the is really nothing interresting
% here. 
%    \begin{macrocode}
  beginchar("C",l_h#*(1+cosd(30))/2,l_h#,0); "The letter C";
    uniarc(h/2,P_t,(h/2,h/2),30,330,10);
  endchar;

%    \end{macrocode}
% \end{fontcode}
% \begin{fontcode}{D}
% As with the B, there are two ways to do this letter: One way would
% be to make the arc a true half segment of a circle, the other would
% be to compose it of two quarter segments, joined by a vertical
% line. The second solution also entails, that two horizontal lines
% should connect the two quarter circles with the left vertical
% line. Again I chose the simple solution, which --- ofcourse ---
% amounts to the first mentioned above.
%    \begin{macrocode}
  beginchar("D",A_w#,l_h#,0); "The letter D";
    uniarc(1/2h,P_t,(w-1/2h,1/2h),-90,90,10);
    uniend(P_t,(P_t,h-P_t),90,180,20);
    uniend(P_t,(P_t,P_t),180,270,30);
    pickup Unipensqu ;
    top lft z1 = (0,h-P_t) ; bot lft z2 = (0,P_t)    ; draw z1--z2 ;
    top lft z3 = (P_t,h)   ; top rt  z4 = (w-1/2h,h) ; draw z3--z4 ;
    bot lft z5 = (P_t,0)   ; bot rt  z6 = (w-1/2h,0) ; draw z5--z6 ;
    penlabels(1,2) ;
  endchar;

%    \end{macrocode}
% \end{fontcode}
% \begin{fontcode}{E}
% It can be argued, that the middle bar should be shorter then the top
% and bottom bar, but since this only complicates things, I chose not
% to do so. However, I am not going to be stuborn on this, and it may
% well prove to be better aestethics, if the middle bar is shortend.
%    \begin{macrocode}
  beginchar("E",A_w#,l_h#,0); "The letter E" ;
    uniend(P_t,(P_t,h-P_t),90,180,10);
    uniend(P_t,(P_t,P_t),180,270,20);
    pickup Unipensqu ;
    lft top z1 = (P_t,h)   ; rt  top z2 = (w,h)   ; draw z1--z2 ;
    lft     z3 = (P_t,h/2) ; rt      z4 = (w,h/2) ; draw z3--z4 ;
    lft bot z5 = (P_t,0)   ; rt  bot z6 = (w,0)   ; draw z5--z6 ;
    lft top z7 = (0,h-P_t) ; lft bot z8 = (0,P_t) ; draw z7--z8 ;
    penlabels(range 1 thru 8) ;
  endchar;

%    \end{macrocode}
% \end{fontcode}
% \begin{fontcode}{F}
% Ofcourse, very similar to the \textunibf{E}. The consideration
% concerning the middle bar of the \textunibf{E} will ofcourse reflect
% on this letter. 
%    \begin{macrocode}
  beginchar("F",A_w#,l_h#,0); "The letter F" ;
    uniend(P_t,(P_t,h-P_t),90,180,10);
    pickup Unipensqu ;
    lft top z1 = (P_t,h)   ; rt  top z2 = (w,h)   ; draw z1--z2 ;
    lft     z3 = (P_t,h/2) ; rt      z4 = (w,h/2) ; draw z3--z4 ;
    lft top z5 = (0,h-P_t) ; lft bot z6 = (0,0)   ; draw z5--z6 ;
    penlabels(range 1 thru 8);
  endchar;

%    \end{macrocode}
% \end{fontcode}
% \begin{fontcode}{G}
% This is very similar to the minuscle \textunibf{g}, the only difference
% is the size, and that the down stroke doens't extend below the
% baseline.
%    \begin{macrocode}
  beginchar("G",l_h#,l_h#,0); "The letter G" ;
    uniarc(w/2,P_t,(w/2,h/2),30,360,10) ;
    pickup Unipensqu ;
    top rt z1 = (w,h/2) ; bot rt z2 = (w,0) ;
    draw z1--z2;
    penlabels(1,2);
  endchar;

%    \end{macrocode}
% \end{fontcode}
% \begin{fontcode}{H}
% An awfull simple letter. There can be no doubt on how this should
% look. 
%    \begin{macrocode}
  beginchar("H",A_w#,l_h#,0); "The letter H" ;
    pickup Unipensqu ;
    top lft z1 = (0,h) ; bot lft z2 = (0,0) ; draw z1--z2 ;
    top rt  z3 = (w,h) ; bot rt  z4 = (w,0) ; draw z3--z4 ;
    lft z5 = (0,h/2) ; rt z6 = (w,h/2) ; draw z5--z6 ;
    penlabels(1,2,3,4,5,6);
  endchar;

%    \end{macrocode}
% \end{fontcode}
% \begin{fontcode}{I}
% It doesn't get any simpler!
%    \begin{macrocode}
  beginchar("I",P_t#,l_h#,0); "The letter I" ;
    pickup Unipensqu ;
    top lft z1 = (0,h) ; bot lft z2 = (0,0) ; draw z1--z2 ;
    penlabels(1,2);
  endchar;

%    \end{macrocode}
% \end{fontcode}
% \begin{fontcode}{J}
%    \begin{macrocode}
  beginchar("J",P_t#+2C_d#,l_h#,0); "The letter J";
    uniend(P_t,(w-P_t,P_t),270,360,10);
    pickup Unipensqu ;
    lft bot z1 = (0,0)   ; rt bot z2 = (w-P_t,0) ; draw z1--z2 ;
    rt  bot z3 = (w,P_t) ; rt top z4 = (w,h)     ; draw z3--z4 ;
    penlabels(1,2,3,4);
  endchar;

%    \end{macrocode}
% \end{fontcode}
% \begin{fontcode}{K}
% Similar to \textunibf{k}.
%    \begin{macrocode}
  beginchar("K",(l_h#+3P_t#)/2,l_h#,0) ; "The letter K" ;
    uniarc((h+P_t)/2,P_t,(P_t,h),270,360,10) ;
    uniarc((h+P_t)/2,P_t,(P_t,0),0,90,20) ;
    pickup Unipensqu ;
    top lft z1 = (0,h) ; bot lft z2 = (0,0) ; draw z1--z2 ;
    penlabels(1,2);
  endchar;

%    \end{macrocode}
% \end{fontcode}
% \begin{fontcode}{L}
% This is just a reflected \textunibf{J}.
%    \begin{macrocode}
  beginchar("L",P_t#+2C_d#,l_h#,0) ; "The letter L" ;
    uniend(P_t,(P_t,P_t),180,270,10) ;
    pickup Unipensqu ;
    top lft z1 = (0,h)   ; bot lft z2 = (0,P_t) ; draw z1--z2 ;
    bot lft z3 = (P_t,0) ; bot rt  z4 = (w,0)   ; draw z3--z4 ;
    penlabels(1,2,3,4) ;
  endchar;

%    \end{macrocode}
% \end{fontcode}
% \begin{fontcode}{M}
% The same kind of considerations as in \textunibf{m} went into this
% letter.
%    \begin{macrocode}
  beginchar("M",M_w#,l_h#,0) ; "The letter M" ;
    temp := .25*(w+P_t);
    uniarc(temp,P_t,(temp,h-temp),0,180,10) ;
    uniarc(temp,P_t,(w-temp,h-temp),0,180,20) ;
    pickup Unipensqu ;
    top lft z1 = (0,h-temp) ; bot lft z2 = (0,0) ;  draw z1--z2 ;
    top z3 = (w/2,h-temp)   ; bot z4 = (w/2,0)   ;  draw z3--z4 ;
    top rt z5 = (w,h-temp)  ; bot rt z6 = (w,0)  ;  draw z5--z6 ;
    penlabels(1,2,3,4,5,6);
  endchar;

%    \end{macrocode}
% \end{fontcode}
% \begin{fontcode}{N}
% Tricky because of the \textunibf{M} (see above).
%    \begin{macrocode}
  beginchar("N",A_w#,l_h#,0); "The letter N" ;
    uniarc(w/2,P_t,(w/2,h-w/2),0,180,10) ;
    pickup Unipensqu ;
    top lft z1 = (0,h-w/2) ; bot lft z2 = (0,0);  draw z1--z2 ;
    top rt z3 = (w,h-w/2)  ; bot rt z4 = (w,0) ;  draw z3--z4 ;
    penlabels(1,2,3,4) ;
  endchar;

%    \end{macrocode}
% \end{fontcode}
% \begin{fontcode}{O}
% No, this is not going to be an oval, but a \emph{circle\/}!
%    \begin{macrocode}
  beginchar("O",l_h#,l_h#,0) ; "The letter O";
    unicir(w/2,P_t,(w/2,h/2),10);
  endchar;

%    \end{macrocode}
% \end{fontcode}
% \begin{fontcode}{P}
% No surprises.
%    \begin{macrocode}
  beginchar("P",A_w#,l_h#,0) ; "The letter P";
    unicir(w/2,P_t,(w/2,h-w/2),10)
    pickup Unipensqu ;
    lft top z1 = (0,h-w/2) ; lft bot z2 = (0,0) ; draw z1--z2 ;
    penlabels(1,2);
  endchar;

%    \end{macrocode}
% \end{fontcode}
% \begin{fontcode}{Q}
% There are to variants of this letter, one is an reflected
% \textunibf{P}, and the other is a vaiant of an \textunibf{O}. The
% default one, is the \textunibf{Q} variant. If you want to use the
% other variant, you can acceses it directly with \Lcs{varQ}, or you
% can pass the argument \texttt{varQ} to the \textsc{uni} package.
% (Option \texttt{varQ} not implemented yet!)
%    \begin{macrocode}
  beginchar("Q",l_h#,l_h#,p_d#) ; "The letter Q";
    unicir(w/2,P_t,(w/2,w/2),10);
    pickup Unipensqu ;
    top z1 = (w/2,3P_t) ; bot z2 = (w/2,-d) ; draw z1--z2 ;
    penlabels(1,2);
  endchar;

%    \end{macrocode}
% \end{fontcode}
% \begin{fontcode}{R}
% I'm not enterily happy with this letter, but quite frankly, I don't
% know how else to make it. Please give me your suggestion.
%    \begin{macrocode}
  beginchar("R",A_w#,l_h#,0) ; "The letter R";
    unicir(w/2,P_t,(w/2,h-w/2),10) ;
    rad := h-w+P_t ; 
    uniarc(rad,P_t,(w-rad,0),0,90,20) ;
    pickup Unipensqu ;
    lft top z1 = (0,h-w/2)  ; bot lft z2 = (0,0) ; draw z1--z2 ;
    temp := w/2-rad ;
    if temp>0 :
      pickup pensquare xscaled temp yscaled P_t ;
      lft top z3 = (1/2w,rad) ; drawdot z3 ;
    fi;
    penlabels(1,2,3) ;
  endchar;

%    \end{macrocode}
% \end{fontcode}
% \begin{fontcode}{S}
% Just like the minuscle \textunibf{s}, this is a `slow' letter, i.e.,
% it takes \MF{} quite some time to compute. 
%    \begin{macrocode}
  beginchar("S",A_w#,l_h#,0) ; "The letter S" ;
    temp := (h+P_t)/4 ;
    uniarc(temp,P_t,(temp,temp),180,270,10) ;
    uniarc(temp,P_t,(w-temp,temp),270,450,20) ;
    uniarc(temp,P_t,(temp,h-temp),90,270,30) ;
    uniarc(temp,P_t,(w-temp,h-temp),0,90,40) ;
    pickup Unipensqu ;
    bot lft z1 = (temp,0)   ; bot rt z2 = (w-temp,0)   ; draw z1--z2 ;
    lft     z3 = (temp,h/2) ; rt     z4 = (w-temp,h/2) ; draw z3--z4 ;
    top lft z5 = (temp,h)   ; top rt z6 = (w-temp,h)   ; draw z5--z6 ; 
    penlabels(1,2,3,4,5,6) ;
  endchar;

%    \end{macrocode}
% \end{fontcode}
% \begin{fontcode}{T}
% Again --- simple!
%    \begin{macrocode}
  beginchar("T",A_w#,l_h#,0); "The letter T" ;
    pickup Unipensqu ;
    top     z1 = (w/2,h) ; bot    z2 = (w/2,0) ; draw z1--z2 ;
    top lft z3 = (0,h)   ; top rt z4 = (w,h)   ; draw z3--z4 ;
    penlabels(1,2,3,4);
  endchar;

%    \end{macrocode}
% \end{fontcode}
% \begin{fontcode}{U}
% \emph{Font--jepody:} The character of the \universal{} font, that,
% when reflected gives \textunibf{U}.
%    \begin{macrocode}
  beginchar("U",A_w#,l_h#,0); "The letter U" ;
    uniarc(w/2,P_t,(w/2,w/2),180,360,10) ;
    pickup Unipensqu ;
    top lft z1 = (0,h) ; bot lft z2 = (0,w/2) ; draw z1--z2 ;
    top rt  z3 = (w,h) ; bot  rt z4 = (w,w/2) ; draw z3--z4 ;
    penlabels(1,2,3,4) ;
  endchar;

%    \end{macrocode}
% \end{fontcode}
% \begin{fontcode}{V}
% See also the minuscle \textunibf{v}.
%    \begin{macrocode}
  beginchar("V",A_w#,l_h#,0); "The letter V" ;
    unilne(P_t,(0,h),(w/2,P_t),1,1,10);
    unilne(P_t,(w/2,P_t),(w,h),1,1,20);
    uniarc(P_t,P_t,(w/2,P_t),180,360,30);
  endchar;

%    \end{macrocode}
% \end{fontcode}
% \begin{fontcode}{W}
% Flippedy--flop.
%    \begin{macrocode}
  beginchar("W",M_w#,l_h#,0) ; "The letter W" ;
    temp := .25*(w+P_t);
    uniarc(temp,P_t,(temp,temp),180,360,10) ;
    uniarc(temp,P_t,(w-temp,temp),180,360,20) ;
    pickup Unipensqu ;
    top lft z1 = (0,h)   ; bot lft z2 = (0,temp)   ; draw z1--z2 ;
    top     z3 = (w/2,h) ; bot     z4 = (w/2,temp) ; draw z3--z4 ;
    top rt  z5 = (w,h)   ; bot rt  z6 = (w,temp)   ; draw z5--z6 ;
    penlabels(1,2,3,4,5,6);
  endchar;

%    \end{macrocode}
% \end{fontcode}
% \begin{fontcode}{X}
% This is a bit tricky --- see the minuscle \textunibf{x}.
%    \begin{macrocode}
  beginchar("X",l_h#,l_h#,0) ; "The letter X" ;
    uniarc(h/2,P_t,(P_t/2,h/2),270,90,10);
    uniarc(h/2,P_t,(w-P_t/2,h/2),90,270,20);
    temp := (h-w+P_t)/2 ;
    pickup pensquare xscaled temp yscaled P_t slanted slantratio ;
    lft top z1 = (0,h) ; draw z1 ;
    lft bot z2 = (0,0) ; draw z2 ;
    rt  top z3 = (w,h) ; draw z3 ;
    rt  bot z4 = (w,0) ; draw z4 ;
    penlabels(1,2,3,4);
  endchar;

%    \end{macrocode}
% \end{fontcode}
% \begin{fontcode}{Y}
% \Newestchanges{v2.0}{98/08/01}{Character \textunibf{Y} changed.}
% This actually a bit different from \textunibf{y}, but it looks right. 
%    \begin{macrocode}
  beginchar("Y",A_w#,l_h#,0); "The letter Y" ;
    uniarc(w/2,P_t,(w/2,h-P_t),180,360,10) ;
    pickup Unipensqu ;
    top lft z1 = (0,h) ; drawdot z1 ;
    top rt  z2 = (w,h) ; drawdot z2 ;
    top     z3 = (w/2,h-w/2) ; bot z4 = (w/2,0) ; draw z3--z4 ;
    penlabels(1,2,3,4) ;
  endchar;

%    \end{macrocode}
% \end{fontcode}
% \begin{fontcode}{Z}
% Again a tricky letter. For more onm this please refer to the
% minuscle \textunibf{z}.
% 
% Notice that the angle \texttt{phi} in this majuscle is not the
% same as in the minuscles \textunibf{z}, since this letter doesn't fit
% in a square, but is retangular.
%    \begin{macrocode}
  beginchar("Z",A_w#,l_h#,0) ; "The letter Z" ;
    pickup Unipensqu ;
    top lft z1 = (0,h)   ; top rt z2 = (w-P_t,h) ; draw z1--z2 ;
    bot lft z3 = (P_t,0) ; bot rt z4 = (w,0)     ; draw z3--z4 ;
    phi := angle((w,h-P_t)-(0,P_t)) ;
    z5 = (P_t,P_t)     ; z6 = z5 + P_t*(-sind(phi),cosd(phi)) ;
    z7 = (w-P_t,h-P_t) ; z8 = z7 + P_t*(sind(phi),-cosd(phi)) ;
    uniend(P_t,z5,90+phi,270,10);
    uniend(P_t,z7,-90+phi,90,20);
    fill z5--z6--z7--z8--cycle ;
    penlabels(range 1 thru 8);
  endchar;

%    \end{macrocode}
% \end{fontcode}
% As explain in the begining of the section, this file is one big
% \texttt{if...else...fi} loop to mak the generation of the strict
% font easier.
%
% The idea is, that if \texttt{strict} is \texttt{true}, then the main
% part of this file shouldn't be used, but rather \texttt{unilow.mf}
% should be loaded again, but with this time the characters should be
% placed where the majuscules should be. 
% 
% This is done by defining \texttt{code\_offset} to be the (negative) 
% difference the ASCII code for \texttt{A} and \texttt{a}. After we
% have input \texttt{unilow.mf} once more, we reset
% \texttt{code\_offset}. 
%    \begin{macrocode}
else :
  code_offset := ASCII"A" - ASCII"a" ;
  input unilow ;
  code_offset := 0 ;
fi ;

%    \end{macrocode}
%\iffalse
%</upp>
%\fi
%\iffalse
%<*dig>
%\fi
% \subsection{The Numbers --- (\texttt{unidig.mf})}
% \file{unidig.mf}
%
% I couldn't find any design of numbers, I could directly ascribe to
% Herbert Bayer. I, however, found some other examples, and from
% these, and my general conception of the font, I designed the
% numerals, as they are seen below.
%
% \begin{fontcode}{0}
% Perhaps this should have been a circle, but to destingice the zero
% from the majuscle {\uni O}, I chose to strecth it.
%    \begin{macrocode}
beginchar("0",A_w#,l_h#,0) ; "The number 0" ;
  uniarc(w/2,p_t,(w/2,h-w/2),0,180,10) ;
  uniarc(w/2,p_t,(w/2,w/2),180,360,20) ;
  pickup unipensqu ;
  top lft z1 = (0,h-w/2) ; bot lft z2 = (0,w/2) ; draw z1--z2 ;
  top rt  z3 = (w,h-w/2) ; bot rt  z4 = (w,w/2) ; draw z3--z4 ;
  penlabels(1,2,3,4) ;
endchar;

%    \end{macrocode}
% \end{fontcode}
% \begin{fontcode}{1}
% Here we use the dimension \texttt{c\_d}, since the stem should be
% thee same lenght in the medium font as in the bold face one.
%    \begin{macrocode}
beginchar("1",2c_d#,l_h#,0) ; "The number 1" ;
  uniend(p_t,(w-p_t,h-p_t),0,90,10) ;
  pickup unipensqu ;
  lft top z1 = (0,h)     ; rt top z2 = (w-p_t,h) ; draw z1--z2 ;
  rt  top z3 = (w,h-p_t) ; rt bot z4 = (w,0)     ; draw z3--z4 ;
  penlabels(1,2,3,4) ;
endchar;

%    \end{macrocode}
% \end{fontcode}
% \begin{fontcode}{2}
% Again, this is a bit tricky, for the same reason as the minuscle
% {\uni z}.
%    \begin{macrocode}
beginchar("2",A_w#,l_h#,0) ; "The number 2" ;
  uniarc(w/2,p_t,(w/2,h-w/2),0,180,10) ;
  phi := angle((w,h-w/2)-(0,p_t)) ;
  z1 = (w-p_t,h-w/2) ; z2 = z1 + p_t*(sind(phi),-cosd(phi)) ;
  z3 = (p_t,p_t)     ; z4 = z3 + p_t*(-sind(phi),cosd(phi)) ;
  fill z1--z2--z3--z4--cycle ;
  uniend(p_t,z1,270+phi,360,20) ;
  uniend(p_t,z3,90+phi,270,30) ;
  pickup unipensqu ;
  bot lft z5 = (p_t,0) ; bot rt z6 = (w,0) ; draw z5--z6 ; 
  penlabels(range 1 thru 6) ;
endchar;

%    \end{macrocode}
% \end{fontcode}
% \begin{fontcode}{3}
% By first defining to paths similar to the two circle segments, it is
% possible to calculate the intersectionpoint, and thereby the angle
% \texttt{phi}, where the to segments meet, relative to one of the
% centers. This angle is then used to define the \emph{real} path, and
% the rightmost point of the middle bar.
%    \begin{macrocode}
beginchar("3",A_w#,l_h#,0) ; "The number 3" ;
  path arc_a, arc_b ;
  arc_a = (w,h-w/2)..(w/2,h-w) ; arc_b = (w,w/2)..(w/2,w) ;
  z3 = arc_a intersectionpoint arc_b ; phi := angle(z3-(w/2,w/2)) ;
  uniarc(w/2,p_t,(w/2,h-w/2),-phi,180,10) ;
  uniarc(w/2,p_t,(w/2,w/2),-180,phi,20) ;
  pickup unipensqu ;
  rt z1 = (w/2*(1+cosd(phi)),h/2) ; lft z2 = (w/2,h/2) ; draw z1--z2 ;
  penlabels(1,2) ;
endchar;

%    \end{macrocode}
% \end{fontcode}
% \begin{fontcode}{4}
% One could argue, that the top left stroke should be vertical, but I
% chose to go for a $45^\circ$ slanted line, for aestethic reasons.
%    \begin{macrocode}
beginchar("4",A_w#,l_h#,0) ; "The number 4" ;
  z1 = (w-p_t,h-p_t) ; z2 = z1 + p_t*(-1/sqrt(2),1/sqrt(2)) ;
  z3 = (p_t,h-w+p_t) ; z4 = z3 + p_t*(-1/sqrt(2),1/sqrt(2)) ;
  fill z1--z2--z4--z3--cycle ;
  uniend(p_t,z1,0,135,10) ;
  uniend(p_t,z3,135,270,20) ;
  pickup unipensqu ;
  top rt  z5 = (w,h-p_t) ; bot rt z6 = (w,0)   ; draw z5--z6 ;
  bot lft z7 = (p_t,h-w) ; bot rt z8 = (w,h-w) ; draw z7--z8 ;
  penlabels(range 1 thru 8) ;
endchar;

%    \end{macrocode}
% \end{fontcode}
% \begin{fontcode}{5}
% This gave me some trouble. I originally wanted the arc to have a
% diameter the width of the character, but that meant, that the to
% horizontal lines of the font, came so close to each other, that it
% didn't look good. So I played a little with \texttt{rad}, and
% decided that the current value gave the nicest resault.
%    \begin{macrocode}
beginchar("5",A_w#,l_h#,0) ; "The number 5" ;
  rad := 9w/20 ; 
  uniarc(rad,p_t,(w-rad,rad),-150,90,10) ;
  uniend(p_t,(p_t,h-p_t),90,180,20) ;
  uniend(p_t,(p_t,2rad),180,270,30) ;
  pickup unipensqu ;
  top lft z1 = (p_t,2rad) ; top rt  z2 = (w-rad,2rad) ; draw z1--z2 ;
  bot lft z3 = (0,2rad)   ; top lft z4 = (0,h-p_t)    ; draw z3--z4 ;
  top lft z5 = (p_t,h)    ; top rt  z6 = (w,h)        ; draw z5--z6 ;
  penlabels(range 1 thru 6) ;
endchar;

%    \end{macrocode}
% \end{fontcode}
% \begin{fontcode}{6}
% This was almost to easy --- a circle, an arc, and a line connecting
% them. 
%    \begin{macrocode}
beginchar("6",A_w#,l_h#,0) ; "The number 6" ;
  unicir(w/2,p_t,(w/2,w/2),10) ;
  uniarc(w/2,p_t,(w/2,h-w/2),60,180,20) ;
  pickup unipensqu ;
  top lft z1 = (0,h-w/2) ; bot lft z2 = (0,w/2) ; draw z1--z2 ;
  penlabels(1,2) ;
endchar;

%    \end{macrocode}
% \end{fontcode}
% \begin{fontcode}{7}
% Apperently, this character could have the same problems as the
% \textuni{2}, but it didn't --- can you see why not?
%    \begin{macrocode}
beginchar("7",A_w#,l_h#,0) ; "The number 7" ;
  z1 = (w-p_t,h-p_t) ; phi := angle(z1) ;
  uniend(p_t,z1,-90+phi,90,10) ;
  z2 = z1 + p_t*(cosd(90-phi),-sind(90-phi)) ;
  z3 = (p_t/cosd(90-phi),0) ; z4 = (0,0) ;
  fill z1--z2--z3--z4--cycle ;
  pickup unipensqu ;
  top lft z5 = (0,h) ; top rt z6 = (w-p_t,h) ; draw z5--z6 ;
  penlabels(range 1 thru 6) ;
endchar;

%    \end{macrocode}
% \end{fontcode}
% \begin{fontcode}{8}
% Ha ha, to circles, one on top of the other. Some may prefer if the
% bottom most circle had a slightly larger radius then the top most,
% but I believe that to be in conflict with the general idea of
% simplicity. 
%    \begin{macrocode}
beginchar("8",1/2*(l_h#+p_t#),l_h#,0) ; "The number 8" ;
  unicir(w/2,p_t,(w/2,w/2),10) ;
  unicir(w/2,p_t,(w/2,h-w/2),20) ;
endchar;

%    \end{macrocode}
% \end{fontcode}
% \begin{fontcode}{9}
% See above under \textuni{6}.
%    \begin{macrocode}
beginchar("9",A_w#,l_h#,0) ; "The number 9" ;
  unicir(w/2,p_t,(w/2,h-w/2),10) ;
  uniarc(w/2,p_t,(w/2,w/2),-150,0,20) ;
  pickup unipensqu ;
  top rt z1 = (w,h-w/2) ; bot rt z2 = (w,w/2) ; draw z1--z2 ;
  penlabels(1,2) ;
endchar;

%    \end{macrocode}
% \end{fontcode}
%\iffalse
%</dig>
%\fi
%\iffalse
%<*spe>
%\fi
% \subsection{Specials --- \texttt{unispe.mf}}
% \file{unispe.mf}
% 
% For these characters, I couldn't find any original design,
% so once again, I did some inter-- and extrapolation, plus I had some
% print--outs of other implenations of Herbert Bayers universal
% font. So once again, I am to blame for any aestethic judgements.
%
% \begin{fontcode}{\char"10}
% At first I thought I didn't had to do this character, but then I
% realized that you \emph{do} needed, since some words are spelled
% with some sort of accent over the ``i'', other then a single dot,
% e.g., \textunibf{na\"ive}.
%    \begin{macrocode}
beginchar(hex"10",p_t#,x_h#,0) ; "The dotless letter i" ;
  pickup unipensqu ;
  bot lft z1 = (0,0) ; top lft z2 = (0,h) ; draw z1--z2;
  penlabels(1,2);
endchar;

%    \end{macrocode}
% \end{fontcode}
% \begin{fontcode}{\char"11}
% Non single dot j's are not as frequent as those of i's, so for the
% sake of completness, if nothing else, this letter is included.
%    \begin{macrocode}
beginchar(hex"11",p_t#,x_h#,p_d#) ; "The dotless letter j" ;
  pickup unipensqu ;
  bot lft z1 = (0,-d) ;  top lft z2 = (0,h) ; draw z1--z2 ;
  penlabels(1,2);
endchar;

%    \end{macrocode}
% \end{fontcode}
% \begin{fontcode}{\char"24}
% I couldn't make up my mind wether this should just be a \textunibf{s},
% with a vertical bar through, or if I should make it differntly. In
% the end, I chose to make it different, since I think it looks best
% in the context of the font.
%    \begin{macrocode}
beginchar("$",(l_h#-c_d#+p_t#)/2,l_h#,c_d#) ; "The dollar sign ($)" ;
  uniarc(w/2,p_t,(w/2,w/2),180,450,10) ;
  uniarc(w/2,p_t,(w/2,h-c_d-w/2),0,270,20) ;
  pickup unipensqu ;
  top z1 = (w/2,h) ; bot z2 = (w/2,-d) ; draw z1--z2 ;
  penlabels(1,2) ;
endchar;

%    \end{macrocode}
% \end{fontcode}
% \begin{fontcode}{\char"26}
% You could argue back and forth on the shape of the ampersand, but I
% decided to go for a simple design.
%    \begin{macrocode}
beginchar("&",(l_h#+p_t#)/2+c_d#,l_h#,c_d#) ; "The ampersand (&)" ;
  rad := (w-c_d)/2 ;
  unicir(rad,p_t,(rad,h-rad),10) ;
  uniarc(rad,p_t,(rad,rad),0,270,20) ;
  pickup unipensqu ;
  lft bot z1 = (rad,0)     ; rt bot z2 = (w,0)      ; draw z1--z2 ;
  rt  top z3 = (w-c_d,rad) ; rt bot z4 = (w-c_d,-d) ; draw z3--z4 ;
  penlabels(1,2,3,4) ;
endchar;

%    \end{macrocode}
% \end{fontcode}
% \begin{fontcode}{?}
% I did have some considerations concerning this. Since I had kind of
% decided to make avery junction ``smooth'', this also had to
% be. However, that meant, that my original plan, to make this letter
% as wide as an \textunibf{A}, didn't work, so I had to make it less
% wide, which in the end does look better.
%    \begin{macrocode}
beginchar("?",l_h#-5c_d#/2,l_h#,0) ; "The question mark (?)" ;
  temp := angle((P_T,-w/2)) - 0.01 ;
  uniarc(w/2,P_T,(w/2,h-w/2),temp,180,10) ;
  uniend(P_T,((w+P_T)/2,h-w),90,180,20) ;
  uniend(P_T,((w+P_T)/2,h-w+P_T),270,360+temp,30) ;
  pickup UniPensqu ;
  top z1 = (w/2,h-w) ; bot z2 = (w/2,2P_T) ; draw z1--z2 ;
  pickup UniPencir ;
  bot z3 = (w/2,0) ; drawdot z3 ;
  penlabels(1,2,3) ;
endchar;

%    \end{macrocode}
% \end{fontcode}
% \begin{fontcode}{\char"3E}
% These Spanish special letters, are just rotations, so nothing
% special is going on here.
%    \begin{macrocode}
beginchar(spanish_query,l_h#-5c_d#/2,x_h#,p_d#) ; "The Spanish query" ; 
  temp := angle((-P_T,w/2))-0.01 ;
  uniarc(w/2,P_T,(w/2,-d+w/2),temp,360,10) ;
  uniend(P_T,((w-P_T)/2,-d+w),270,360,20) ;
  uniend(P_T,((w-P_T)/2,-d+w-P_T),90,temp,30) ;
  pickup UniPensqu ;
  bot z1 = (w/2,-d+w) ; top z2 = (w/2,h-2P_T) ; draw z1--z2 ;
  pickup UniPencir ;
  top z3 = (w/2,h) ; drawdot z3 ;
  penlabels(1,2,3) ;
endchar;

%    \end{macrocode}
% \end{fontcode}
% \begin{fontcode}{\char"3C}
% See above.
%    \begin{macrocode}
beginchar(spanish_shriek,P_T#,x_h#,p_d#) ; "The Spanish shriek" ;
  pickup UniPencir ; top z1 = (w/2,h) ; drawdot z1 ;
  pickup UniPensqu ; top z2 = (w/2,h-2P_T) ; bot z3 = (w/2,-d) ;
  draw z2--z3 ; penlabels(1,2,3) ;
endchar;

%    \end{macrocode}
% \end{fontcode}
%\iffalse
%</spe>
%\fi
%\iffalse
%<*pun>
%\fi
% \subsection{Punctuations --- \texttt{unipun.mf}}
% \file{unipun.mf}
%
% This is the programs for general punctuation marks, ranging from
% period to ast.
%
% \begin{fontcode}{\char"21}
% Quite a simple character. Notice the use of \texttt{unipencir}.
%    \begin{macrocode}
beginchar("!",P_T#,l_h#,0) ; "The exclamation mark (!)" ;
  pickup UniPensqu ;
  top lft z1 = (0,h) ; bot lft z2 = (0,2P_T) ; draw z1--z2 ;
  pickup UniPencir ;
  bot lft z3 = (0,0) ; drawdot z3 ;
  penlabels(1,2,3) ;
endchar;

%    \end{macrocode}
% \end{fontcode}
% \begin{fontcode}{(}
% Here, and in the next character ()) we don't use pens, since we can
% get a much better resault using the \MF{} path macro \texttt{...} .
%    \begin{macrocode}
beginchar("(",x_w#/2,l_h#,p_d#) ; "The left paranthesis (()" ;
  z1 = (w,h)      ; z2 = (p_t,(h-d)/2) ; z3 = (w,-d)    ;
  z4 = (w-p_t,-d) ; z5 = (0,(h-d)/2)   ; z6 = (w-p_t,h) ;
  fill z1..z2..z3--z4..z5..z6--cycle ;
  penlabels(range 1 thru 6) ;  
endchar;

%    \end{macrocode}
% \end{fontcode}
% \begin{fontcode}{)}
%    \begin{macrocode}
beginchar(")",x_w#/2,l_h#,p_d#) ; "The right paranthesis ())" ;
  z1 = (p_t,h) ; z2 = (w,(h-d)/2)     ; z3 = (p_t,-d)    ;
  z4 = (0,-d)  ; z5 = (w-p_t,(h-d)/2) ; z6 = (0,h)       ;
  fill z1..z2..z3--z4..z5..z6--cycle ;
  penlabels(range 1 thru 6) ;  
endchar;

%    \end{macrocode}
% \end{fontcode}
%
% \begin{fontcode}{\#}
% I never really got satisfied with this letter, but this is the best
% I could do --- who ever uses a \# anyway!
%    \begin{macrocode}
beginchar("#",x_w#,x_h#,0) ; "The hash mark (#)" ;
  unilne(p_t,(0,0),(w/2,h),1,1,10) ;
  unilne(p_t,(w/2,0),(w,h),1,1,20) ;
  pickup unipensqu ;
  top lft z1 = (0,(h-c_d)/2) ; top rt z2 = (w,(h-c_d)/2) ;
  bot lft z3 = (0,(h+c_d)/2) ; bot rt z4 = (w,(h+c_d)/2) ;
  draw z1--z2 ; draw z3--z4 ;
  penlabels(1,2,3,4) ;
endchar;

%    \end{macrocode}
% \end{fontcode}
% \begin{fontcode}{\%}
% Among other characters, this one made me define a dimension called
% \texttt{c\_d}, which is to be used for all kinds of curves. The idea
% is that, some sizes curves should depend on the weight of the font,
% and others not. Those that \emph{shouldn't} will use \texttt{c\_d}.
%    \begin{macrocode}
beginchar("%",x_w#,l_h#,0) ; "The percent sign (%)" ;
  temp := 3c_d/2 ;
  unicir(temp,p_t,(temp,h-temp),10) ;
  unicir(temp,p_t,(w-temp,temp),20) ;
  unilne(p_t,(0,0),(w,h),1,1,30) ;
endchar;

%    \end{macrocode}
% \end{fontcode}
% \begin{fontcode}{'}
% Agian we have a translated comma --- the apostrophe.
%    \begin{macrocode}
beginchar("'",2P_T#,l_h#,0) ; "The apostrophe (')" ;
  uniend(w/2,(w/2,h-w/2),0,180,10) ;
  z1 = (0,h-w/2) ; z2 = (w,h-w/2) ; z3 = (0,h-3w/2) ;
  fill z1--z2--z3--cycle ; penlabels(1,2,3) ;
endchar;

%    \end{macrocode}
% \end{fontcode}
% \begin{fontcode}{*}
% This isn't really complicated execpt for the value of \texttt{temp},
% which insures that the top of ast will be in the character.
%    \begin{macrocode}
beginchar("*",x_w#,l_h#,0) ; "The ast (*)" ;
  path rect ;
  temp := h-(w*sind(60)-p_t*cosd(60))/2 ;
  pickup unipensqu ;
  lft z1 = (0,temp) ; rt z2 = (w,temp) ; draw z1--z2 ;
  rect = (bot lft z1)--(top lft z1)--(top rt z2)--(bot rt z2)--cycle ;
  fill rect rotatedabout((w/2,temp),60) ;
  fill rect rotatedabout((w/2,temp),120) ;
  penlabels(1,2) ;
endchar;

%    \end{macrocode}
% \end{fontcode}
% \begin{fontcode}{+}
% Plus and minus, now that's easy.
%    \begin{macrocode}
beginchar("+",x_w#,x_h#,0) ; "The plus sign (+)" ;
  pickup unipensqu ;
  lft z1 = (0,w/2) ; rt  z2 = (w,w/2) ; draw z1--z2 ;
  bot z3 = (w/2,0) ; top z4 = (w/2,w) ; draw z3--z4 ;
endchar;

%    \end{macrocode}
% \end{fontcode}
% \begin{fontcode}{,}
% Incedently, the apostrophs (both single and reversed), are
% just translations and reflections of the comma.
%
% \textsl{Mathemathical problem:} Work out which algebraic group the
% characters `\textunibf{,}', `\textunibf{'}', and `\textunibf{`}',
% belongs to? 
%    \begin{macrocode}
beginchar(",",2P_T#,2P_T#,2P_T#) ; "The punctuation ," ;
  uniend(w/2,(w/2,0),0,180,10) ;
  z1 = (0,0) ; z2 = (w,0) ; z3 = (0,-d) ;
  fill z1--z2--z3--cycle  ; penlabels(1,2,3) ;
endchar;

%    \end{macrocode}
% \end{fontcode}
% \begin{fontcode}{-}
% Minus? --- isn't it the opposite of plus?
%    \begin{macrocode}
beginchar("-",4x_w#/5,x_h#,0) ; "The hyphen (-)" ;
  pickup unipensqu ;
  lft z1 = (0,h/2) ; rt z2 = (w,h/2) ; draw z1--z2 ;
  penlabels(1,2);
endchar;

%    \end{macrocode}
% \end{fontcode}
% \begin{fontcode}{.}
% Wow, a dot!
%    \begin{macrocode}
beginchar(".",2P_T#,2P_T#,0) ; "The punctuation ." ;
  uniend(w/2,(w/2,h/2),0,360,10) ;
%  pickup UniPencir ; lft bot z1 = (0,0) ; drawdot z1 ; penlabels(1); 
endchar;

%    \end{macrocode}
% \end{fontcode}
% \begin{fontcode}{/}
% This is a nice utilization of \texttt{unilne}.
%    \begin{macrocode}
beginchar("/",x_w#,l_h#,0) ; "The slash (/)" ;
  unilne(p_t,(0,0),(w,h),1,1,10) ;
endchar;

%    \end{macrocode}
% \end{fontcode}
% \begin{fontcode}{:}
% Wauw, \emph{two} dots --- cool!
%    \begin{macrocode}
beginchar(":",2P_T#,x_h#,0) ; "The punctuation :" ;
  uniend(w/2,(w/2,h-w/2),0,360,10) ;
  uniend(w/2,(w/2,w/2),0,360,20) ;
endchar;

%    \end{macrocode}
% \end{fontcode}
% \begin{fontcode}{;}
% Again, this is straight forward.
%    \begin{macrocode}
beginchar(";",2P_T#,x_h#,2P_T#) ; "The punctuation ;" ;
  uniend(w/2,(w/2,h-w/2),0,360,10) ;
  uniend(w/2,(w/2,0),0,180,20) ;
  z2 = (0,0) ; z3 = (w,0) ; z4 = (0,-d) ; fill z2--z3--z4--cycle ; 
  penlabels(1,2,3,4) ;
endchar;

%    \end{macrocode}
% \end{fontcode}
% \begin{fontcode}{\char"3D}
% These characters are rediculously simple.
%    \begin{macrocode}
beginchar("=",x_w#,x_h#,0) ; "The equal sign (=)" ;
  pickup unipensqu ;
  top lft z1 = (0,(h-p_t)/2) ; top rt z2 = (w,(h-p_t)/2) ;
  bot lft z3 = (0,(h+p_t)/2) ; bot rt z4 = (w,(h+p_t)/2) ;
  draw z1--z2 ; draw z3--z4 ;
  penlabels(1,2,3,4) ;
endchar;

%    \end{macrocode}
% \end{fontcode}
% \begin{fontcode}{@}
% Now this was a bit of a challenge. It is clear, that the left stroke
% should be a straight line tarveling all the way to the baseline, but
% how big should the small circle be. I decided to go for the largest
% one, that didn't touch or intersected the outer arc more then one
% place, i.e., at the far left.
%    \begin{macrocode}
beginchar("@",l_h#,l_h#,0) ; "The at sign (@)" ;
  uniarc(w/2,p_t,(w/2,h/2),0,240,10) ;
  unicir(w/3,p_t,(2w/3,w/3),20) ;
  pickup unipensqu ;
  top rt z1 = (w,w/2) ; bot rt z2 = (w,0) ; draw z1--z2 ;
  penlabels(1,2) ;
endchar;

%    \end{macrocode}
% \end{fontcode}
% \begin{fontcode}{[}
% Notice the soft corners. This is ofcourse accomplieshed with
% \texttt{uniend}, which turned out to be a very nice macro.
%    \begin{macrocode}
beginchar("[",3p_t#,l_h#,p_d#) ; "The left bracket ([)" ;
  uniend(p_t,(p_t,h-p_t),90,180,10) ;
  uniend(p_t,(p_t,-d+p_t),180,270,20) ;
  pickup unipensqu ;
  top lft z1 = (p_t,h)   ; top rt  z2 = (w,h)      ; draw z1--z2 ;
  top lft z3 = (0,h-p_t) ; bot lft z4 = (0,-d+p_t) ; draw z3--z4 ;
  bot lft z5 = (p_t,-d)  ; bot rt  z6 = (w,-d)     ; draw z5--z6 ;
  penlabels(range 1 thru 6) ;
endchar;

%    \end{macrocode}
% \end{fontcode}
% \begin{fontcode}{]}
% Speaking of reflections.
%    \begin{macrocode}
beginchar("]",3p_t#,l_h#,p_d#) ; "The right braket (])" ;
  uniend(p_t,(w-p_t,h-p_t),0,90,10) ;
  uniend(p_t,(w-p_t,-d+p_t),270,360,20) ;
  pickup unipensqu ;
  top lft z1 = (0,h)     ; top rt  z2 = (w-p_t,h)  ; draw z1--z2 ;
  top rt  z3 = (w,h-p_t) ; bot rt  z4 = (w,-d+p_t) ; draw z3--z4 ;
  bot lft z5 = (0,-d)    ; bot rt  z6 = (w-p_t,-d) ; draw z5--z6 ;
  penlabels(range 1 thru 6) ;
endchar;

%    \end{macrocode}
% \end{fontcode}
% \begin{fontcode}{`}
% Who is this `comma' character --- he keeps poping up the strangest
% places. 
%    \begin{macrocode}
beginchar("`",2P_T#,l_h#,0) ; "The reversed apostroph (`)" ;
  uniend(w/2,(w/2,h-w),180,360,10) ;
  z1 = (0,h) ; z2 = (0,h-w) ; z3 = (w,h-w) ; fill z1--z2--z3--cycle ; 
  penlabels(1,2,3) ;
endchar;

%    \end{macrocode}
% \end{fontcode}
% \begin{fontcode}{--}
% Ah, a horizontal line --- how fascinating!
%    \begin{macrocode}
beginchar(hex"7B",m_w#,x_h#,0) ; "The en-dash (--)" ;
  pickup unipensqu ;
  lft z1 = (0,h/2) ; rt z2 = (w,h/2) ; draw z1--z2 ;
  penlabels(1,2) ;
endchar;

%    \end{macrocode}
% \end{fontcode}
% \begin{fontcode}{---}
% And another horizontal line --- and it's even longer then the
% previous one.
%    \begin{macrocode}
beginchar(hex"7C",M_w#,x_h#,0) ; "The em-dash (---)" ;
  pickup unipensqu ;
  lft z1 = (0,h/2) ; rt z2 = (w,h/2) ; draw z1--z2 ;
  penlabels(1,2) ;
endchar;

%    \end{macrocode}
% \end{fontcode}
%\iffalse
%</pun>
%\fi
%\iffalse
%<*acc>
%\fi
% \subsection{Accents --- \texttt{uniacc.mf}}
% \file{uniacc.mf}
% \begin{fontcode}{\char"12}
% Even though you use a reversed apostrophe in \LaTeX{} to get this
% accent, the accent shouldn't look like a apostophe, that would be
% far to clumsy. So instead we \emph{rotate} a comma and translate it
% --- algebraic groups again!
%    \begin{macrocode}
beginchar(hex"12",x_w#,l_h#,0) ; "The accent `" ;
  uniend(P_T/2,(w/2,a_h+P_T/2),90,270,10) ;
  z1 = (w/2,a_h+P_T) ; z2 = (w/2,a_h) ; z3 = (w/2+P_T,a_h) ; 
  fill z1--z2--z3--cycle ; penlabels(1,2,3) ;
endchar ;

%    \end{macrocode}
% \end{fontcode}
% \begin{fontcode}{\char"13}
% See above.
%    \begin{macrocode}
beginchar(hex"13",x_w#,l_h#,0) ; "The accent '" ;
  uniend(P_T/2,(w/2,a_h+P_T/2),-90,90,10) ;
  z1 = (w/2,a_h+P_T) ; z2 = (w/2,a_h) ; z3 = (w/2-P_T,a_h) ; 
  fill z1--z2--z3--cycle ; penlabels(1,2,3) ;
endchar ;

%    \end{macrocode}
% \end{fontcode}
% \begin{fontcode}{\char"14}
%    \begin{macrocode}
beginchar(hex"14",x_w#,l_h#,0) ; "The accent hachek" ;
  z1 = (w/2,a_h+p_t) ; uniend(p_t,z1,225,315,10) ;
  z2 = z1 + p_t*(-1,-1)/sqrt(2) ; z3 = z1 + p_t*(-1,1) ;
  z4 = z3 + (-p_t*sqrt(2),0) ; path rombe ;
  rombe := z1--z2--z4--z3--cycle ; fill rombe ;
  fill rombe reflectedabout ((w/2,0),(w/2,h)) ;
  penlabels(1,2,3,4) ;
endchar ;

%    \end{macrocode}
% \end{fontcode}
% \begin{fontcode}{\char"15}
%    \begin{macrocode}
beginchar(hex"15",x_w#,l_h#,0) ; "The accent breve" ;
  rad := 3p_t/2 ; uniarc(rad,p_t,(w/2,a_h+rad),180,360,10) ;
endchar ;

%    \end{macrocode}
% \end{fontcode}
% \begin{fontcode}{\char"16}
%    \begin{macrocode}
beginchar(hex"16",x_w#,a_h#+p_t#,0) ; "The accent macron (bar)" ;
  pickup unipensqu ;
  bot lft z1 = (w/2-2p_t,a_h) ; bot rt z2 = (w/2+2p_t,a_h) ;
  draw z1--z2 ; penlabels(1,2) ;
endchar ;

%    \end{macrocode}
% \end{fontcode}
% \begin{fontcode}{\char"17}
%    \begin{macrocode}
beginchar(hex"17",A_w#+4/3*(l_h#-x_h#)*slantratio,l_h#,0) ;
  "The accent circle" ;
  rad := P_T ; unicir(rad,p_t,(w/2,h-rad),10) ;
endchar ;

%    \end{macrocode}
% \end{fontcode}
% \begin{fontcode}{\char"18}
%    \begin{macrocode}
beginchar(hex"18",x_w#,x_h#,2c_d#) ; "The accent cidelia" ;
  uniarc(d/2,2P_T/3,(w/2+d/4,-d/2),90,270,10) ;
endchar ;

%    \end{macrocode}
% \end{fontcode}
% \begin{fontcode}{\char"20}
%    \begin{macrocode}
phi := 15 ; tmp# := 3c_d# ; define_pixels(tmp) ;
beginchar(hex"20",tmp#*cosd(phi)+p_t#*sind(phi),l_h#,0) ;
  "The accent bar over l" ;
  z1 = (0,(h+p_t*cosd(phi)-tmp*sind(phi))/2) ;
  z2 = (p_t*sind(phi),(h-p_t*cosd(phi)-tmp*sind(phi))/2) ;
  z3 = (w,(h-p_t*cosd(phi)+tmp*sind(phi))/2) ;
  z4 = (w-p_t*sind(phi),(h+p_t*cosd(phi)+tmp*sind(phi))/2) ;
  fill z1--z2--z3--z4--cycle ;
  penlabels(1,2,3,4) ;
endchar ;

%    \end{macrocode}
% \end{fontcode}
% \begin{fontcode}{\char"5E}
%    \begin{macrocode}
beginchar(hex"5E",x_w#,l_h#,0) ; "The accent hat" ;
  z1 = (w/2,a_h+p_t) ; uniend(p_t,z1,45,136,10) ;
  z2 = z1 + p_t*(-1,1)/sqrt(2) ; z3 = z1 + p_t*(-1,-1) ;
  z4 = z3 + (-p_t*sqrt(2),0) ; path rombe ;
  rombe := z1--z2--z4--z3--cycle ; fill rombe ;
  fill rombe reflectedabout ((w/2,0),(w/2,h)) ;
  penlabels(1,2,3,4) ;
endchar ;

%    \end{macrocode}
% \end{fontcode}
% \begin{fontcode}{\char"5F}
%    \begin{macrocode}
beginchar(hex"5F",x_w#,l_h#,0) ; "The accent dot" ;
  pickup UniPencir ; bot z1 = (w/2,a_h) ; drawdot z1 ; penlabels(1) ;
endchar ;

%    \end{macrocode}
% \end{fontcode}
% \begin{fontcode}{\char"7D}
%    \begin{macrocode}
beginchar(hex"7D",x_w#,l_h#,0) ; "The accent ''" ;
  rad := P_T/2 ;
  uniend(rad,(w/2-rad,a_h+rad),-90,90,10) ;
  uniend(rad,(w/2+P_T,a_h+rad),-90,90,20) ;
  z1 = (w/2-rad-P_T,a_h) ; z2 = (w/2-rad,a_h) ;
  z3 = (w/2-rad,a_h+P_T) ; fill z1--z2--z3--cycle ;
  z4 = (w/2,a_h)         ; z5 = (w/2+P_T,a_h) ;
  z6 = (w/2+P_T,a_h+P_T) ; fill z4--z5--z6--cycle ;
  penlabels(range 1 thru 6) ;
endchar ;

%    \end{macrocode}
% \end{fontcode}
% \begin{fontcode}{\char"7E}
%    \begin{macrocode}
beginchar(hex"7E",x_w#,l_h#,0) ; "The accent ~" ;
  rad := (w*sqrt(2)+p_t)/4 ; temp := (2w-p_t*sqrt(2))/8 ;
  uniarc(rad,p_t,(w/2+temp,a_h+rad),225,315,10) ;
  uniarc(rad,p_t,(w/2-temp,a_h+rad-2temp),45,135,20) ;
endchar ;

%    \end{macrocode}
% \end{fontcode}
% \begin{fontcode}{\char"7F}
%    \begin{macrocode}
beginchar(hex"7F",x_w#,l_h#,0) ; "The accent umlout (double dot)" ;
  pickup UniPencir ;
  bot z1 = (w/2-P_T,a_h) ; bot z2 = (w/2+P_T,a_h) ;
  drawdot z1 ; drawdot z2 ; penlabels(1,2) ;
endchar ;

%    \end{macrocode}
% \end{fontcode}
%\iffalse
%</acc>
%\fi
%\iffalse
%<*lig>
%\fi
% \subsection{Ligatures --- \texttt{unilig.mf}}
% \file{unilig.mf}
%
% \begin{fontcode}{SS}
% If we are making a small caps shaped font, then we need to make an
% upper case version of the german double s (\ss), so we start of
% testing if the \texttt{caps} flag is set.
%    \begin{macrocode}
if caps:
  beginchar(hex"19",5/2x_w#,x_h#,0) ; "Ligature SS" ;
    temp := (h+p_t)/4 ;
    uniarc(temp,p_t,(temp,temp),180,270,10) ;
    uniarc(temp,p_t,(2w/5-temp,temp),270,450,20) ;
    uniarc(temp,p_t,(temp,h-temp),90,270,30) ;
    uniarc(temp,p_t,(2w/5-temp,h-temp),0,90,40) ;
    pickup unipensqu ;
    bot lft z1 = (temp,0)   ; bot rt z2 = (2w/5-temp,0)   ; 
    lft     z3 = (temp,h/2) ; rt     z4 = (2w/5-temp,h/2) ; 
    top lft z5 = (temp,h)   ; top rt z6 = (2w/5-temp,h)   ; 
    draw z1--z2 ; draw z3--z4 ; draw z5--z6 ; 
    penlabels(1,2,3,4,5,6) ;
    currentpicture := currentpicture + (currentpicture shifted
      (3/5w,0)) ; 
  endchar ; 
  
%    \end{macrocode}
% \end{fontcode}
% \begin{fontcode}{\char"19}
% If we are not making a small caps font, then the usual german double
% s is made.
%    \begin{macrocode}
else:
  beginchar(hex"19",(l_h#+3p_t#)/2,l_h#,p_t#) ; "Ligature ss" ;
    rad := (w-p_t)/2 ;
    uniarc(rad,p_t,(p_t+rad,h-rad),-90,180,10) ;
    uniarc(rad,p_t,(p_t+rad,rad),-90,90,20) ;
    pickup unipensqu ;
    top lft z1 = (p_t,h-rad) ; bot lft z2 = (p_t,-d) ; draw z1--z2 ;
    lft     z3 = (0,h/2)     ; rt z4 = (w-rad,h/2)   ; draw z3--z4 ;
    penlabels(1,2,3,4) ;
  endchar ;
fi ;

%    \end{macrocode}
% \end{fontcode}
% The next three characters should not be made in a small caps font,
% so  these are all put in side the conditinal
% \begin{verbatim}
%   if not caps :
% \end{verbatim}
% However, we need to put small caps versions of these letters in the
% position of these charcaters, so we use a little trick later on to
% do this.
%
% And if we are making a \emph{strict} shaped font, then we need to
% put these characters into two slots each, with three slots between
% the to replicas of the character. In that case, we first evaluate
% the code once, then if \texttt{strict} is false, we go on in the
% code, otherwise, we evaluate the code once more, \emph{but} the
% characters is put into new slots 3 slots later then before, since
% \texttt{code\_offset} now is 3. Finally in the end we reset
% \texttt{code\_offset}.
%
% This trick is used also in \texttt{uniext.mf} and
% \texttt{unilow.mf}.
% 
% \begin{fontcode}{\char"1A}
% This is just a combination of an \textunibf{a} and \textunibf{e},
% which we earlier on saved in the picture variables \texttt{a\_pic}
% and \texttt{e\_pic}.
%    \begin{macrocode}
if not caps :
  for temp = 1,2 :
    if temp = 2 : code_offset := 3 ; fi ;
    beginchar(hex"1A",2x_w#-p_t#,x_h#,0) ; "Ligature ae" ;
      currentpicture := a_pic + ( e_pic shifted ((w-p_t)/2,0)) ;
    endchar ;

%    \end{macrocode}
% \end{fontcode}
% \begin{fontcode}{\char"1B}
% This is just a compinition of an \textunibf{o} and
% \textunibf{e}. The \textunibf{e} we saved earlier on in the picture
% variable \texttt{e\_pic}. The \textunibf{o} part is drawn anew.
%    \begin{macrocode}
    beginchar(hex"1B",2x_w#-p_t#,x_h#,0) ; "Ligature oe" ;
      unicir(h/2,p_t,(h/2,h/2),10) ;
      currentpicture := currentpicture + (e_pic shifted ((w-p_t)/2,0)) ;
    endchar ;

%    \end{macrocode}
% \end{fontcode}
% \begin{fontcode}{\char"1C}
% This is really a simple letter. It utilizes the to macros
% \texttt{unicir} and \texttt{unilne} in a very nice way, I think. 
%    \begin{macrocode}
    beginchar(hex"1C",x_w#,x_h#,0) ; "Ligature o/" ;
      unicir(w/2,p_t,(w/2,h/2),10) ;
      unilne(p_t,(0,0),(w,h),1,1,20) ;
    endchar ;
    exitif (not strict) ;
    if temp = 2 : code_offset := 0 ; fi ;
  endfor ;
fi ;

%    \end{macrocode}
% \end{fontcode}
% Since we don't want any majusculues in the \emph{strict} shaped
% font, the next three characteres is only generated if
% \texttt{strict} is \texttt{false}.
% 
% Since we have to make two version of the majuscules below in a small
% caps font, we set up an \texttt{fot} loop. The trick is this: The
% loop while always execute once, so the characters will always be
% made in the original size. Now, if we are making a small caps font,
% then the loop will execute once more, and we call the macro
% \texttt{do\_font} (\texttt{temp = 2}), so that the new characters
% will have the right dimensions.
%    \begin{macrocode}
if not strict :
  for temp = 1,2 :
    if temp = 2 : do_caps(-3) ; fi ;

%    \end{macrocode}
% \begin{fontcode}{\char"1D}
% It wouln't make any sense to just do a combinition of \textunibf{A} 
% and \textunibf{E}, as were done in minuscules above, so we draw the
% whole letter anew.
%    \begin{macrocode}
    beginchar(hex"1D",M_w#,l_h#,0) ; "Ligature AE" ;
      uniarc(w/2,P_t,(w/2,h-w/2),90,180,21) ;
      uniend(P_t,((w+P_t)/2,P_t),180,270,30) ;
      pickup Unipensqu ;
      top lft z1 = (w/2,h)       ; top rt  z2 = (w,h)      ; 
      top lft z3 = (0,h-w/2)     ; bot lft z4 = (0,0)      ; 
      lft     z5 = (0,h/2)       ; rt      z6 = (w,h/2)    ; 
      bot lft z7 = ((w+P_t)/2,0) ; bot rt  z8 = (w,0)      ; 
      top     z9 = (w/2,h)       ; bot     z10 = (w/2,P_t) ;
      draw z1--z2 ; draw z3--z4 ; draw z5--z6 ;
      draw z7--z8 ; draw z9--z10 ;  
      penlabels(range 1 thru 10) ;
    endchar ;

%    \end{macrocode}
% \end{fontcode}
% \begin{fontcode}{\char"1E}
% Again, a simple combination of \textunibf{O} and \textunibf{E},
% wouldn't  work. 
%    \begin{macrocode}
    beginchar(hex"1E",M_w#,l_h#,0) ; "Ligature OE" ;
      uniarc(h/2,P_t,(h/2,h/2),90,270,10) ;
      pickup Unipensqu ;
      top lft z1 = (h/2,h)   ; top rt  z2 = (w,h)   ; draw z1--z2 ;
      lft     z3 = (h/2,h/2) ; rt      z4 = (w,h/2) ; draw z3--z4 ;
      bot lft z5 = (h/2,0)   ; bot rt  z6 = (w,0)   ; draw z5--z6 ;
      top     z7 = (h/2,h)   ; bot     z8 = (h/2,0) ; draw z7--z8 ;
      penlabels(range 1 thru 8) ;
    endchar ;

%    \end{macrocode}
% \end{fontcode}
% \begin{fontcode}{\char"1F}
% What a said above the minuscule \textunibf{\o} also goes for this 
% letter, since this is nothing but an enlargement of that character. 
%    \begin{macrocode}
    beginchar(hex"1F",l_h#,l_h#,0) ; "Liguture O/" ;
      unicir(w/2,P_t,(w/2,h/2),10) ;
      unilne(P_t,(0,0),(w,h),1,1,20) ;
    endchar ;

%    \end{macrocode}
% \end{fontcode}
% This is where it gets tricky. First we check to see if we are
% maiking an small caps font, and if not so, we should exit the loop
% right away, so that we don't screw up the minuscules we already have
% made above. If, however, we are making a small caps font, we should,
% after the second run, restore the dimensions to it's original state.
%    \begin{macrocode}
    exitif (not caps) ;
    if temp = 2 : end_do_caps ; fi ;
  endfor ;
fi ;

%    \end{macrocode}
%\iffalse
%</lig>
%\fi
%\iffalse
%<*ext>
%\fi
% \subsection{Extras --- \texttt{uniext.mf}}
% \file{uniext.mf}
%
% Please notice I included \textunibf{\char"0B}, \textunibf{\char"0C},
% \textunibf{\char"0D}, and \textunibf{\char"0E}, which isn't
% standard Computer Modern Roman policy. See more below.
%
% \Newestchanges{v2.0}{98/08/01}{Some of the \textunibf{bauhaus} symbols
% that where avaliable in v1.0, has been taken out.}
% The first part of this file is some symbols relevant to the
% \textunibf{bauhaus} school. Please notice that some of the symbols
% present in version~1.0 has been taken out\footnote{If you have used
% version~1.0 of this font, and liked those characters and found them
% useful, you should e--mail me \texttt{<cholm@fys.ku.dk>} and let me
% know. If I get enough letters on this I will incorporate them again
% in future releases.}, since the were seldomly used, and it made the
% font contain exactly 128 characters.
%
% These characters should \emph{not} be slanted in a slanted shaped
% font, hence we redefine \texttt{currenttrans} to \texttt{identity},
% just before the next character, and resets it after the last
% character. Also notice that \textuni{\bauhead} and
% \textuni{\bauforms} may take some time to generate.
%    \begin{macrocode}
currenttransform := identity ;

%    \end{macrocode}
%
% \begin{fontcode}{\char"00}
% The next three characters are really not the complicated or useful
% by themselves, but if you combine them, maybe even with the
% \textsf{color} package of \LaTeX{}, you can really add some
% \textunibf{bauhaus} flavour to your document.
%
% The square, ofcourse is obvious.
%    \begin{macrocode}
beginchar(hex"00",l_h#,l_h#,0) ; "The filled square symbol" ;
  z1 = (0,0) ; z2 = (w,0) ; z3 = (w,h) ; z4 = (0,h) ;
  fill z1--z2--z3--z4--cycle ;
  penlabels(1,2,3,4) ;
endchar ;

%    \end{macrocode}
% \end{fontcode}
% \begin{fontcode}{\char"01}
% Also four vectors are defined, put translated a bit, and another
% path macro --- it is amazing how much you can do with so little.
%    \begin{macrocode}
beginchar(hex"01",l_h#,l_h#,0) ; "The filled circle symbol" ;
  z1 = (w,h/2) ; z2 = (w/2,h) ; z3 = (0,h/2) ; z4 = (w/2,0) ;
  fill z1..z2..z3..z4..cycle ;
  penlabels(1,2,3,4) ;
endchar ;

%    \end{macrocode}
% \end{fontcode}
% \begin{fontcode}{\char"02}
% Maybe every side of this trangle should be of the same length, mut
% then I had to make the triangle either lower, or wider then the
% square and circle. I couldn't decide, so I went for equal character
% dimensions --- so I believe in equality, sue me!
%    \begin{macrocode}
beginchar(hex"02",l_h#,l_h#,0) ; "The filled triangle symbol" ;
  z1 = (0,0) ; z2 = (w,0) ; z3 = (w/2,h) ;
  fill z1--z2--z3--cycle ;
  penlabels(1,2,3) ;
endchar ;

%    \end{macrocode}
% \end{fontcode}
% \begin{fontcode}{\char"03}
% This is a typical \textuni{bauhaus} symbol. I think it is very
% beautiful.
%
% First we draw the surrounding circle.
%    \begin{macrocode}
beginchar(hex"03",2l_h#,2l_h#,0) ; "The bauhaus-head symbol" ;
  unicir(w/2,2c_d/9,(w/2,w/2),40) ;
%    \end{macrocode}
% Then we define some horizontal variables $a_{1\ldots6}$ and some
% vertical variables $b_{1\ldots8}$.
%    \begin{macrocode}
  a1 := .702h  ; a2 := .561h  ; a3 := .491h  ; a4 := .351h  ;
  a5 := .272h  ; a6 := .140h  ;
  b1 := .202w ; b2 := .307w ; b3 := .412w ; b4 := .447w ;
  b5 := .465w ; b6 := .518w ; b7 := .588w ; b8 := .623w ;
%    \end{macrocode}
% Then we define the vectors needed for the eye, and draw the eye.
%    \begin{macrocode}
  temp := c_d/6 ; pickup pensquare scaled temp ;
  top lft z1 = (b1,a1) ; top rt z2 = (b2,a1) ; draw z1--z2 ;
  bot rt  z3 = (b4,a3) ; top rt z4 = (b4,a2) ; draw z3--z4 ;
  z5 = (b2,a1) ; z6 = (b4,a1) ; z7 = (b4,a2) ; z8 = (b2,a2) ;
  fill z5--z6--z7--z8--cycle ;
%    \end{macrocode}
% Then we define the vectors needed for the nostril, and draw it. We
% still use the pen used for the edges of the eye.
%    \begin{macrocode}
  lft bot z9 = (b4,a4) ; lft bot z10 = (b7,a4) ; draw z9--z10 ;
%    \end{macrocode}
% Next up is the chin. Again the same pen.
%    \begin{macrocode}
  lft bot z11 = (b2,a6) ; rt bot z12 = (b6,a6) ; draw z11--z12 ;
%    \end{macrocode}
% Now it's time for the lips. They need to be thicker then the chin
% and edges of the eye, so we pickup a new pen.
%    \begin{macrocode}
  temp := 3c_d/5 ; pickup pensquare scaled temp ;
  lft top z13 = (b5,a5) ; rt top z14 = (b6,a5) ; draw z13--z14 ;
%    \end{macrocode}
% It's time for the lower part of the face. Here we don't need to find
% strange paths or the like, so we do it all with a \texttt{fill}
% command. 
%    \begin{macrocode}
  z15 = (b6,a4) ; z16 = (b7,a4) ; z17 = (b7,a6) ; z18 = (b6,a6) ;
  fill z15--z16--z17--z18--cycle ;
%    \end{macrocode}
% Since it is not know where the forehead will end at the top, or
% where the nect will end in the bottom, we define some temporay
% paths, and make up the real ones from those.
%
% First we need to declare the paths.
%    \begin{macrocode}
  path noselft, nosert, necklft, neckrt ;
  path headcircle , parttop, partbot;
%    \end{macrocode}
% Then we build five temporary paths, one for each side of the
% forehead and neck, and one for the surronding circle.
%    \begin{macrocode}
  z19 = (b7,a4) ; z20 = (b7,h)  ; noselft = z19--z20 ;
  z21 = (b8,h)  ; z22 = (b8,a4) ; nosert  = z21--z22 ;
  z23 = (b3,a6) ; z24 = (b3,0)  ; necklft = z23--z24 ;
  z25 = (b6,0)  ; z26 = (b6,a6) ; neckrt  = z25--z26 ;
  z27 = (w/2,h) ; z28 = (w,h/2) ; z29 = (w/2,0) ; z30 = (0,h/2) ; 
  headcircle :=  z27..z28..z29..z30..cycle ;
%    \end{macrocode}
% Now we can determine the intersection points between our temporary
% paths and the circle, and define the vectors we need.
%
% We also find the parts of the path \texttt{headcircle} that are
% relevant for our to areas we need to fill. At last we can fill the
% areas. 
%    \begin{macrocode}
  z31 = noselft intersectiontimes headcircle ;
  z32 = nosert  intersectiontimes headcircle ;
  parttop = subpath(y31,y32) of headcircle ;
  z33 = neckrt  intersectiontimes headcircle ;
  z34 = necklft intersectiontimes headcircle ;
  partbot = subpath(y34,y33) of headcircle ;
  fill z19--parttop--z22--cycle ;
  fill z23--partbot--z26--cycle ;
  penlabels(range 1 thru 34) ;
endchar ;

%    \end{macrocode}
% \end{fontcode}
% \begin{fontcode}{\char"04}
% \Newestchanges{v2.0}{98/08/01}{Joseph Collins came up with the
% analytic solution --- thanks JC.}
% This is an interresting character. In version~1.0, I posed it as an
% mathemathical puzzle, and engourage people to work on it, and if
% they came up with a solution, pass it on to me. Well, Joseph Collins
% \index{Collins, Joseph} did just that, and for this I owe him many
% thanks. For more details on the problem and its solution, take a
% look in appendix~\ref{app:solu}.
%
% First we define some pen sizes we want to use, the variable
% \texttt{phi} and draw the circle around the character.
%    \begin{macrocode}
beginchar(hex"04",2l_h#,2l_h#,0) ; "The bauhaus-forms symbol" ;
  phi := 36.673 ;
  thn_pen := 2c_d/9 ; med_pen := 3c_d/9 ; thk_pen := 4c_d/9 ;
  unicir(w/2,thn_pen,(w/2,w/2),20) ;
%    \end{macrocode}
% Then we define the three vertices of the triangle --- points $A,B,C$
% in the notation of appendix~\ref{app:solu} --- and draw the curved
% ends there. 
%    \begin{macrocode}
  z1 = (thn_pen+med_pen,h/2) ;
  z2 = (.6433w-med_pen,.9790h-med_pen) ;
  z3 = (.6433w-med_pen,.0210h+med_pen) ;
  uniend(med_pen,z1,phi+90,270-phi,30) ;
  uniend(med_pen,z2,0,phi+90,40) ;
  uniend(med_pen,z3,270-phi,360,50) ;
%    \end{macrocode}
% After this, we calculate the rest of the points needed for the top
% most edge of the triangle, line $|AC|$. Then we reflect it
% horizontaly to get the bottom most line $|AB|$.
%
% Then we draw the vertical line $|BC|$ via a pen.
%    \begin{macrocode}
  z4 = z1 + med_pen*(-sind(phi),cosd(phi)) ;
  z5 = z2 + med_pen*(-sind(phi),cosd(phi)) ;
  path sl_line ; sl_line = z1--z4--z5--z2--cycle ; fill sl_line ;
  fill sl_line reflectedabout((0,h/2),(w,h/2)) ;
  pickup pensquare scaled med_pen ;
  lft bot z6 = z2 ; lft top z7 = z3 ; draw z6--z7 ;
%    \end{macrocode}
% Now it's time for the four vertices $P,Q,R,S$ of the square. Again
% we draw the cured ends at those four vertices. This time we use a
% thicker pen.
%    \begin{macrocode}
  z8 = (.3687w+thk_pen,.2254h+thk_pen) ;
  z9 = (.9179w-thk_pen,.2254h+thk_pen) ;
  z10 = (.9179w-thk_pen,.7746h-thk_pen) ;
  z11 = (.3687w+thk_pen,.7746h-thk_pen) ;
  uniend(thk_pen,z8,180,270,60) ;
  uniend(thk_pen,z9,270,360,70) ;
  uniend(thk_pen,z10,0,90,80) ;
  uniend(thk_pen,z11,90,180,90) ;
%    \end{macrocode}
% Finally we define the remaning needed vectors, and draw the edges
% $|PQ|,|QR|,|RS|$ and $|SP|$ of the square.
%    \begin{macrocode}
  pickup pensquare scaled thk_pen ;
  lft top z12 = z8  ; rt  top z13 = z9  ; draw z12--z13 ;
  lft bot z14 = z9  ; lft top z15 = z10 ; draw z14--z15 ;
  bot rt  z16 = z10 ; bot lft z17 = z11 ; draw z16--z17 ;
  top rt  z18 = z11 ; bot rt  z19 = z8  ; draw z18--z19 ;
  penlabels(range 1 thru 19) ;
endchar ;

%    \end{macrocode}
% After these five characters we reset \texttt{currenttransform} to
% include the slant specified by \texttt{slantratio}, so that the rest
% of the font will come out as it slanted if such a font is begin made.
%    \begin{macrocode}
currenttransform := identity slanted slantratio ;

%    \end{macrocode}
% \end{fontcode}
%
% Next we provide 6 charecters not directly avaliable in the
% \texttt{OT1}  encoding, but avaliable in the \texttt{T1} encoding of
% the Cork fonts. These are \textunibf{\NG}, \textunibf{\TH},
% \textunibf{\dh}, \textunibf{\ng}, and \textunibf{\th}, plus the
% accent `ogoneck' (on an \textunibf{a} it looks like
% \textunibf{\k{a}}).
%
% We do need to check again, wether we are making a small caps shaped
% font, and if so, we should not generate the minuscles
% \textunibf{\dh}, \textunibf{\ng}, and \textunibf{\th}.
%
% However, if we are making a \emph{strict} shaped font, then we need
% to make the characters twice, and we employe the trick used in
% \texttt{unilig.mf} again.
% 
% \begin{fontcode}{\char"05}
% I am not completly happy with this character, but it was the best I
% could think of. Please let me know if you have any kinds of
% suggestions. 
%    \begin{macrocode}
if not caps :
  for temp = 1,2 :
    if temp = 2 : code_offset := 3 ; fi ;
    beginchar(hex"05",x_w#,l_h#,0) ; "The letter eth" ;
      unicir(w/2,p_t,(w/2,w/2),10) ;
      uniarc(w/2,p_t,(w/2,h-w/2),0,120,20) ;
      pickup unipensqu ;
      top rt z1 = (w,h-w/2) ; bot rt z2 = (w,w/2) ; draw z1--z2 ;
      z3 = (w/2,h-w/2+p_t/sqrt(2)) ; z4 = (w/2+p_t/sqrt(2),h-w/2) ;
      z5 = (w,h-p_t/sqrt(2))       ; z6 = (w-p_t/sqrt(2),h)       ;
      fill z3--z4--z5--z6--cycle ;
      penlabels(range 1 thru 6) ;
    endchar ;

%    \end{macrocode}
% \end{fontcode}
% \begin{fontcode}{\char"06}
% This is very much like \textunibf{n}, but has a longer rightmost
% down stroke.
%    \begin{macrocode}
    beginchar(hex"06",x_w#,x_h#,p_d#) ; "The letter eng" ;
      uniarc(w/2,p_t,(w/2,h-w/2),0,180,10) ;
      pickup unipensqu ;
      top lft z1 = (0,h-w/2) ; bot lft z2 = (0,0)  ; draw z1--z2 ;
      top rt  z3 = (w,h-w/2) ; bot rt  z4 = (w,-d) ; draw z3--z4 ;
      penlabels(1,2,3,4) ;
    endchar ;

%    \end{macrocode}
% \end{fontcode}
% \begin{fontcode}{\char"07}
%    \begin{macrocode}
    beginchar(hex"07",x_w#,l_h#,p_d#) ; "The letter thorn" ;
      rad := (h+d)/4 ;
      uniarc(rad,p_t,(w-rad,rad),-90,90,10) ;
      pickup unipensqu ;
      top lft z1 = (0,h) ; bot lft z2 = (0,-d) ; draw z1--z2 ;
      top lft z3 = (p_t,2rad) ; top rt z4 = (w-rad,2rad) ;
      bot lft z5 = (p_t,0)    ; bot rt z6 = (w-rad,0)    ;
      draw z3--z4 ; draw z5--z6 ;
      penlabels(range 1 thru 6) ;
    endchar ;
    exitif (not strict) ;
    if temp = 2 : code_offset := 0 ; fi ;
  endfor ;
fi ;

%    \end{macrocode}
% \end{fontcode}
%
% Like in \texttt{unilig.mf} we now employe a trick to generate to
% versions of the uppercase letters \textunibf{\NG} and
% \textunibf{\TH}, that is \textunibsc{\ng} and \textunibsc{\th}.
%
% Since there us only two majuscules here, we might as well take
% advantige of the extra slot, and make a small caps version of
% \textunibf{\varQ}, so this is defined before \textunibf{\NG}, to
% take the place of \textunibf{dh}.
%     \begin{macrocode}
if not strict :
  for temp = 1,2 :
    if temp = 2 : do_caps(-3) ; fi ;
    
%    \end{macrocode}
% \begin{fontcode}{\char"08}
% This is the variant of \textunibf{Q} based an \textunibf{P}. This
% one is \emph{non}--default, you can acces this letter with
% \Lcs{varQ}\footnote{I am somewhat troubled with the majuscle `Q',
% because I don't know if the default one should be `\textunibf{Q}' or
% `\textunibf{\varQ}'. I will keep both characters in the font, but if
% enough wnats to chage the default, I will consider this
% ofcourse. Tell me \emph{your} opinon!}.
%    \begin{macrocode}
    beginchar(hex"08",A_w#,l_h#,0) ; "The variant letter Q";
      unicir(w/2,P_t,(w/2,h-w/2),10)
      pickup Unipensqu ;
      rt top z1 = (w,h-w/2) ; rt bot z2 = (w,0) ; draw z1--z2 ;
      penlabels(1,2);
    endchar ;

%    \end{macrocode}
% \end{fontcode}
% \begin{fontcode}{\char"09}
% This is similar to \textunibf{N}, execpt the rightmost vertical
% stroke ends in an arc.
%    \begin{macrocode}
    beginchar(hex"09",A_w#,l_h#,0) ; "The letter Eng" ;
      rad := 3C_d ;
      uniarc(w/2,P_t,(w/2,h-w/2),0,180,10) ;
      uniarc(rad,P_t,(w-rad,rad),-90,0,20) ;
      pickup Unipensqu ;
      top lft z1 = (0,h-w/2) ; bot lft z2 = (0,0);  draw z1--z2 ;
      top rt z3 = (w,h-w/2)  ; bot rt z4 = (w,rad) ;  draw z3--z4 ; 
      penlabels(1,2,3,4) ;
    endchar ;

%    \end{macrocode}
% \end{fontcode}
% \begin{fontcode}{\char"0A}
%    \begin{macrocode}
    beginchar(hex"0A",A_w#,l_h#,0) ; "The letter Thorn" ;
      rad := h/4 ;
      uniarc(rad,P_t,(w-rad,h/2),-90,90,10) ;
      pickup Unipensqu ;
      top lft z1 = (0,h) ; bot lft z2 = (0,0) ; draw z1--z2 ;
      top lft z3 = (P_t,h/2+rad) ; top rt z4 = (w-rad,h/2+rad) ;
      bot lft z5 = (P_t,h/2-rad) ; bot rt z6 = (w-rad,h/2-rad) ;
      draw z3--z4 ; draw z5--z6 ;
      penlabels(range 1 thru 6) ;
    endchar ;
    exitif (not caps) ;
    if temp = 2 : end_do_caps ; fi ;
  endfor ;
fi ;

%    \end{macrocode}
% \end{fontcode}
% \begin{fontcode}{\char"0B}
% This is actually a reversed cidelia accent.
%    \begin{macrocode}
beginchar(hex"0B",x_w#,x_h#,2c_d#) ; "The accent ogoneck" ;
  uniarc(d/2,2P_T/3,(w/2-d/4,-d/2),-90,90,10) ;
endchar ;

%    \end{macrocode}
% \end{fontcode}
% \begin{fontcode}{\char"0C}
% I chose to include the braces in the font, since you might needed
% them, and the Computer Modern Roman braces, doesn't really go with
% the rest of the font, so if you had to use those, it wouldn't look
% very good. They are, however not in the standard position, since
% that is already taken up.
%    \begin{macrocode}
beginchar(hex"0C",3c_d#,l_h#,p_d#) ; "The left brace ({)" ;
  uniarc(2c_d,p_t,(3c_d,h-2c_d),90,180,10) ;
  uniarc(2c_d,p_t,(3c_d,-d+2c_d),180,270,20) ;
  pickup unipensqu ;
  top lft z1 = (c_d,h-2c_d) ; bot lft z2 = (c_d,-d+2c_d) ; draw z1--z2 ;
  lft z3 = (0,(h-d)/2) ; rt z4 = (c_d,(h-d)/2) ; draw z3--z4 ;
  penlabels(1,2,3,4) ;
endchar ;

%    \end{macrocode}
% \end{fontcode}
% \begin{fontcode}{\char"0D}
% Discussion above.
%    \begin{macrocode}
beginchar(hex"0D",3c_d#,l_h#,p_d#) ; "The right brace (})" ;
  uniarc(2c_d,p_t,(0,h-2c_d),0,90,10) ;
  uniarc(2c_d,p_t,(0,-d+2c_d),270,360,20) ;
  pickup unipensqu ;
  top rt z1 = (w-c_d,h-2c_d) ; bot rt z2 = (w-c_d,-d+2c_d) ;
  draw z1--z2 ;
  rt z3 = (w,(h-d)/2) ; lft z4 = (w-c_d,(h-d)/2) ; draw z3--z4 ;
  penlabels(1,2,3,4) ;
endchar ;

%    \end{macrocode}
% \end{fontcode}
% \begin{fontcode}{\char"0E}
% The paragraph sign is usually in the \texttt{cmsy} family, avaliable
% in \texttt{OT1} encoding only, but for the same reasons as the
% braces above, I decided to include this charater in the font.
%    \begin{macrocode}
beginchar(hex"0E",(l_h#+p_d#+2p_t#)/3,l_h#,p_d#) ;
  "The Paragraph sign" ; 
  uniarc(w/2,p_t,(w/2,h-w/2),30,270,10) ;
  uniarc(w/2,p_t,(w/2,w/2-d),-150,90,20) ;
  unicir(w/2,p_t,(w/2,(h-d)/2),30) ;
endchar ;

%    \end{macrocode}
% \end{fontcode}
% \begin{fontcode}{\char"0F}
% I guess there are no real surprises here --- it's just a bar!
%    \begin{macrocode}
beginchar(hex"0F",p_t#,l_h#,p_d#) ; "The symbol bar (|)" ;
  pickup unipensqu ;
  lft top z1 = (0,h) ; lft bot z2 = (0,-d) ; draw z1--z2 ;
  penlabels(1,2);
endchar ;

%    \end{macrocode}
% \end{fontcode}
% 
% The next two characters is included, since I think it would be a
% good idea to use \universal{} characters for German
% quotation, instead of some Computer Modern Roman character, which
% would be totally out of place.
%
% If you use the \textsf{uni} package you can say
% \begin{verbatim}
%   {\uni
%     \guillemoleft Hello World\guillemoright\newline
%     \guilsinglleft Hello World\guilsinglright}
% \end{verbatim}
% and get
% \begin{quote}
%   {\uni
%     \guillemoleft Hello World\guillemoright\newline
%     \guilsinglleft Hello World\guilsinglright}
% \end{quote}
%
% \begin{fontcode}{\char"22}
% This is quote a simple character. Do notice the nice use of
% \texttt{uniend}, to produce the soft turn.
%    \begin{macrocode}
beginchar(hex"22",2x_w#/3,x_h#,0) ; "The single left guillomot" ;
  z1 = (p_t,h/2) ; z2 = (w,h) ; phi := angle(z2-z1) ;
  uniend(p_t,(z1),90+phi,270-phi,10) ;
  z3 = (w-p_t/sind(phi),h) ; z4 = z1 + p_t*(-sind(phi),cosd(phi)) ;
  path rombe ; rombe := z1--z2--z3--z4--cycle ; fill rombe ;
  fill rombe reflectedabout ((0,h/2),(w,h/2)) ;
  penlabels(1,2,3,4) ;
endchar ;

%    \end{macrocode}
% \end{fontcode}
% \begin{fontcode}{\char"5C}
%    \begin{macrocode}
beginchar(hex"5C",2x_w#/3,x_h#,0) ; "The single right guillomot";
  z1 = (w-p_t,h/2) ; z2 = (0,h) ; phi := 180-angle(z2-z1) ; 
  uniend(p_t,(z1),phi-90,90-phi,10) ;
  z3 = (p_t/sind(phi),h) ; z4 = z1 + p_t*(sind(phi),cosd(phi)) ;
  path rombe ; rombe := z1--z2--z3--z4--cycle ; fill rombe ;
  fill rombe reflectedabout ((0,h/2),(w,h/2)) ;
  penlabels(1,2,3,4) ;
endchar ;

%    \end{macrocode}
% \end{fontcode}
%\iffalse
%</ext>
%\fi
%\iffalse
%<*font>
%\fi
% \section{Font driver files}\file{ful*.mf}
%
% This section describes the driver files
% \texttt{uni}\meta{series}\meta{shape}\meta{size}\texttt{.mf}, where
% \meta{series} is one of \texttt{r} (medium), or \texttt{bf}
% (boldface), \meta{shape} one of upright (no letter), \texttt{sl}
% (slanted), or \texttt{sc} (small caps), and \meta{size} is the
% designsize in points, one of 8, 9, 10, 12, or 17.
%
% To make the source file shorter, I employed a little trick,
% exploiting some of the features of the \textsf{docstrip}
% program. That, on the other hand means that the line numbers you see
% here, doesn't conform to the actual ones in the driver files.
%
% First we make sure the base file \texttt{unibase.mf} is loaded, but
% not more then once in a run. This is needed since this file contains
% all the macros and definitions for the font.
% 
%    \begin{macrocode}
if unknown unibase : input unibase; fi;

%    \end{macrocode}
% Next we define some \textsl{boolean} variables, determining the
% shape of the font we are to create. This are straight forward, and
% should be self explanetory. Any number of variables may be set to
% \texttt{true}, execpt that it makes no sense to define both
% \texttt{bold} and \texttt{medium} to \texttt{true}, so this will be
% considered an error, and a medium font will be made. (See alse the
% explanation of the \texttt{start\_font} macro in the
% \texttt{unibase.mf} section.)
%
% \begin{verbatim}
%<+medium>medium := true ;
%<+bold>bold := true ;
%<+slanted>slant := true ;
%<+caps>caps := true ;
%<+strict>strict := true ; 
%<+eight>start_font(8pt#) ;
%<+nine>start_font(9pt#) ;
%<+ten>start_font(10pt#) ;
%<+twelve>start_font(12pt#) ;
%<+seventeen>start_font(17pt#) ;
%\end{verbatim}
%
% The next part of the files just inputs the nessecary source files,
% and there is nothing special here. Finally we end the font with the
% macro \texttt{end\_font}.
%    \begin{macrocode}
input uniupp ; input unilow ; input unidig ; input unispe ;
input unilig ; input unipun ; input uniacc ; input uniext ;

end_font;

%    \end{macrocode}
%\iffalse
%</font>
%\fi
%\iffalse
%<*docpackage>
%\fi
% \section{Commands for the Documentation --- \texttt{unidoc.sty}}
% \file{unidoc.sty}\label{app:unidoc}
%
% \textsc{Warning:} Most of the macros defined in this file uses
% \TeX{} primitivs like \Lcs{def} and \Lcs{let}, contorary to the
% recommendations in \clsguide{}. This means you shouldn't try to use
% this package in conjunction with normal \LaTeXe{} documents, since
% it will not nessecarily by portable, and may generate unwanted
% resaults. This package is \emph{only} intended for the documentation
% of the \universal{} package, \emph{and nothing else!}
%
% \subsection{Initializing}
% 
% First we need to identify the package, its version and release 
% date, etc.
%    \begin{macrocode}
\def\fileversion{v2.0}
\def\filedate{98/08/01}
\ProvidesPackage{unidoc}[\filedate\space\fileversion\space universal
                         documenation package.]
%    \end{macrocode}
% Then we load some pacakges needed. \textsf{doc} is ofcourse needed
% to do all the actual typesetting of macros etc., while \textsf{uni}
% is needed for the fonts\footnote{This means ofcourse, that you
% needed to have all the \MF{} sources ready, or in other words, you
% should have run \texttt{uni.ins} through \LaTeX{}.}, and finally
% \textsf{mflogo} is needed for the \MF{} logo.
%    \begin{macrocode}
\newif\ifeepic\eepicfalse
\DeclareOption*{\PassOptionsToPackage{\CurrentOption}{uni}}
\ProcessOptions\relax
\RequirePackage{doc}
\RequirePackage{mflogo}
\RequirePackage{uni}
\IfFileExists{eepic.sty}{%
  \RequirePackage{eepic}\eepictrue}{%
  \PackageWarning{unidoc}{`eepic.sty' not found, so there will be no
    pictures - you are warned.}\eepicfalse}

%    \end{macrocode}
%
% \subsection{Macros for the Index}
% 
% \begin{macro}{\file}
% First we save the argument --- the current output filename --- in a
% command, set the codeline counter to zero (since every starts at
% line 1, obviously). Then we check to see if we are outputting files
% at all. If we are, we write an index entry.
%    \begin{macrocode}
\def\file#1{
  \def\c@r{#1}
  \c@CodelineNo0
  \if@filesw
    \immediate\write\@indexfile
    {\string\indexentry{#1=\string\texttt{#1}%
        \string\space(File)}%
    {\thepage}}\fi}

%    \end{macrocode}
% \end{macro}
% \begin{macro}{\main}
% This command is used be \texttt{doc.sty}, to choose the font for the
% codelines numbers in the index. It is set to \texttt{typewriter}.
%    \begin{macrocode}
\def\main#1{\texttt{{\small\c@r}:\ #1}}

%    \end{macrocode}
% \end{macro}
% \begin{macro}{\src}
% To make the index reflect, that more then one file is present, and
% therefore more then one entry could have the same codeline number,
% we put the file name before the codeline number in the index. The
% name is gotten from the \Lcs{file} command. This ofcourse takes up
% quite some space in the index, so later on we speciffy the index
% to only have 2 columns.
%    \begin{macrocode}
\def\src#1#2{\texttt{{\small#1}:\ #2}}

%    \end{macrocode}
% \end{macro}
% \begin{macro}{\fontcodeindex}
% The next two commands are responsible for writting the index entries
% of the above environments. They are similar to the \texttt{doc}
% package command \Lcs{codeline@wrindex} but uses the filenames
% defined by \Lcs{file} (via  the \Lcs{src} command), and the
% \Lcs{fontcodeindex} uses a font appropiat for the font descriped
% (i.e., \Lcs{FontCodeFont}) 
%    \begin{macrocode}
\def\fontcodeindex#1{%
  \@bsphack\begingroup\let\_=\protect\_%
  \special@index{%
    \expandafter\string#1\actualchar%
    {\string\FontCodeFont\space#1}%
    \encapchar src{\c@r}}\endgroup\@esphack}

%    \end{macrocode}
% \end{macro}
% \begin{macro}{\fontmacroindex}
%    \begin{macrocode}
\def\fontmacroindex#1{%
  \@bsphack\begingroup\let\_=\protect\_%
  \special@index{%
    \expandafter\string#1\actualchar%
    {\string\MacroFont\space#1}%
    \encapchar src{\c@r}}\endgroup\@esphack}
  
%    \end{macrocode}
% \end{macro}
%
% \subsection{Descriptive Environments}
% 
% The next counters are to do some more advanced stuff on the on line
% numbers in the index. Instead of just writting the beginning line of
% the fontcode, we writte the complete interval of the fontcode. See
% also the command \Lcs{f@ntcodeindex} and \Lcs{f@ntmacroindex}.
%    \begin{macrocode}
\newcount\startfontcodeline 
\newcount\startfontmacroline

%    \end{macrocode}
% \begin{macro}{\fontcode}
% \begin{macro}{\endfontcode}
% \begin{macro}{\FontCodeFont}
% Next comes two environments for descriping the font programs, and
% font macros. They are similar to the environment \texttt{macro} in
% the \texttt{doc} package. However, some alterations is made, so that
% the right font is used in the index. (See also the
% \Lcs{fontcodeindex} macro below.) Also, notice the defintion of
% \Lcs{saved@macroname} and \Lcs{PrintFontName}. This is done so that
% control sequnces in the argument to \texttt{fontcode} environment,
% which should expand to a single letter, comes out expanded, rather
% then the actual control sequences, which isn't wanted here.
%    \begin{macrocode}
\def\fontcode#1{
  \def\saved@fontname{#1}
  \let\temp@MF\MacroFont\let\MacroFont\FontCodeFont
  \let\temp@PMN\PrintMacroName\let\PrintMacroName\PrintFontName
  \let\temp@SMI\SpecialMainIndex
  \let\SpecialMainIndex\fontcodeindex
  \macro{#1}}
\def\endfontcode{
  \endmacro
  \let\MacroFont\temp@MF
  \let\SpecialMainIndex\temp@SMI
  \let\PrintMacroName\temp@PMN}
\let\FontCodeFont\unibf
\def\PrintFontName#1{\strut\MacroFont\saved@fontname\ }

%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
% \begin{macro}{\fontmacro}
% \begin{macro}{\endfontmacro}
% This is similar to \texttt{fontcode} environment, but is used to
% descripe the macros of \texttt{unibase}. The reason why we employ to
% environments, and not just one, is that the margin notes should come
% out in \texttt{typewriter} font in this environment, while it
% should be in \universal{} font above. 
%    \begin{macrocode}
\def\fontmacro#1{
  \let\temp@under\_
  \let\_\MacroUnderscore
  \let\temp@SMI\SpecialMainIndex
  \let\SpecialMainIndex\fontmacroindex
  \macro{#1}}
\def\endfontmacro{%
  \endmacro\let\SpecialMainIndex\temp@SMI\let\_\temp@under}
\def\MacroUnderscore{{\char"5F}}

%    \end{macrocode}
% \end{macro}
% \end{macro}
%    \begin{macrocode}
\let\beginillu\ifeepic
\let\illuother\else
\let\endillu\fi

%    \end{macrocode}
%
% \subsection{Useful Commands}
% 
% \begin{macro}{\Newestchanges}
% This macro is intended to be used like the \Lcs{changes} macro of
% the \textsf{doc} package. However, it should only be used on the last
% most change. But rather then just making an entry in the the
% glossary, it will also print a line saying when this macro was last
% changed. This is something like what is done in
% \texttt{ltxguide.cls}, but a bit different, since in that class not
% enough is being done glossary--wise, and too much is done
% margin--wise. When making an update to a macro, the new
% \Lcs{changes} should be made with \Lcs{Newestchanges}, and the old
% \Lcs{Newestchanges} should be renamed to \Lcs{changes}. Notice that
% \texttt{doc.sty} says \Lcs{def}\Lcs{saved@macroname}\texttt{\{\}},
% so we can't say
% \begin{verbatim}
%   \ifx\saved@macroname\relax
% \end{verbatim}
% since \Lcs{relax} \emph{isn't} the same as an empty definition, but
% \Lcs{@empty} is. In the case that \Lcs{saved@macroname} is defined
% to something, then we put a  bullet ($\bullet$) in the margin, and
% attach a footnote to it, where the footnote text contains the proper
% information. Ofcourse this could led to a lot of footnotes, but the
% alternative is to redefine the \texttt{macro} environment, and I
% really didn't have the stomach for that, Sorry. Notice the use of
% \Lcs{@gobble}, that removes the leading `v' in the version number.
%    \begin{macrocode}
\def\Newestchanges#1#2#3{
  \ifx\saved@macroname\@empty%
    \marginpar{\small\raggedright{\sl Change on} #2, {\sl Version}
      \expandafter\@gobble#1}
  \else%
    \llap{$\bullet$\footnote{{\sl Change of }
        {\MacroFont\expandafter\string\saved@macroname} 
        {\sl on} #2, {\sl Version }\expandafter\@gobble#1}}
  \fi
  \changes{#1}{#2}{#3}}

%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\Lcs}
% Finally we define a short hand for \Lcs{...}, to make the
% documentaion easier.
%    \begin{macrocode}
\def\Lcs#1{\texttt{\char"5C{}#1}}

%    \end{macrocode}
% \end{macro}
%
% \subsubsection{The Font Charts}
% 
% \begin{macro}{\FontChart}
% This macro is for typesetting a table of the font. It is taken from
% \texttt{testfont.tex}.
%
% First we define some counters to use in the table. \Lcs{n} is the
% counts the number of letters and symbols typeset so far, while
% \Lcs{m} is counting the number of typeset characters in current
% line. \Lcs{p} is a penalty counter. The dimension \Lcs{dim} is used
% for setting the characters appropiate.
%
% We also define a new \Lcs{if}, used to see if we should go on.
%
% \Lcs{oct} and \Lcs{hex} are used for typesetting numbers in
% octadecimal and hexadecimal notation respectivily.
%    \begin{macrocode}
\newcount\n\newcount\m\newcount\p\newdimen\dim
\newif\ifskipping
\def\oct#1{\hbox{\rm\'{}\kern-.2em\it#1\/\kern.05em}}
\def\hex#1{\hbox{\rm\H{}\tt#1}} 

%    \end{macrocode}
% \begin{macro}{\setdigs}
% This is used to set the counters \Lcs{n} and \Lcs{m} every time a
% new (double) line is started.
%    \begin{macrocode}
\def\setdigs#1"#2{\gdef\h{#2}
  \m=\n \divide\m by 64 \xdef\0{\the\m}%
  \multiply\m by-64 \advance\m by\n \divide\m by 8 \xdef\1{\the\m}}

%    \end{macrocode}
% \end{macro}
% \begin{macro}{\testrow}
% This is used to see how we should typeset the current row.
%    \begin{macrocode}
\def\testrow{\setbox0=\hbox{\penalty 1\def\\{\char"\h}%
  \\0\\1\\2\\3\\4\\5\\6\\7\\8\\9\\A\\B\\C\\D\\E\\F%
  \global\p=\lastpenalty}}

%    \end{macrocode}
% \end{macro}
% \begin{macro}{\oddline}
% This is used to typeset topmost line of a double line. It basically
% just putting a line and some saces into the chart.
%    \begin{macrocode}
\def\oddline{
  \cr\noalign{\nointerlineskip}\multispan{19}\hrulefill&
  \setbox0=\hbox{\lower 2.3pt\hbox{\hex{\h x}}}\smash{\box0}\cr
  \noalign{\nointerlineskip}}

%    \end{macrocode}
% \end{macro}
% \begin{macro}{\evenline}
% This is used to typeset bottommost line of a double line. It
% basically does the same as \Lcs{oddline}, but also checks to see if
% we need to end the chart or go on.
%    \begin{macrocode}
\def\evenline{
  \loop\skippingfalse
  \ifnum\n<256 \m=\n \divide\m 16 \chardef\next=\m
  \expandafter\setdigs\meaning\next \testrow
  \ifnum\p=1 \skippingtrue \fi\fi
  \ifskipping \global\advance\n 16\repeat
  \ifnum\n=256 \let\next=\endchart\else\let\next=\morechart\fi
  \next}

%    \end{macrocode}
% \end{macro}
% \begin{macro}{\morechart}
% This macro is called every time we need to typeset a new double line
% of the chart.
%    \begin{macrocode}
\def\morechart{
  \cr\noalign{\hrule\penalty5000}
  \chartline \oddline \m=\1 \advance\m 1 \xdef\1{\the\m}
  \chartline \evenline}

%    \end{macrocode}
% \end{macro}
% \begin{macro}{\chartline}
% \begin{macro}{\chartstrut}
% \Lcs{chartline} is called every time we need to typeset a line of
%  the chart. Notice it uses the macro \Lcs{:} to do the
% job. \Lcs{chartstrut} is used to get approiate spacing.
%    \begin{macrocode}
\def\chartline{&\oct{\0\1x}&&\:&&\:&&\:&&\:&&\:&&\:&&\:&&\:&&}
\def\chartstrut{\lower4.5pt\vbox to14pt{}}

%    \end{macrocode}
% \end{macro}
% \end{macro}
% \begin{macro}{\:}
% \begin{macro}{\reposition}
% \begin{macro}{\centerlargechars}
% These macros are used for typesetting the actual characters in the
% chart. \Lcs{:} gives the appropiate space for a character and
% encriments the \Lcs{n} counter, while \Lcs{reposition} places the
% character nicely in the the chart. \Lcs{centerlargechars} does the
% same for {\large large} characters.
%    \begin{macrocode}
\def\:{\setbox0=\hbox{\char\n}%
  \ifdim\ht0>7.5pt\reposition
  \else\ifdim\dp0>2.5pt\reposition\fi\fi
  \box0\global\advance\n 1 }
\def\reposition{
  \setbox0=\vbox{\kern2pt\box0}\dim=\dp0
  \advance\dim 2pt \dp0=\dim}
\def\centerlargechars{
  \def\reposition{\setbox0=\hbox{$\vcenter{\kern2pt\box0\kern2pt}$}}}

%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
% \begin{macro}{\chart}
% \begin{macro}{\endchart}
% These two macros is what starts and ends the chart. \Lcs{chart} sets
% up the appropiate stuff, and writes the top most line in the
% chart. \Lcs{endchart} is called by \Lcs{evenline} if no more
% characters should be typeset, and then it finished everything off,
% plus writes the last line of the chart.
%    \begin{macrocode}
\def\chart{$$\global\n=0
  \halign to\hsize\bgroup
    \chartstrut##\tabskip0pt plus10pt&&\hfil##\hfil&\vrule##\cr 
    \lower6.5pt\null&&&
    \oct0&&\oct1&&\oct2&&\oct3&&\oct4&&\oct5&&\oct6&&\oct7&\evenline}
\def\endchart{
  \cr\noalign{\hrule}
  \raise11.5pt\null&&&\hex 8&&\hex 9&&\hex A&&\hex B&
  &\hex C&&\hex D&&\hex E&&\hex F&\cr
  \egroup$$\par}

%    \end{macrocode}
% \end{macro}
% \end{macro}
% Finally we get to the \emph{real} macro. This macro takes one
% argument, the name of the \meta{font driver file}. We put the chart
% inside a \texttt{figure} environment, so that we may refer to it
% latter. This is done using the label \texttt{chart:}\meta{font driver
% file}. The chart is encapsulated in a group, so that the definition
% of \Lcs{chart@font} doesn't get in the way elsewhere in the document.
%    \begin{macrocode}
\def\FontChart#1{
%%   \marginpar{\small\raggedright Letters and symbols in \texttt{#1} 
%%      font.} 
  \begin{figure}
    \begingroup
      \font\chart@font=#1
      \chart@font
      \chart
   \endgroup
\end{figure}}

%    \end{macrocode}
% \end{macro}
%
% \subsection{Parameters and Miscillaneous Commands}
% 
% This is used --- as explaind in \texttt{doc.dvi} --- to give a
% different prologue to the index, more suitable to our needs.
%    \begin{macrocode}
\IndexPrologue{%
  \section{Index}\markboth{Index}{Index}
  The Numbers written in \textit{italic} refer to the pages, where
  a macros usage is descriped, while those in \texttt{typewrite} refer 
  to line numbers in the files, mentioned before, where the definition 
  is, while \textsl{slanted} shows the places it is used. Normal letters 
  refer to pages, wether it be descriptions or usage.}
\GlossaryPrologue{%
  \section{Change History}\markboth{Change History}{Change History}
  Below is listed the changes made to the \universal{} font and the
  \LaTeX{} support package \textsf{uni}, from version~1.0 to 2.0.}

%    \end{macrocode}
% Also we set the number of columns in the index to 2, since some
% space is needed for the entries
%    \begin{macrocode}
\setcounter{IndexColumns}{2}

%    \end{macrocode}
% We don't want the index flutted with silly command sequences, so we
% leave some of them out.
%    \begin{macrocode}
\DoNotIndex{\@bsphack,\@empty,\@esphack,\@gobble,\@ifnextchar,%
  \@ifundefined,\@indexfile,\@onlypreamble,\iffalse,\_,\,\accent,%
  \aftergroup,\actualchar,\advance,\begin,\begingroup,\bgroup,%
  \box,\bullet,\changes,\char,\chardef,\CheckModules,\CodeLineIndex,%
  \cr,\crcr,\csname,\DeclareFontFamily,\DeclareFontShape,\DeclareMacro,%
  \dim,\divide,\dp,\DeclareOption,\def,\DoNotIndex,\edef,\egroup,\else,%
  \end,\endcsname,\EnableCrossrefs,\encapchar,\endgroup,\endmacro,%
  \expandafter,\fbox,\fi,\font,\footnote,\fontemcoding,\fontfamuliy,%
  \fontseries,\fontshape,\gdef,\global,\H,\h,\halign,\hbox,\hfil,%
  \hidewidth,\hrule,\hrulefill,\hsize,\ht,\hyphenchar,\if@filesw,%
  \ifdim,\IfFileExists,\ifnum,\ifskipping,\ifx,\immediate,\indexentry,%
  \it,\itdefault,\kern,\lastpenalty,\LaTeX,\LaTeXe,\leavevmode,\let,%
  \llap,\loop,\lower,\m,\macro,\MacroFont,\marginpar,\marginparwidth,%
  \markboth,\mdseries,\meaning,\multiply,\multispan,\n,\newcommand,%
  \newcount,\newdimen,\newif,\newline,\next,\noalign,\noexpand,%
  \nointerlineskip,\not@math@alphabet,\null,\ooalign,\p,\par,\penalty,%
  \ProcessOptions,\protect,\ProvidesFile,\ProvidesPackage,%
  \RecordChanges,\raggedright,\raise,\relax,\renewcommand,\repeat,%
  \RequirePackage,\rm,\saved@macroname,\scshape,\section,\selectfont,%
  \setcounter,\setbox,\show,\skippingfalse,\skippingture,\sl,\slshape,%
  \small,\smash,\space,\special@index,\SpecialMainIndex,\stop,\string,%
  \strut,\tabskip,\TeX,\TeXbook,\textit,\textsf,\textsl,\texttt,\the,%
  \thepage,\tt,\typeout,\unhbox,\universal,\upshape,\usefont,\vbox,%
  \vcenter,\vrule,\write,\xdef,\z@}

%    \end{macrocode}
% And then we define the behaviour of the \textsf{doc} package, by
% setting a number of flags (as explained in the documentation of the
% \textsf{doc} package). We also set the margin paragraph widths to be
% a bit smaller then usual.
%     \begin{macrocode}
\EnableCrossrefs
\CodelineIndex
\RecordChanges
\CheckModules
\marginparwidth=54pt
\newcommand{\NFSS}{\textsf{NFSS}}
\newcommand{\ftnguide}{\textit{\LaTeXe{} Font Selection}}
\newcommand{\clsguide}{
  \textit{\LaTeXe{} for Class and Packages Writers}}
\newcommand{\TeXbook}{\TeX\textsf{book}}
\newcommand{\MFbook}{\MF\textsf{book}}
\newcommand{\universal}{\textunibf{universal}}

%    \end{macrocode}
%\iffalse
%</docpackage>
%\fi
% \Finale
% \appendix
%
% \section{Solution to the \Lcs{bauhausforms} problem}
% \label{app:solu}
%
% \subsection{The Problem}
% This I owe to Joseph Collins \texttt{<collins@ARL.MIL>}.
%
% During the preperation of version~1.0 of this font, I was loosing
% sleep over what I chose to call `The \Lcs{bauhausforms}
% problem', after the problems the symbol \textuni{\bauforms} gave
% me. 
%
% As can be seen from the symbol, the idea is to make a figure out of
% a circle, a square, and a triangle. From these three figures you can
% ofcourse make infinitly many figures, even though the sizes are
% limited. The particular combination of the three figures I was
% looking, first seemed simple\footnote{And after having seen Mr.\
% Collins solution, it did again.}, but turned out to be
% difficult. What I wanted to do was (see also
% figure~\ref{fig:bauforms}):
% \begin{quote}
%   Take a circle of some radius (e.g., 1). Inside this circle draw a
%   isosceles triangle $\bigtriangleup ABC$, with all vertices on the
%   circle, The singular vertice $A$ placed on the horizontal line
%   traveling left from the center of the circle.
%
%   Now draw a square $\Box PQRS$ inside of the circle, having two
%   vertices on the circle, and two on the triangle.
%
%   The wanted triangle and square are such that, the opposing side of
%   the singular vertice $|BC|$ should divede the square into to equal
%   oblongs, i.e., intersect $|PQ|$ midway between $P$ and $Q$.
% \end{quote}
%
% \begin{figure}[htbp]
%   \centering
%   \beginillu
%     \setlength{\unitlength}{.05\textwidth}
%     \begin{picture}(10,10)
%       \thinlines
%       \put(-1,5){\line(1,0){12}}
%       \put(5,-1){\line(0,1){12}}
%       \thicklines
%       \put(5,5){\circle{10}}
%       \put(0,5){\line(100,74){6.521}}
%       \put(0,5){\line(100,-74){6.521}}
%       \put(6.4330,0.2097){\line(0,1){9.5805}}
%       \put(3.6873,7.7457){\line(1,0){5.4914}}
%       \put(3.6873,2.2543){\line(1,0){5.4914}}
%       \put(3.6873,2.2543){\line(0,1){5.4914}}
%       \put(9.1787,2.2543){\line(0,1){5.4914}}
%       \put(0,5){\mbox{$A$}}
%       \put(6.4330,0.2097){\mbox{$B$}}
%       \put(6.4330,5){\mbox{$B^\prime$}}
%       \put(6.4330,9.7903){\mbox{$C$}}
%       \put(3.6873,2.2543){\mbox{$P$}}
%       \put(3.6873,5){\mbox{$P^\prime$}}
%       \put(9.1787,2.2543){\mbox{$Q$}}
%       \put(9.1787,5){\mbox{$Q^\prime$}}
%       \put(9.1787,7.7457){\mbox{$R$}}
%       \put(3.6873,7.7457){\mbox{$S$}}
%       \put(5,5){\mbox{$O$}}
%       \put(0,5){\arc{1}{0}{0.6401}}
%       \put(0,4.5){\mbox{$\varphi$}}
%     \end{picture}
%   \illuother
%     \begin{tabular}{%
%     @{\vline\extracolsep{1em}\space}%
%     p{.8\textwidth}%
%     @{\space\vline}}
%       \hline
%       Since you are processing this document without the
%       \textsf{eepic} package, you will not see the illustration
%       otherwise here. To compensate, I will give you a short
%       description on how to draw the figure yourself.
%       
%       Take out some paper, a pencil, compasses, and a ruler. Now
%       draw a circle of some radius $r$, with its center in origo of
%       a Cartisean coordinate system. In the next subsection, you
%       will find the coordinates for points $A,B,C,O,P,Q,R,$ and $S$
%       expressed in terms of $x,y,$ and $h$. You will also find the
%       correct values for $x,y,h$ in that section. Multiply those
%       values with $r$, and plot the points above in the coordinate
%       system. Draw the triangle $\bigtriangleup ABC$, and the square
%       $\Box PQRS$, and --- voila, you have the  illustration.\\
%       \hline
%     \end{tabular}
%   \endillu
%   \caption{The \Lcs{bauforms} problem.}\label{fig:bauforms}
% \end{figure}
% 
% This shouldn't be to difficult, should it. Well I didn't think so,
% but after many late evenings with pen, paper, ruler, compasses, and
% heavy use of trigonometric relations, I found out that the half
% $\varphi$ of the singular vertice should obey:
% \begin{eqnarray}
% 0 &=& \sin \left( \cos^{-1} \left( \frac{\cos2\varphi}{\sqrt{2}}
%         \right) \right) - \frac{\cos2\varphi}{\sqrt{2}}\nonumber\\
% & & - 2\sqrt{2}
%       \frac{\cos\varphi^2\sin\varphi}{\cos\varphi+\sin\varphi}
%       \nonumber  
% \end{eqnarray}
% Now I dare you to find the exact solution to that.
%
% Using numerical methodes (Newton's method), was ofcourse no
% problem, and gave satesfactory resualt. If the expression on the
% right above is labelled $f$, $f^\prime$ is:
% \begin{eqnarray}
% f^\prime &=& \frac{\sin4\varphi}{2\sqrt{\frac{3-\cos4\varphi}{4}}}
%    + \sqrt{2}\sin2\varphi\nonumber\\
% & & - \frac{2\sqrt{2}\cos\varphi}{\cos\varphi+\sin\varphi^2}
%       \left( \left( \cos\varphi+\sin\varphi \right)
%          \left( \cos^2\varphi-2\sin^22\varphi \right)\right. \nonumber\\ 
% & & - \quad \left.\left( \cos\varphi-\sin\varphi \right)
%          \cos^2\varphi\sin\varphi \right) \nonumber
% \end{eqnarray}
% Using these expressions for $f$ and $f^\prime$ in a \textsf{Fortran}
% program, I reached resaults close to what Mr.\ Collins found.
%
% \subsection{Joseph Collins' Solution}
%
% In Mr.\ Collins notation, the points on figure~\ref{fig:bauforms}
% has the following coordinates:
% \begin{eqnarray*}
%   A = (0,-1)  & B^\prime = (x,0)   & C = (x,y)\\
%   O = (0,0)   & P^\prime = (x-h,0) & Q^\prime = (x+h,0)\\
%   R = (x+h,h) & S = (x-h,h) & \\
% \end{eqnarray*}
% Below is what Mr.\ Collins wrote me --- thank you very much.
%
% On the unit circle
% \begin{equation}\label{eq:uc}
%   x^2 + y^2 = 1
% \end{equation}
% we have the vertices of a triangle at $(-1,0)$, $(x,y)$, and
% $(x,-y)$. A square has four vertices $(x \pm h, \pm h)$, where the
% two points $(x-h, \pm h)$ lie on the triangle (constraint A) and the
% two points $(x+h, \pm h)$ lie on the circle (constraint B).  Thus,
% the vertical side of the triangle bisects the square.  From
% constraint A, upon consideration of similar triangles, we have
% $$\frac{y}{1+x} = \frac{h}{1+x-h}, \quad \mbox{so that}\quad
%   h =  \frac{(1+x) y }{1+x+y}.$$
% By (\ref{eq:uc}), this is
% \begin{equation} \label{eq:b1}
%   h = \frac{(1+x)\sqrt{1-x^2}}{1+x+\sqrt{1-x^2}} .
% \end{equation}
% From constraint B, we get
% \begin{equation} \label{eq:b2}
%   (x+h)^2 + h^2 = 1  .
% \end{equation}
% Any simultaneous solution of (\ref{eq:b1}) and (\ref{eq:b2}) is also a
% solution of
% \begin{equation}\label{eq:eqn}
%   8x^3 - 4x^2 - 3x + 1 = 0,
% \end{equation}
% the relevant solution being
% \begin{equation}  \label{eq:sol}
%   x = \frac16 + \sqrt{\frac{11}{18}} \sin
%   \left[ \frac{\pi}{6}
%     - \frac13 \arctan\left(\frac{3\sqrt{237}}{23}\right) \right].
% \end{equation}
% Equation (\ref{eq:eqn}) and solution (\ref{eq:sol}) courtesy of
% Mathematica. We get $y$ and $h$ from (\ref{eq:uc}) and
% (\ref{eq:b1}), respectively. The angle at $(-1,0)$ is $\varphi = 2
% \arctan\bigl(y/(1+x)\bigr)$. 
%
% Approximate values are
% \begin{eqnarray*}
%   x &\simeq& 0.2865914\\
%   y &\simeq&  0.9580529\\
%   h &\simeq& 0.5491394 \\
%   \varphi &\simeq&  1.280129 \ ( \simeq  73.346^o)
% \end{eqnarray*}
% 
% \section{Copyrights --- GNU General Public Lisence}
% \label{app:ggpl}
%
% This \MF{} implementation of the ``universal'' font and the \LaTeX{}
% support package ``uni'' copyright \copyright{} 1998  Christian Holm.
%
% This program is free software; you can redistribute it and/or modify
% it under the terms of the GNU General Public License as published by
% the Free Software Foundation; either version 2 of the License, or
% (at your option) any later version. 
%
% This program is distributed in the hope that it will be useful, but
% \textsc{without any warranty}; without even the implied warranty 
% of \textsc{merchantability} or \textsc{fitness for a particular
% purpose}. See the GNU General Public License for more details.
%
% You should have received a copy of the GNU General Public License
% along with this program; if not, write to
% \begin{quote}
%   The Free Software Foundation, Inc.\\
%   675 Mass Ave\\
%   Cambridge\\
%   MA 02139\\
%   USA
% \end{quote}
%
% See the file \texttt{copyright} in the distribution for the complete
% GNU General Public License.
% 
% You can reach the me (the copyright holder) at
% \begin{quote}
%   Christian Holm\\
%   Sankt Hansgade 23, 1.\ th.\\
%   DK--2200 Copenhagen N\\
%   Denmark\\
%   E--mail: \texttt{cholm@nbi.dk} or \texttt{cholm@fys.ku.dk}
% \end{quote}
% 
% \section{Wishlist}
%
% Below is a list of things I would like to do with the font and
% package. If anyone has any suggestions, ready--made code, or new
% ideas, please let me know.
%
% If you would like to take on one or more of the tasks presented
% below, please do so, but send me a note so that I may coordinate
% with my own efforts, and perhaps have a constructive dicourse.
% 
% I should however instruct you to read the \emph{complete}
% documentation of the package and font, since this may give some
% reasons why I have chosen a particular approach.
%
% \begin{itemize}
% \item Make the font an 8--bit encoded (256 characters) font,
%   conforming somewhat to the \texttt{T1} encoding of the Cork fonts.
% \item Making a package (perhaps \textsf{mfdoc}), to make
%   documentation of \MF{} sources, just like \textsf{doc} is fore
%   \LaTeX{} sources. This is ofcourse a independent project, and I
%   will proberly not work on it.
% \end{itemize}
% \clearpage
% \section{Font Charts}
% \label{app:charts}
%
% Below are some charts of the \universal{} font in different series
% and shapes (medium upright, bold upright, medium slanted, medium
% small caps), all in size \texttt{8pt}.
% 
% \FontChart{fulmr8.mf}
% \FontChart{fulmo8.mf}
% \FontChart{fulmc8.mf}
% \FontChart{fulmst8.mf}
% \FontChart{fulbr8.mf}
% \clearpage
